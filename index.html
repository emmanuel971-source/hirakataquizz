<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>150 voyelles MP3 gratuites – Google Translate TTS</title>
<style>
  body { font-family: Arial, sans-serif; max-width: 1000px; margin: 40px auto; padding: 20px; background: #f9f9f9; line-height: 1.6; }
  h1 { color: #d81e5b; }
  input, button { font-size: 16px; padding: 10px; margin: 8px; }
  button { background: #d81e5b; color: white; border: none; border-radius: 6px; cursor: pointer; }
  #status { margin: 20px 0; font-weight: bold; color: #333; }
  #log { font-family: monospace; font-size: 13px; max-height: 320px; overflow-y: auto; border: 1px solid #ccc; padding: 12px; background: white; }
</style>
</head>
<body>

<h1>150 fichiers MP3 (30 variantes × A / É / I / O / U) – 100% gratuit</h1>
<p>Utilise l’ancien moteur Google Translate TTS (fr + fr-CA + variations pitch/vitesse).</p>

<button onclick="generateAll()" style="font-size:18px; padding:14px 32px;">
  ▶ Lancer la génération des 150 fichiers
</button>

<div id="status">Prêt… (cela prendra 4–10 min selon votre connexion)</div>
<div id="log"></div>

<script>
const vowels = [
  {letter: "A", text: "a"},
  {letter: "É", text: "é"},
  {letter: "I", text: "i"},
  {letter: "O", text: "o"},
  {letter: "U", text: "u"}
];

const langs = ["fr", "fr-CA"];  // les deux seuls accents vraiment différents

// 30 variations (15 par langue)
const variations = [];
for (let i = 0; i < 30; i++) {
  const lang = langs[i % 2];
  const rate = 0.75 + (i % 15) * 0.042;          // ≈ 0.75 → 1.35
  const pitch = -5 + Math.floor(i / 2) * 0.8;    // ≈ -5 → +6.8
  variations.push({lang, rate, pitch});
}

async function getAudioBase64(text, lang, rate, pitch) {
  // SSML basique pour aider à contrôler la durée
  const ssmlText = `<speak>${text}<break time="700ms"/></speak>`;

  const url = `https://translate.google.com/translate_tts?` +
    `ie=UTF-8&` +
    `q=${encodeURIComponent(ssmlText)}&` +
    `tl=${lang}&` +
    `total=1&` +
    `idx=0&` +
    `textlen=${text.length}&` +
    `client=tw-ob&` +           // "tw-ob" = user-agent-like qui passe encore souvent
    `ttsspeed=${rate}`;

  // Note : pitch n'est pas supporté directement → on simule via rate + petite astuce SSML si besoin
  // → ici on reste sur rate + langue pour la variation principale

  try {
    const response = await fetch(url, {
      headers: {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
      }
    });

    if (!response.ok) throw new Error(`HTTP ${response.status}`);

    const blob = await response.blob();
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result.split(',')[1]); // base64 sans prefix
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  } catch (e) {
    throw new Error(`Erreur fetch → ${e.message}`);
  }
}

async function generateAll() {
  const status = document.getElementById("status");
  const log = document.getElementById("log");
  log.innerHTML = "";
  status.textContent = "Démarrage... (patience, Google limite parfois les requêtes rapides)";

  let count = 0;
  let ok = 0;

  for (const v of vowels) {
    for (const [idx, var] of variations.entries()) {
      count++;
      status.textContent = `(${ok}/${count-1})  ${v.letter} #${idx+1}   (${var.lang} | vitesse ${var.rate.toFixed(2)})`;

      try {
        const base64 = await getAudioBase64(v.text, var.lang, var.rate, 0);

        const binary = atob(base64);
        const bytes = new Uint8Array(binary.length);
        for (let j = 0; j < binary.length; j++) bytes[j] = binary.charCodeAt(j);

        const blob = new Blob([bytes], {type: "audio/mp3"});
        const url = URL.createObjectURL(blob);

        const a = document.createElement("a");
        a.href = url;
        a.download = `${v.letter}_v${String(idx+1).padStart(2,'0')}_${var.lang}_r${var.rate.toFixed(2)}.mp3`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        log.innerHTML += `OK ${v.letter} #${idx+1} – ${var.lang}<br>`;
        ok++;
      } catch (err) {
        log.innerHTML += `Échec ${v.letter} #${idx+1} – ${err.message}<br>`;
      }

      await new Promise(r => setTimeout(r, 1200));  // pause plus longue → évite blocage Google
    }
  }

  status.textContent = `Terminé ! ${ok} / ${count} fichiers générés.`;
}
</script>
</body>
</html>
