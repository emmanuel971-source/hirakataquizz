<!DOCTYPE html>
<html>
<head>
<link rel="icon" href="data:,">
<base target="_top">
<style>
html {
touch-action: pan-x pan-y;
-ms-touch-action: pan-x pan-y;
}

* {
user-select: none;
-webkit-user-select: none;
-webkit-touch-callout: none;
-webkit-tap-highlight-color: transparent;
}

body {
background: #F8F1E9;
font-family: 'Noto Sans JP', sans-serif;
color: #8B6F47;
font-family: sans-serif;
text-align: center;
padding: 0.5em 1em 1em 1em;
margin: 0;
height: 100vh;
overflow: hidden;
display: flex;
flex-direction: column;
}

body::before {
content: '';
position: absolute;
top: 0;
left: 0;
background: url('https://www.transparenttextures.com/patterns/paper-fibers.png');
opacity: 0.1;
z-index: -1;
}

h1 {
margin: 0.5em 0;
font-size: 1.8em;
text-align: center;
color: #8B6F47;
text-shadow: 0 1px 2px rgba(139, 111, 71, 0.3);
}

@media screen and (max-width: 400px),
screen and (-webkit-min-device-pixel-ratio: 2),
screen and (min-resolution: 192dpi) {
h1 {
font-size: 3em;
margin: 0.3em 0;
}
}

@media screen and (-webkit-min-device-pixel-ratio: 2) and (max-width: 800px) {
h1 {
font-size: 2.2em;
margin: 0.15em 0;
}
}

h2 {
margin: 0.5em 0;
font-size: 3em;
text-align: center;
color: #8B6F47;
text-shadow: 0 1px 2px rgba(139, 111, 71, 0.3);
}

@media screen and (max-width: 400px),
screen and (-webkit-min-device-pixel-ratio: 2),
screen and (min-resolution: 192dpi) {
h2 {
font-size: 4em;
margin: 0.1em 0;
}
}

@media screen and (-webkit-min-device-pixel-ratio: 2) and (max-width: 800px) {
h2 {
font-size: 4em;
margin: 0.15em 0;
}
}


#progressBarContainer {
display: flex;
align-items: center;
justify-content: space-between;
gap: 0.5em;
margin: 1em auto 0.3em auto;
max-width: 40ch;
width: 100%;
}

.progress-bar-track {
position: relative;
height: 16px;
background: linear-gradient(to right, #E0F7FA, #355E3B);
border-radius: 6px;
flex: 1;
box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.progress-marker {
position: absolute;
top: 45%;
left: 0;
transform: translate(-50%, -50%);
font-size: 2em;
transition: left 1.5s ease;
color: #636E72;
}

.side-emoji {
font-size: 1.6em;
line-height: 1;
color: #636E72;
}

@keyframes pulse {
0% { transform: translate(-50%, -50%) scale(1); }
100% { transform: translate(-50%, -50%) scale(1.2); }
}

@media screen and (max-width: 768px), screen and (-webkit-min-device-pixel-ratio: 2) {
#progressBarContainer {
max-width: 80%;
margin: 1.5em auto 0.5em auto;
gap: 1em;
}

.progress-bar-track {
height: 32px;
border-radius: 12px;
}

.progress-marker {
font-size: 4.5em;
top: 45%;
transform: translate(-50%, -50%);
}

.side-emoji {
font-size: 2.5em;
}
}

.level-hiraganas {
margin: 1em auto;
max-width: 800px;
flex-shrink: 0;
}

.hiraganas-grid {
display: flex;
justify-content: center;
gap: 20px;
flex-wrap: wrap;
margin-bottom: 0.5em;
}

.hiragana-card {
text-align: center;
transition: all 0.3s ease;
position: relative;
padding: 10px;
background: #FFFFFF;
border-radius: 8px;
box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25), 0 3px 6px rgba(0, 0, 0, 0.15);
}

.hiragana-card.completed {
background: #DDE6D5;
animation: completedPulse 2s ease-in-out infinite;
}

@keyframes completedPulse {
0%, 100% { transform: scale(1); }
50% { transform: scale(1.05); }
}

.hiragana-char {
font-size: 2.2em;
font-weight: bold;
margin-bottom: 6px;
color: #8B6F47;
text-shadow: 0 0 3px rgba(139, 111, 71, 0.3);
}

.hiragana-card.completed .hiragana-char {
color: #A8D5BA;
text-shadow: 0 0 5px rgba(168, 213, 186, 0.5);
animation: starGlow 2s ease-in-out infinite;
}

.stars-container {
display: flex;
justify-content: center;
gap: 2px;
}

.star {
width: 12px;
height: 12px;
background: #E8ECEF;
clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
transition: all 0.3s ease;
}

.star.filled {
background: #FDC1C5;
}

.star.new-star {
animation: starFill 0.5s ease-in-out;
}

.hiragana-card.completed .star.filled {
background: #A8D5BA;
animation: starGlow 2s ease-in-out infinite;
}

@keyframes starFill {
0% { transform: scale(0) rotate(180deg); }
100% { transform: scale(1) rotate(0deg); }
}

@keyframes starGlow {
0%, 100% { filter: brightness(1); }
50% { filter: brightness(1.3); }
}

.firework {
position: absolute;
top: 0;
left: 50%;
transform: translateX(-50%);
width: 0.5em;
height: 0.5em;
background: transparent;
pointer-events: none;
animation: fireworkExplosion 700ms ease-out forwards;
z-index: 10;
}

@keyframes fireworkExplosion {
0% {
box-shadow: 0 0 #ff0, 0 0 #f00, 0 0 #0ff;
opacity: 1;
transform: translateX(-50%) scale(1);
}
100% {
box-shadow: 0 -40px #ff0, 30px -30px #f00, 40px 0 #0ff, 30px 30px #0f0, 0 40px #00f, -30px 30px #f0f, -40px 0 #fff, -30px -30px #ff0;
opacity: 0;
transform: translateX(-50%) scale(0.5);
}
}

.sakura {
position: absolute;
width: 100px;
height: 10px;
background: #FDC1C5;
border-radius: 50%;
pointer-events: none;
animation: sakuraFall 3s linear forwards;
z-index: 10;
}

@keyframes sakuraFall {
0% { transform: translateY(0) rotate(0deg); opacity: 1; }
100% { transform: translateY(110vh) rotate(720deg); opacity: 0; }
}

@media screen and (max-width: 768px), screen and (-webkit-min-device-pixel-ratio: 2) {
.level-hiraganas {
max-width: none;
width: 100vw;
padding: 0 2em;
box-sizing: border-box;
}

.hiraganas-grid {
display: flex;
flex-wrap: wrap;
justify-content: space-evenly;
gap: 15px;
}

.hiragana-card {
flex: 1 1 auto;
min-width: 80px;
text-align: center;
transition: all 0.3s ease;
position: relative;
padding: 10px;
background: #FFFFFF;
border-radius: 8px;
box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25), 0 3px 6px rgba(0, 0, 0, 0.15);
}

.hiragana-char {
font-size: 4em;
margin-bottom: 10px;
}

.stars-container {
display: flex;
justify-content: center;
gap: 2px;
}

.star {
width: 28px;
height: 28px;
}
}

@media screen and (-webkit-min-device-pixel-ratio: 2) and (max-width: 800px) {
.level-hiraganas {
max-width: none;
width: 100vw;
padding: 0 2em;
box-sizing: border-box;
}

.hiraganas-grid {
width: 100%;
box-sizing: border-box;
display: flex;
flex-wrap: wrap;
justify-content: space-evenly;
gap: 20px;
}

.hiragana-card {
flex: 1 1 120px;
max-width: 140px;
text-align: center;
transition: all 0.3s ease;
position: relative;
padding: 10px;
background: #FFFFFF;
border-radius: 8px;
box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25), 0 3px 6px rgba(0, 0, 0, 0.15);
}

.hiragana-char {
font-size: 6em;
margin-bottom: 10px;
}

.stars-container {
gap: 2px;
}

.star {
width: 14px;
height: 14px;
}
}

.quiz-container {
flex: 1;
display: flex;
flex-direction: column;
justify-content: space-between;
min-height: 0;
padding-bottom: 2em;
}

.question {
font-size: 3.5em;
font-weight: bold;
margin: 0.5em 0;
height: 1.2em;
display: flex;
align-items: center;
justify-content: center;
color: #8B6F47;
text-shadow: 1px 1px 2px rgba(139, 111, 71, 0.4);
}

.answers {
display: flex;
flex-wrap: wrap;
justify-content: center;
gap: 0.8em;
margin-bottom: 1em;
}

@media screen and (max-width: 768px), screen and (-webkit-min-device-pixel-ratio: 2) {
.quiz-container {
flex: 1;
display: flex;
flex-direction: column;
justify-content: flex-start;
min-height: 0;
padding-bottom: 2em;
}

.question {
font-size: 10em;
font-weight: bold;
margin: 0.5em 0;
height: 1.2em;
display: flex;
align-items: center;
justify-content: center;
text-shadow: 1px 1px 2px rgba(139, 111, 71, 0.4);
}

.answers {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
justify-content: center; /* centre le grid */
gap: 0.8em;
margin-bottom: 1em;
width: 100%;
box-sizing: border-box;
padding: 0 1em;
}

.sakura {
width: 20px;
height: 20px;
}
}

.arcade-button {
position: relative;
background: #F5E8C7;
background-image: url('https://www.transparenttextures.com/patterns/light-wood.png');
border: 2px solid #8B6F47;
border-radius: 10px;
padding: 0.8em 1.5em;
color: #8B6F47;
font-size: 1.4em;
line-height: 0.6;
white-space: normal;
font-weight: bold;
cursor: pointer;
box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2), inset 0 2px 2px rgba(255, 255, 255, 0.3);
transition: all 0.15s ease;
text-shadow: 0 0 8px rgba(139, 111, 71, 0.5);
overflow: hidden;
min-width: 120px;
text-align: center;
}

.arcade-button::before {
content: '';
position: absolute;
top: 0;
left: 0;
right: 0;
height: 50%;
background: linear-gradient(to bottom, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0));
border-top-left-radius: 10px;
border-top-right-radius: 10px;
pointer-events: none;
}

.arcade-button:hover {
transform: translateY(-2px) scale(1.02);
box-shadow: 0 6px 10px rgba(0, 0, 0, 0.25), inset 0 2px 2px rgba(255, 255, 255, 0.3);
border-color: #7A5C3A;
}

.arcade-button:active {
transform: translateY(2px) scale(0.98);
box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2), inset 0 1px 1px rgba(255, 255, 255, 0.3);
}

.arcade-button:disabled {
cursor: not-allowed;
opacity: 0.8;
}

.arcade-button.clicked {
opacity: 1 !important;
cursor: default;
}

.arcade-button.clicked-glow {
text-shadow: 0 0 12px #A8D5BA, 0 0 4px #A8D5BA;
animation: glowPulse 1s ease-in-out infinite;
}

.arcade-button.correct {
background: rgba(168, 213, 186, 0.5) !important;
color: #8B6F47;
border-color: #A8D5BA;
background-image: none !important;
animation: correctGlow 0.6s ease-in-out;
opacity: 1 !important;
}

.arcade-button.correct::before {
display: none;
}

.arcade-button.incorrect {
background: rgba(253, 193, 197, 0.5) !important;
color: #8B6F47;
border-color: #FDC1C5;
background-image: none !important;
animation: incorrectShake 0.6s ease-in-out;
opacity: 1 !important;
}

.arcade-button.incorrect::before {
display: none;
}

@keyframes glowPulse {
0%, 100% { text-shadow: 0 0 12px #A8D5BA, 0 0 4px #A8D5BA; }
50% { text-shadow: 0 0 18px #A8D5BA, 0 0 6px #A8D5BA; }
}

@keyframes correctGlow {
0% { box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2), inset 0 2px 2px rgba(255, 255, 255, 0.3); }
50% { box-shadow: 0 6px 10px rgba(0, 0, 0, 0.25), 0 0 20px rgba(168, 213, 186, 0.6); }
100% { box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2), inset 0 2px 2px rgba(255, 255, 255, 0.3); }
}

@keyframes incorrectShake {
0% { transform: translateX(0); }
10% { transform: translateX(-8px); }
20% { transform: translateX(8px); }
30% { transform: translateX(-6px); }
40% { transform: translateX(6px); }
50% { transform: translateX(-4px); }
60% { transform: translateX(4px); }
70% { transform: translateX(-2px); }
80% { transform: translateX(2px); }
90% { transform: translateX(-1px); }
100% { transform: translateX(0); }
}

@media screen and (max-width: 768px), screen and (-webkit-min-device-pixel-ratio: 2), screen and (min-resolution: 192dpi) {
button, a, input, textarea {
-webkit-tap-highlight-color: transparent;
}

.arcade-button {
font-size: 4em;
aspect-ratio: 1 / 0.6;
width: 100%;
box-sizing: border-box;
padding: 0;
display: flex;
align-items: center;
justify-content: center;
text-align: center;
}
}

.result {
animation: fadeIn 0.4s ease-in;
font-size: 1.3em;
line-height: 1.4em;
margin: 0.5em 0 0.2em 0;
min-height: 4.5em;
display: flex;
flex-direction: column;
justify-content: center;
align-items: center;
text-align: center;
color: #8B6F47;
}

.result-line.highlight {
color: #8B6F47;
}

@keyframes fadeIn {
from { opacity: 0; transform: translateY(10px); }
to { opacity: 1; transform: translateY(0); }
}

#continueBtn {
visibility: hidden;
margin: 0.5em auto;
display: block;
width: fit-content;
}

#boutonInstaller {
margin: 0.5em auto;
height: 3em;
display: none;
}

@media screen and (max-width: 768px), screen and (-webkit-min-device-pixel-ratio: 2), screen and (min-resolution: 192dpi) {
.result {
margin-top: 5em;
text-align: center;
word-break: break-word;
white-space: normal;
display: block;
min-height: auto;
}

.result > * {
width: 100%;
}

.result-line {
font-size: 4em;
width: 100%;
text-align: center;
}

.result-line.highlight {
margin-top: 1.2em;
font-size: 3em;
}

.result-line.highlight {
line-height: 1.2;
margin-top: 0.5em;
}

#continueBtn {
margin-top: 1em;
margin-bottom: 1em;
height: 3em;
}

#boutonInstaller {
margin-top: 1em;
margin-bottom: 1em;
height: 3em;
}
}

@media screen and (max-width: 768px), screen and (-webkit-min-device-pixel-ratio: 2), screen and (min-resolution: 192dpi) {
.result {
margin-top: 5em;
}

.result > * {
width: 100%;
}

.result {
text-align: center;
word-break: break-word;
white-space: normal;
display: block;
min-height: auto;
}

.result-line {
font-size: 4em;
width: 100%;
text-align: center;
}

.result-line.highlight {
margin-top: 1.2em;
font-size: 3em;
}

.result-line.highlight {
line-height: 1.2;
margin-top: 0.5em;
}

#continueBtn {
margin-top: 2em;
margin-bottom: 2em;
height: 3em;
width: 100%;
}

visibility: hidden;
}

#boutonInstaller {
margin-top: 1em;
margin-bottom: 1em;
height: 3em;
}

.sakura {
width: 20px;
height: 20px;
}

@media (max-width: 768px) {
.hiraganas-grid {
gap: 15px;
}

.hiragana-char {
font-size: 1.8em;
}

.question {
font-size: 2.8em;
}

.arcade-button {
padding: 0.6em 1.2em;
font-size: 1em;
}
}

@media (max-height: 700px) {
.hiragana-char {
font-size: 1.6em;
margin-bottom: 4px;
}

.question {
font-size: 2.5em;
margin: 0.3em 0;
}

.answers {
gap: 0.6em;
margin-bottom: 0.8em;
}

.arcade-button {
padding: 0.6em 1.2em;
}
}

@media (max-height: 600px) {
.hiragana-char {
font-size: 1.4em;
}

.stars-container {
gap: 1px;
}

.star {
width: 10px;
height: 10px;
}

.question {
font-size: 2.2em;
}

.progress-marker {
font-size: 1.6em;
}

.side-emoji {
font-size: 1.4em;
}
}

@keyframes confettiFall {
0% { transform: translateY(0); }
100% { transform: translateY(110vh) rotate(720deg); }
}

body.shake {
animation: screenShake 0.4s ease-in-out;
}

@keyframes screenShake {
0% { transform: translate(0px, 0px); }
25% { transform: translate(4px, -4px); }
50% { transform: translate(-4px, 4px); }
75% { transform: translate(4px, 4px); }
100% { transform: translate(0px, 0px); }
}

@media screen and (max-width: 768px), screen and (-webkit-min-device-pixel-ratio: 2) {
#progressBarContainer {
max-width: 80%;
margin: 1.5em auto 0.5em auto;
gap: 1em;
}

.progress-bar-track {
height: 32px;
border-radius: 12px;
}

.progress-marker {
font-size: 4.5em;
top: 30%;
}

.side-emoji {
font-size: 2.5em;
}

.level {
font-size: 2.5em;
margin: 0.4em 0;
}
}

@media screen and (-webkit-min-device-pixel-ratio: 2) and (max-width: 800px) {
#progressBarContainer {
max-width: 80%;
margin: 1.5em auto 0.5em auto;
gap: 1em;
}

.progress-bar-track {
height: 32px;
border-radius: 12px;
}

.progress-marker {
font-size: 4.5em;
top: 30%;
}

.side-emoji {
font-size: 2.5em;
}

.level {
font-size: 1.5em;
margin: 0.1em 0;
}
}

/* ✅ NOUVEAU STYLE HAMBURGER - Style carte hiragana */
.hamburger {
position: fixed;
background: #FFFFFF; /* Fond blanc comme les cartes */
border: none; /* Supprime la bordure */
border-radius: 8px; /* Bords arrondis comme les cartes */
color: #8B6F47;
padding: 12px;
cursor: pointer;
z-index: 1000;
/* Ombre identique aux cartes hiragana */
box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25), 0 3px 6px rgba(0, 0, 0, 0.15);
transition: all 0.3s ease;
display: flex;
align-items: center;
justify-content: center;
}

/* Icône hamburger avec 3 barres */
.hamburger-icon {
display: flex;
flex-direction: column;
gap: 4px;
width: 20px;
height: 16px;
}

.hamburger-bar {
width: 100%;
height: 3px;
background: rgba(139, 111, 71, 0.3); /* Marron voilé/discret */
border-radius: 2px;
transition: all 0.3s ease;
}

/* Desktop - hover révèle les barres */
@media (min-width: 769px) {
.hamburger {
top: 20px;
left: 20px;
width: 44px;
height: 44px;
}

.hamburger:hover .hamburger-bar {
background: #8B6F47; /* Marron normal au survol */
}

.hamburger:hover {
box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3), 0 4px 8px rgba(0, 0, 0, 0.2);
transform: translateY(-1px);
}
}

/* Mobile - 2x plus gros */
@media screen and (max-width: 768px), screen and (-webkit-min-device-pixel-ratio: 2), screen and (min-resolution: 192dpi) {
.hamburger {
position: fixed !important;
bottom: 20px !important;
right: 20px !important;
left: auto !important;
top: auto !important;
width: 88px !important; /* 2x plus gros */
height: 88px !important;
padding: 20px;
display: flex;
box-sizing: border-box;
}

.hamburger-icon {
width: 36px;
height: 28px;
gap: 6px;
}

.hamburger-bar {
height: 4px;
background: rgba(139, 111, 71, 0.4); /* Légèrement plus visible sur mobile */
}
}



/* Ajuster la règle générale pour .menu */
.menu {
position: fixed;
top: 0;
right: 0;
width: 100%;
height: 100%;
background: rgba(248, 241, 233, 0.95); /* Voile blanc cassé */
display: flex;
flex-direction: column;
justify-content: center;
align-items: center;
gap: 15px;
transform: translateX(100%);
transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
opacity: 0;
z-index: 999;
}

.menu.active {
transform: translateX(0);
opacity: 1;
}

.menu .arcade-button {
width: 300px !important; /* Plus large que les 200px actuels */
height: 80px !important; /* Hauteur fixe pour tous */
min-height: 80px !important; /* Force la hauteur minimum */
max-height: 80px !important; /* Limite la hauteur maximum */
line-height: 80px !important; /* Centre le texte verticalement */
padding: 0 1.5em !important; /* Padding horizontal seulement */
font-size: 1.6em !important; /* Taille de police cohérente */
box-sizing: border-box !important;
}



/* Garde ton code Firefox intact */
@media screen and (max-width: 768px), screen and (-webkit-min-device-pixel-ratio: 2), screen and (min-resolution: 192dpi) {
.menu .arcade-button {
width: 600px !important;
font-size: 2.8em !important;
padding: 0.1em 1em !important;
line-height: 120px !important; /* ← Centre le texte */
height: 120px !important; /* ← Hauteur fixe pour TOUS */
max-height: 120px !important; /* ← Remplace l'ancien 2.5em */
}

/* Correction spécifique Chrome */
@supports (-webkit-appearance: none) {
.menu .arcade-button {
width: min(80vw, 500px) !important; /* Plus conservateur */
height: 120px !important; /* ← Hauteur fixe */
max-height: 120px !important; /* ← Remplace l'ancien max-height */
line-height: 120px !important; /* ← Centre le texte verticalement */
padding: 0 1em !important; /* ← Supprime padding vertical */
}
}
}
.section {
display: none;
}

.section.active {
display: flex;
flex-direction: column;
height: 100vh;
}

.coming-soon {
font-size: 1.5em;
color: #8B6F47;
margin-top: 1em;
text-align: center;
}

@media (max-width: 768px) {
.coming-soon {
font-size: 2em;
}
}

/* Styles pour le mode révisions */
#revision-question {
font-size: 1.5em;
margin-bottom: 10px;
color: #8B6F47;
text-shadow: 1px 1px 2px rgba(139, 111, 71, 0.4);
}

.char-correct {
background-color: #d4edda;
border-radius: 5px;
padding: 2px 4px;
}

.char-incorrect {
background-color: #f8e7e6;
border-radius: 5px;
padding: 2px 4px;
}

.pulsing {
animation: revisionPulse 0.8s infinite;
}

@keyframes revisionPulse {
0% { transform: scale(1); }
50% { transform: scale(1.1); }
100% { transform: scale(1); }
}

#revision-input-display {
font-size: 2em;
margin: 0 auto 10px auto; /* Centre horizontalement et garde 10px en bas */
height: 65px; /* Hauteur fixe */
padding: 10px;
border: 2px solid #8B6F47;
border-radius: 8px;
width: 300px;
text-align: center;
background: #FFFFFF;
box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
display: flex; /* Utilise flexbox pour centrer le contenu verticalement */
align-items: center; /* Centre verticalement le texte */
justify-content: center; /* Centre horizontalement le texte */
overflow: hidden; /* Empêche le contenu de déborder */
}

.revision-keyboard {
display: grid;
grid-template-columns: repeat(5, 60px);
gap: 8px;
justify-content: center;
margin-bottom: 20px;
margin-top: 0; /* Assure qu'il n'y a pas de marge supérieure */
}

.revision-key {
width: 60px;
height: 60px;
display: flex;
align-items: center;
justify-content: center;
border: 2px solid #8B6F47;
border-radius: 10px;
cursor: pointer;
transition: all 0.2s ease;
font-weight: bold;
font-size: 1.1em;
box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

/* Couleurs des touches selon les lignes */
.revision-key:nth-child(-n+5) { background-color: #d1e7ff; color: black; }
.revision-key:nth-child(6), .revision-key:nth-child(7) { background-color: #fff3cd; color: black; }
.revision-key:nth-child(8) { background-color: #d1e7ff; color: black; }
.revision-key:nth-child(9), .revision-key:nth-child(10) { background-color: #f8e7e6; color: black; }
.revision-key:nth-child(n+11):nth-child(-n+15) { background-color: #d4edda; color: black; }
.revision-key:nth-child(n+16):nth-child(-n+20) { background-color: #ffe4b5; color: black; }
.revision-key:nth-child(n+21):nth-child(-n+24) { background-color: #dee2e6; color: black; }
.revision-key:nth-child(25) { background-color: #ffffff; color: black; }

.revision-key:hover {
transform: translateY(-2px);
box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

.revision-key:active {
transform: translateY(0);
box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}

#revision-message {
margin-top: 10px;
margin-bottom: 10px;
font-size: 1.2em;
color: #8B6F47;
min-height: 1.5em;
}

/* Responsive pour mobile */
@media screen and (max-width: 768px), screen and (-webkit-min-device-pixel-ratio: 2) {
#revision-question {
font-size: 6em;
margin-top: 40px; /* Pousse la carte plus bas */
}

#revision-input-display {
font-size: 4em;
width: 90%;
padding: 15px;
position: fixed;
bottom: 1040px; /* 10px au-dessus du clavier */
left: 50%;
transform: translateX(-50%);
/*   z-index: 1000; S'assurer que l'élément est au-dessus */
}

#revision-message {
font-size: 3em; /* Beaucoup plus grand pour la réponse ! */
margin: 20px 0;
font-weight: bold; /* Pour une meilleure visibilité */
}

.revision-keyboard {
grid-template-columns: repeat(5, 1fr);
width: 90%;
padding: 0 5px;
position: fixed;
bottom: 100px;
left: 50%;
transform: translateX(-50%);
}

.revision-key {
width: 100%;
height: auto;
aspect-ratio: 1;
min-width: 50px;
font-size: clamp(2.5em, 8vw, 5em);
font-weight: bold;
line-height: 1;
}
}

/* ✨ NOUVEAUX STYLES POUR LES CARTES - Identiques au mode apprentissage */
.char-card {
display: inline-flex;
padding: 15px;
margin: 5px;
border-radius: 8px; /* Même rayon que les cartes hiragana */
min-width: 60px;
min-height: 60px;
text-align: center;
font-size: 2.2em;
font-weight: bold;
color: #8B6F47;
text-shadow: 0 0 3px rgba(139, 111, 71, 0.3);

/* ✅ MÊME STYLE QUE LES CARTES HIRAGANA */
background: #FFFFFF;
box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25), 0 3px 6px rgba(0, 0, 0, 0.15);
transition: all 0.4s ease; /* Transition plus fluide */

align-items: center;
justify-content: center;
}

/* 🎨 GRADATIONS ULTRA-SUBTILES (couleurs beaucoup plus douces) */
.char-correct-1 {
background: #f9fdf9; /* Vert ultra-discret, à peine visible */
box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25), 0 3px 6px rgba(0, 0, 0, 0.15), inset 0 0 2px rgba(139, 195, 74, 0.1);
}
.char-correct-2 {
background: #f5faf5; /* Vert très pâle */
box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25), 0 3px 6px rgba(0, 0, 0, 0.15), inset 0 0 3px rgba(139, 195, 74, 0.15);
}
.char-correct-3 {
background: #f0f8f0; /* Vert léger */
box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25), 0 3px 6px rgba(0, 0, 0, 0.15), inset 0 0 4px rgba(139, 195, 74, 0.2);
}
.char-correct-4 {
background: #ebf5eb; /* Vert final très soft */
box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25), 0 3px 6px rgba(0, 0, 0, 0.15), inset 0 0 5px rgba(139, 195, 74, 0.25);
}

/* 🌸 GRADATIONS ROSES SAKURA ULTRA-SUBTILES */
.char-incorrect-1 {
background: #fdfafa; /* Rose ultra-discret */
box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25), 0 3px 6px rgba(0, 0, 0, 0.15), inset 0 0 2px rgba(253, 193, 197, 0.1);
}
.char-incorrect-2 {
background: #fcf5f5; /* Rose très pâle */
box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25), 0 3px 6px rgba(0, 0, 0, 0.15), inset 0 0 3px rgba(253, 193, 197, 0.15);
}
.char-incorrect-3 {
background: #faf0f1; /* Rose léger */
box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25), 0 3px 6px rgba(0, 0, 0, 0.15), inset 0 0 4px rgba(253, 193, 197, 0.2);
}
.char-incorrect-4 {
background: #f8ebec; /* Rose final très soft */
box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25), 0 3px 6px rgba(0, 0, 0, 0.15), inset 0 0 5px rgba(253, 193, 197, 0.25);
}

/* 💫 PULSATION AMÉLIORÉE - Plus fluide et prononcée */
.pulsing {
animation: pulse-revision 1.8s infinite ease-in-out;
}

/* Animation pulse-revision affinée (assure-toi qu'elle est présente) */
@keyframes pulse-revision {
0% {
transform: scale(1);
box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25), 0 3px 6px rgba(0, 0, 0, 0.15);
}
50% {
transform: scale(1.06); /* Plus subtile que 1.08 */
box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3), 0 4px 8px rgba(0, 0, 0, 0.2), 0 0 10px rgba(139, 111, 71, 0.4);
}
100% {
transform: scale(1);
box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25), 0 3px 6px rgba(0, 0, 0, 0.15);
}
}
/* Animation pop pour les cartes (pour feedback visuel lors de la saisie) */
.char-card.pop-animation {
animation: pop-card 0.4s ease-in-out;
}

@keyframes pop-card {
0% { transform: scale(1); }
50% { transform: scale(1.1); }
100% { transform: scale(1); }
}

/* Effet de secousse pour les réponses incorrectes (assure-toi qu'il est présent) */
body.shake {
animation: screenShake 0.4s ease-in-out;
}

@keyframes screenShake {
0% { transform: translate(0px, 0px); }
25% { transform: translate(4px, -4px); }
50% { transform: translate(-4px, 4px); }
75% { transform: translate(4px, 4px); }
100% { transform: translate(0px, 0px); }
}
/* Responsive pour mobile (ajustements pour sakura et secousse) */
@media screen and (max-width: 768px), screen and (-webkit-min-device-pixel-ratio: 2) {
.sakura {
width: 30px;
height: 30px;
}
body.shake {
animation: screenShake 0.5s ease-in-out; /* Légèrement plus long pour mobile */
}
}
/* Style de base pour le titre mode révision*/
#mode2 .title {
margin: 0.5em 0;
font-size: 1.8em;
text-align: center;
color: #8B6F47;
text-shadow: 0 1px 2px rgba(139, 111, 71, 0.3);
}

/* Media query pour les écrans mobiles (jusqu'à 768px) */
@media screen and (max-width: 768px), screen and (-webkit-min-device-pixel-ratio: 2) {
#mode2 .title {
margin: 0.5em 0;
font-size: 3em;
text-align: center;
color: #8B6F47;
text-shadow: 0 1px 2px rgba(139, 111, 71, 0.3);
}
}

</style>
</head>
<body>
<!-- Bouton hamburger  <button class="hamburger" onclick="toggleMenu()">☰</button>  -->
<!-- Bouton hamburger -->
<button class="hamburger" onclick="toggleMenu()">
<div class="hamburger-icon">
<div class="hamburger-bar"></div>
<div class="hamburger-bar"></div>
<div class="hamburger-bar"></div>
</div>
</button>

<!-- Menu -->
<nav class="menu" id="menu">
<button class="arcade-button" onclick="showSection('quiz')">Apprendre</button>
<button class="arcade-button" onclick="showSection('mode2')">Mode révisions</button>
<button class="arcade-button" onclick="showSection('options')">Options</button>
<button class="arcade-button" onclick="toggleMenu()">Fermer</button>
</nav>

<!-- Section Quiz (contenu actuel) -->
<div id="quiz" class="section active">
<h1>🌿⛩️ Welcome to Hira-Kata-Quiz ⛩️🌸</h1>
<div id="progressBarContainer"></div>
<div class="level" id="levelDisplay">Niveau actuel : 1</div>
<div class="level-hiraganas">
<div class="hiraganas-grid" id="hiraganaCards"></div>
</div>
<div class="quiz-container">
<div class="question" id="question">load...</div>
<div>
<div class="answers" id="choices1"></div>
<div class="answers" id="choices2"></div>
</div>
<div>
<div class="result" id="result"></div>
<button class="arcade-button" id="continueBtn" onclick="nextQuestion()">🌱 OK... j’ai capté 🌱</button>
<button class="arcade-button" id="boutonInstaller">Ajouter à l'écran d'accueil</button>
</div>
</div>
</div>

<!-- Section Mode Katakana -->
<!-- Section Mode révisions -->
<div id="mode2" class="section">
<h2>🎌 Mode Révisions 🎌</h2>
<div id="revision-question"></div>
<div id="revision-message"></div>
<div id="revision-input-display"></div>
<div class="revision-keyboard">
<div class="revision-key">a</div>
<div class="revision-key">i</div>
<div class="revision-key">u</div>
<div class="revision-key">e</div>
<div class="revision-key">o</div>
<div class="revision-key">k</div>
<div class="revision-key">g</div>
<div class="revision-key">y</div>
<div class="revision-key">h</div>
<div class="revision-key">f</div>
<div class="revision-key">t</div>
<div class="revision-key">ts</div>
<div class="revision-key">d</div>
<div class="revision-key">b</div>
<div class="revision-key">p</div>
<div class="revision-key">s</div>
<div class="revision-key">sh</div>
<div class="revision-key">z</div>
<div class="revision-key">j</div>
<div class="revision-key">ch</div>
<div class="revision-key">m</div>
<div class="revision-key">n</div>
<div class="revision-key">r</div>
<div class="revision-key">w</div>
<div class="revision-key" id="revision-back">←</div>
</div>

</div>

<!-- Section Options -->
<div id="options" class="section">
<h1>Options</h1>
<p class="coming-soon">Coming soon</p>
</div>

<script>
function toggleMenu() {
const menu = document.getElementById('menu');
menu.classList.toggle('active');
}

function showSection(sectionId) {
document.querySelectorAll('.section').forEach(section => {
section.classList.remove('active');
});
document.getElementById(sectionId).classList.add('active');

// Démarrer le mode révisions si c'est le mode sélectionné
if (sectionId === 'mode2') {
revisionMode.isActive = true;
// Petit délai pour s'assurer que la section est visible
setTimeout(() => {
initRevisionKeyboard();
startRevisionQuestion();
}, 100);
} else {
revisionMode.isActive = false;
}

toggleMenu();
}
</script>
<script>
let HiraganaList = [];
let current = {};
let selections = { first: null, second: null };
let targetFields = [];
let isAnswered = false;
let niveauActif = 1;
let previousValidationStates = new Map();
let activeSparks = []; // Variable globale pour les particules
let globalParticleCount = 0; // Compteur global
let previousCharacter = null;

// Variables pour le mode révisions
let revisionMode = {
currentQuestion: "",
input: "",
romajiSegments: [],
charCounts: [],
fullCorrect: "",
cumulativeRomaji: [],
cumulativeChars: [],
isActive: false
};
// Initialisation du contexte audio (à placer au début du script, une seule fois)
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
// Fonction pour générer la table romaji à partir des données Google Sheet (VERSION CORRIGÉE)
function generateRevisionRomajiTable(hiraganaList) {
const table = {};
let validItems = 0;
let invalidItems = 0;

hiraganaList.forEach((item, index) => {
const hiragana = item.Hiragana;
const romaji = item.Romaji;

// ✅ VÉRIFICATIONS ROBUSTES
if (!hiragana || !romaji) {
console.warn(`⚠️ Item ${index} ignoré - données manquantes:`, {hiragana, romaji});
invalidItems++;
return;
}

// Convertir en string si ce n'est pas déjà le cas
const hiraganaStr = String(hiragana).trim();
const romajiStr = String(romaji).trim();

if (hiraganaStr === '' || romajiStr === '' || romajiStr === 'undefined' || romajiStr === 'null') {
console.warn(`⚠️ Item ${index} ignoré - données vides:`, {hiragana: hiraganaStr, romaji: romajiStr});
invalidItems++;
return;
}

try {
// Analyser le romaji pour créer les segments
const segments = analyzeRomajiSegments(romajiStr);
table[hiraganaStr] = {
romaji: segments.segments,
charCounts: segments.charCounts,
originalRomaji: romajiStr,
niveau: item.Niveau,
validation: item.Validation
};
validItems++;
} catch (error) {
console.error(`❌ Erreur lors de l'analyse de l'item ${index}:`, {hiragana: hiraganaStr, romaji: romajiStr}, error);
invalidItems++;
}
});

console.log(`📊 Génération table romaji: ${validItems} items valides, ${invalidItems} items ignorés`);
return table;
}
function generateRevisionKatakanaTable(hiraganaList) {
const table = {};
let validItems = 0;
let invalidItems = 0;

hiraganaList.forEach((item, index) => {
const katakana = item.Katakana; // Assumant colonne "Katakana" dans ta Sheet
const romaji = item.Romaji;

if (!katakana || !romaji) {
console.warn(`⚠️ Item ${index} ignoré pour Katakana - données manquantes:`, {katakana, romaji});
invalidItems++;
return;
}

const katakanaStr = String(katakana).trim();
const romajiStr = String(romaji).trim();

if (katakanaStr === '' || romajiStr === '' || romajiStr === 'undefined' || romajiStr === 'null') {
invalidItems++;
return;
}

try {
const segments = analyzeRomajiSegments(romajiStr);
table[katakanaStr] = {
romaji: segments.segments,
charCounts: segments.charCounts,
originalRomaji: romajiStr,
niveau: item.Niveau,
validation: item.Validation
};
validItems++;
} catch (error) {
invalidItems++;
}
});

console.log(`📊 Génération table katakana: ${validItems} items valides, ${invalidItems} items ignorés`);
return table;
}
// Fonction pour analyser et segmenter le romaji (VERSION CORRIGÉE)
function analyzeRomajiSegments(romajiInput) {
if (!romajiInput) {
throw new Error("Romaji vide ou null");
}

let romajiString = String(romajiInput).toLowerCase().trim();
romajiString = romajiString.replace(/[^a-z]/g, '');

if (romajiString === '') {
throw new Error(`Romaji vide après nettoyage des caractères spéciaux`);
}

// Segmenter intelligemment
const segments = smartSegmentRomaji(romajiString);

return {
segments: segments,
charCounts: segments.map(() => 1) // Chaque segment = 1 caractère visuel
};
}

// Fonction pour segmenter intelligemment le romaji (INCHANGÉE mais ajout de vérifications)
function smartSegmentRomaji(romaji) {
if (!romaji || typeof romaji !== 'string') {
console.warn("smartSegmentRomaji: romaji invalide", romaji);
return [romaji || ''];
}

const specialSyllables = [
'tsu', 'shi', 'chi', 'sha', 'sho', 'shu', 'cha', 'cho', 'chu',
'nya', 'nyo', 'nyu', 'hya', 'hyo', 'hyu', 'mya', 'myo', 'myu',
'rya', 'ryo', 'ryu', 'gya', 'gyo', 'gyu', 'bya', 'byo', 'byu',
'pya', 'pyo', 'pyu', 'kya', 'kyo', 'kyu', 'ja', 'ji', 'ju', 'jo'
];

const basicSyllables = [
'ka', 'ki', 'ku', 'ke', 'ko', 'ga', 'gi', 'gu', 'ge', 'go',
'sa', 'shi', 'su', 'se', 'so', 'za', 'ji', 'zu', 'ze', 'zo',
'ta', 'chi', 'tsu', 'te', 'to', 'da', 'ji', 'zu', 'de', 'do',
'na', 'ni', 'nu', 'ne', 'no',
'ha', 'hi', 'fu', 'he', 'ho', 'ba', 'bi', 'bu', 'be', 'bo', 'pa', 'pi', 'pu', 'pe', 'po',
'ma', 'mi', 'mu', 'me', 'mo',
'ya', 'yu', 'yo',
'ra', 'ri', 'ru', 're', 'ro',
'wa', 'wi', 'we', 'wo', 'n'
];

const vowels = ['a', 'i', 'u', 'e', 'o'];

const allSyllables = [...specialSyllables, ...basicSyllables, ...vowels];

const segments = [];
let remaining = romaji.toLowerCase();

while (remaining.length > 0) {
let found = false;

// Essayer les syllabes les plus longues d'abord
for (const syllable of allSyllables.sort((a, b) => b.length - a.length)) {
if (remaining.startsWith(syllable)) {
segments.push(syllable);
remaining = remaining.slice(syllable.length);
found = true;
break;
}
}

// Fallback : prendre 2 caractères si possible (consonne + voyelle), sinon 1
if (!found) {
if (remaining.length >= 2 && !vowels.includes(remaining[0])) { // Si commence par consonne
segments.push(remaining.slice(0, 2));
remaining = remaining.slice(2);
} else {
segments.push(remaining[0]);
remaining = remaining.slice(1);
}
}
}

return segments.length > 0 ? segments : [romaji];
}



function logError(msg) {
console.warn(msg);
}


function testFeu() {
const container = document.querySelector('.quiz-container');
if (isMobile) {
triggerLightFirework(container);
} else {
triggerAdvancedFirework(container);
}
}

function triggerSakuraFall(container) {
for (let i = 0; i < 30; i++) {
const sakura = document.createElement("div");
sakura.className = "sakura";
sakura.style.left = Math.random() * 100 + "vw";
sakura.style.top = "-10px";
sakura.style.animationDelay = Math.random() * 1.5 + "s";
sakura.style.animationDuration = 2.5 + Math.random() * 1.5 + "s";
document.body.appendChild(sakura);
setTimeout(() => sakura.remove(), 4000);
}


}


// 🎯 GESTIONNAIRE DE PARTICULES OPTIMISÉ
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
const MAX_ACTIVE_PARTICLES = isMobile ? 15 : 30; // Limite stricte

// Fonction de nettoyage des particules
function cleanupOldParticles() {
// Supprimer les particules les plus anciennes si on dépasse la limite
while (activeSparks.length > MAX_ACTIVE_PARTICLES) {
const oldSpark = activeSparks.shift();
if (oldSpark && oldSpark.canvas && oldSpark.canvas.parentNode) {
oldSpark.canvas.remove();
globalParticleCount--;
}
}
// Nettoyer les particules orphelines
activeSparks = activeSparks.filter(spark => {
if (!spark.canvas || !spark.canvas.parentNode) {
globalParticleCount--;
return false;
}
return true;
});
console.log(`🧹 Nettoyage: ${activeSparks.length} particules actives, ${globalParticleCount} compteur global`);
}

// Nettoyage automatique toutes les 3 secondes
setInterval(cleanupOldParticles, 3000);

// Audio
let audioContext;
let audioInitialized = false;

function initAudio() {
try {
if (!audioInitialized) {
audioContext = new (window.AudioContext || window.webkitAudioContext)();
audioInitialized = true;
}
} catch (error) {
console.error("Erreur lors de l'initialisation audio:", error.message);
}
}

function getValidatedCountForLevel(level) {
return HiraganaList.filter(h => parseInt(h.Niveau) === level && parseInt(h.Validation) >= 5).length;
}
function playPopSound() {
initAudio();
try {
const osc = audioContext.createOscillator();
const gain = audioContext.createGain();
osc.connect(gain);
gain.connect(audioContext.destination);
osc.type = 'sine';
osc.frequency.value = 1000; // Son aigu pour "pop"
gain.gain.setValueAtTime(0.05, audioContext.currentTime);
gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
osc.start();
osc.stop(audioContext.currentTime + 0.1);
} catch (error) {
logError('Erreur son pop: ' + error.message);
}
}
function playMarioCoin() {
initAudio();
const notes = [659.25, 1046.50];
const durations = [0.1, 0.2];
notes.forEach((freq, i) => {
setTimeout(() => {
const osc = audioContext.createOscillator();
const gain = audioContext.createGain();
osc.connect(gain);
gain.connect(audioContext.destination);
osc.type = 'sine';
osc.frequency.value = freq;
gain.gain.setValueAtTime(0.05, audioContext.currentTime);
gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + durations[i]);
osc.start();
osc.stop(audioContext.currentTime + durations[i]);
}, i * 100);
});
}

function playSuccess90s() {
initAudio();
const baseFreq = 587.33;
const osc1 = audioContext.createOscillator();
const gain1 = audioContext.createGain();
const osc2 = audioContext.createOscillator();
const gain2 = audioContext.createGain();
osc1.connect(gain1);
osc2.connect(gain2);
gain1.connect(audioContext.destination);
gain2.connect(audioContext.destination);
osc1.type = 'sine';
osc2.type = 'sine';
osc1.frequency.value = baseFreq;
osc2.frequency.setValueAtTime(baseFreq * 1.5, audioContext.currentTime);
osc2.frequency.exponentialRampToValueAtTime(baseFreq * 3, audioContext.currentTime + 0.3);
gain1.gain.setValueAtTime(0.03, audioContext.currentTime);
gain1.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
gain2.gain.setValueAtTime(0.01, audioContext.currentTime);
gain2.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
osc1.start();
osc2.start();
osc1.stop(audioContext.currentTime + 0.4);
osc2.stop(audioContext.currentTime + 0.3);
}

function playFail() {
initAudio();
const oscillator = audioContext.createOscillator();
const gainNode = audioContext.createGain();
oscillator.connect(gainNode);
gainNode.connect(audioContext.destination);
oscillator.type = 'sine';
gainNode.gain.setValueAtTime(0.04, audioContext.currentTime);
gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
oscillator.frequency.exponentialRampToValueAtTime(110, audioContext.currentTime + 0.4);
oscillator.start(audioContext.currentTime);
oscillator.stop(audioContext.currentTime + 0.4);
}

function playFireworkSound() {
initAudio();
try {
const frequencies = [329.63, 415.30, 523.25, 659.25];
frequencies.forEach((freq, i) => {
setTimeout(() => {
const osc = audioContext.createOscillator();
const gain = audioContext.createGain();
const filter = audioContext.createBiquadFilter();
osc.connect(filter);
filter.connect(gain);
gain.connect(audioContext.destination);
osc.type = 'triangle';
osc.frequency.value = freq;
filter.type = 'lowpass';
filter.frequency.value = freq * 2;
gain.gain.setValueAtTime(0.03, audioContext.currentTime);
gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
osc.start();
osc.stop(audioContext.currentTime + 0.4);
}, i * 150);
});
} catch (error) {
logError('Erreur Firework: ' + error.message);
}
}

function playfireworksound2() {
initAudio();
try {
const sequence = [554.37, 659.25, 830.61, 987.77];
sequence.forEach((freq, i) => {
setTimeout(() => {
const osc = audioContext.createOscillator();
const gain = audioContext.createGain();
osc.connect(gain);
gain.connect(audioContext.destination);
osc.type = 'sine';
osc.frequency.value = freq;
gain.gain.setValueAtTime(0.035, audioContext.currentTime);
gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
osc.start();
osc.stop(audioContext.currentTime + 0.2);
}, i * 100);
});
} catch (error) {
logError('Erreur fireworksound 2: ' + error.message);
}
}

function playfireworksound3() {
initAudio();
try {
const sequence = [659.25, 783.99, 987.77, 1174.66];
sequence.forEach((freq, i) => {
setTimeout(() => {
const osc = audioContext.createOscillator();
const gain = audioContext.createGain();
osc.connect(gain);
gain.connect(audioContext.destination);
osc.type = 'sine';
osc.frequency.value = freq;
gain.gain.setValueAtTime(0.035, audioContext.currentTime);
gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
osc.start();
osc.stop(audioContext.currentTime + 0.2);
}, i * 100);
});
} catch (error) {
logError('Erreur fireworksound 3: ' + error.message);
}
}

function playfireworksound4() {
initAudio();
try {
const sequence = [783.99, 987.77, 1174.66, 1396.91];
sequence.forEach((freq, i) => {
setTimeout(() => {
const osc = audioContext.createOscillator();
const gain = audioContext.createGain();
osc.connect(gain);
gain.connect(audioContext.destination);
osc.type = 'sine';
osc.frequency.value = freq;
gain.gain.setValueAtTime(0.035, audioContext.currentTime);
gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
osc.start();
osc.stop(audioContext.currentTime + 0.2);
}, i * 100);
});
} catch (error) {
logError('Erreur fireworksound 4: ' + error.message);
}
}

function playLevelUp() {
initAudio();
try {
const sequence = [523.25, 659.25, 783.99, 1046.50];
const flourish = [783.99, 1046.50, 1318.51];
sequence.forEach((freq, i) => {
setTimeout(() => {
const osc = audioContext.createOscillator();
const gain = audioContext.createGain();
osc.connect(gain);
gain.connect(audioContext.destination);
osc.type = 'sine';
osc.frequency.value = freq;
gain.gain.setValueAtTime(0.04, audioContext.currentTime);
gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.12);
osc.start();
osc.stop(audioContext.currentTime + 0.12);
}, i * 120);
});
flourish.forEach((freq, i) => {
setTimeout(() => {
const osc = audioContext.createOscillator();
const gain = audioContext.createGain();
osc.connect(gain);
gain.connect(audioContext.destination);
osc.type = 'sine';
osc.frequency.value = freq;
gain.gain.setValueAtTime(0.04, audioContext.currentTime);
gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
osc.start();
osc.stop(audioContext.currentTime + 0.1);
}, 480 + i * 100);
});
setTimeout(() => {
const osc = audioContext.createOscillator();
const gain = audioContext.createGain();
const mod = audioContext.createOscillator();
const modGain = audioContext.createGain();
mod.connect(modGain);
modGain.connect(osc.frequency);
osc.connect(gain);
gain.connect(audioContext.destination);
osc.type = 'sine';
mod.type = 'sine';
osc.frequency.value = 1318.51;
mod.frequency.value = 5;
modGain.gain.value = 10;
gain.gain.setValueAtTime(0.04, audioContext.currentTime);
gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 2.0);
osc.start();
mod.start();
osc.stop(audioContext.currentTime + 2.0);
mod.stop(audioContext.currentTime + 2.0);
}, 780);
} catch (error) {
logError('Erreur Level Up: ' + error.message);
}
}
// Son pour réponses correctes : Clochette zen
function playZenBell() {
const oscillator = audioCtx.createOscillator();
const gainNode = audioCtx.createGain();
oscillator.connect(gainNode);
gainNode.connect(audioCtx.destination);

oscillator.type = 'sine';
oscillator.frequency.setValueAtTime(880, audioCtx.currentTime);
gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);

oscillator.start();
setTimeout(() => {
oscillator.frequency.setValueAtTime(660, audioCtx.currentTime);
gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
}, 200);
oscillator.stop(audioCtx.currentTime + 1);
}

// Son pour réponses incorrectes : Bip atténué
function playSoftError() {
const oscillator = audioCtx.createOscillator();
const gainNode = audioCtx.createGain();
oscillator.connect(gainNode);
gainNode.connect(audioCtx.destination);

oscillator.type = 'triangle';
oscillator.frequency.setValueAtTime(220, audioCtx.currentTime);
gainNode.gain.setValueAtTime(0.4, audioCtx.currentTime);
gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);

oscillator.start();
oscillator.stop(audioCtx.currentTime + 0.4);
}
function drawStar(ctx, x, y, radius, rotation = 0) {
const points = 5;
const outerRadius = radius;
const innerRadius = radius / 2;
ctx.beginPath();
for (let i = 0; i < points * 2; i++) {
const r = i % 2 === 0 ? outerRadius : innerRadius;
const angle = (i * Math.PI / points) + rotation - Math.PI / 2;
ctx.lineTo(
x + r * Math.cos(angle),
y + r * Math.sin(angle)
);
}
ctx.closePath();
ctx.fill();
}

function triggerAdvancedFirework(container) {
initAudio();
const validatedCount = getValidatedCountForLevel(niveauActif);
const canvas = document.createElement('canvas');
canvas.style.position = 'absolute';
canvas.style.left = '50%';
canvas.style.top = '50%';
canvas.style.transform = 'translate(-50%, -50%)';
canvas.style.pointerEvents = 'none';
canvas.style.zIndex = '20';
canvas.width = 400;
canvas.height = 400;
container.appendChild(canvas);
const ctx = canvas.getContext('2d');

const colorPalettes = [
['#6B8E23', '#9ACD32', '#32CD32', '#228B22', '#008000', '#006400'], // Palette verte
['#A8D5BA', '#76FF03', '#64DD17', '#00C853', '#AEEA00', '#00E676'],
['#FDC1C5', '#F48FB1', '#EC407A', '#D81B60', '#AD1457', '#FF80AB'],
];
const colors = colorPalettes[Math.floor(Math.random() * colorPalettes.length)];

const maxLifeBase = isMobile ? 30 : 50;
const numParticles = isMobile ? 9 : 12;
const numSalvos = isMobile ? 3 : 3;
const gravity = 0.1;
const salvoDelay = 150;
const dispersionBase = 3;

const particles = [];
const trails = [];

const halo = document.createElement('div');
halo.style.position = 'absolute';
halo.style.left = '50%';
halo.style.top = '50%';
halo.style.width = '20px';
halo.style.height = '20px';
halo.style.borderRadius = '50%';
halo.style.background = 'radial-gradient(circle, rgba(255,255,255,0.9), rgba(255,255,255,0.05))';
halo.style.transform = 'translate(-50%, -50%) scale(1)';
halo.style.opacity = '1';
halo.style.zIndex = '0';
halo.style.pointerEvents = 'none';
container.appendChild(halo);
halo.animate([
{ transform: 'translate(-50%, -50%) scale(1)', opacity: 1 },
{ transform: 'translate(-50%, -50%) scale(6)', opacity: 0 }
], {
duration: 700,
easing: 'ease-out'
}).onfinish = () => halo.remove();

if (validatedCount === 0) {
playFireworkSound();
} else if (validatedCount === 1) {
playfireworksound2();
} else if (validatedCount === 2) {
playfireworksound3();
} else if (validatedCount === 3) {
playfireworksound4();
} else if (validatedCount === 4) {
playLevelUp();
triggerLevelUpAnimation(container);
}

for (let salvo = 0; salvo < numSalvos; salvo++) {
setTimeout(() => {
if (activeSparks.length >= MAX_ACTIVE_PARTICLES) {
console.warn(`⚠️ Salvo ${salvo} annulée - limite atteinte`);
return;
}

const biasDirection = Math.random() < 0.5 ? -1 : 1;
const biasMagnitude = (Math.random() * 0.2 - 0.1) * biasDirection;

for (let i = 0; i < numParticles; i++) {
if (activeSparks.length >= MAX_ACTIVE_PARTICLES) {
console.warn(`🛑 Particule ${i} du salvo ${salvo} ignorée - limite atteinte`);
break;
}

const angleOffset = (Math.random() * 10 - 5) * (Math.PI / 180);
const angle = angleOffset + (i * (360 / numParticles)) * (Math.PI / 180);
const isUpward = (angle >= 3 * Math.PI / 2 || angle <= Math.PI / 2);
let speed = dispersionBase + Math.random() * 3;
if (isUpward) {
speed = Math.max(7, speed);
if ((angle >= 3 * Math.PI / 2 && biasDirection === -1) || (angle <= Math.PI / 2 && biasDirection === 1)) {
speed *= (1 + biasMagnitude);
}
}

const v0x = speed * Math.cos(angle);
const v0y = speed * Math.sin(angle) * -1;
const color = colors[Math.floor(Math.random() * colors.length)];

particles.push({
x: canvas.width / 2,
y: canvas.height / 2,
vx: v0x,
vy: v0y,
life: maxLifeBase + Math.random() * 20,
maxLife: maxLifeBase + Math.random() * 20,
color: color,
rotation: Math.random() * Math.PI * 2
});
activeSparks.push({ canvas });
globalParticleCount++;
console.log(`Particule ajoutée: ${particles.length} particules, ${activeSparks.length} sparks`);
}
}, salvo * salvoDelay);
}

function animate() {
ctx.clearRect(0, 0, canvas.width, canvas.height);

if (!isMobile) {
particles.forEach(p => {
if (Math.random() < 0.2) {
trails.push({
x: p.x,
y: p.y,
color: p.color,
life: 10
});
}
});
}

trails.forEach((t, i) => {
t.life--;
if (t.life <= 0) {
trails.splice(i, 1);
return;
}
ctx.fillStyle = t.color;
ctx.globalAlpha = t.life / 10 * 0.3;
ctx.beginPath();
ctx.arc(t.x, t.y, isMobile ? 2 : 3, 0, 2 * Math.PI);
ctx.fill();
});

particles.forEach((p, i) => {
p.x += p.vx;
p.y += p.vy;
p.vy += gravity;
p.life--;
p.rotation += 0.05;
if (p.life <= 0) {
particles.splice(i, 1);
activeSparks.splice(i, 1);
globalParticleCount--;
return;
}
ctx.fillStyle = p.color;
ctx.globalAlpha = Math.max(0, p.life / p.maxLife);
ctx.save();
ctx.translate(p.x, p.y);
drawStar(ctx, 0, 0, isMobile ? 4 : 6, p.rotation);
ctx.restore();
});

if (particles.length > 0 || Date.now() < Date.now() + numSalvos * salvoDelay) {
requestAnimationFrame(animate);
} else {
canvas.remove();
activeSparks = activeSparks.filter(spark => spark.canvas !== canvas);
globalParticleCount = Math.max(0, globalParticleCount - particles.length);
console.log('Animation terminée');
}
}
requestAnimationFrame(animate);
}
/*
function cleanupOldParticles() {
while (activeSparks.length > MAX_ACTIVE_PARTICLES) {
const oldSpark = activeSparks.shift();
if (oldSpark && oldSpark.canvas && oldSpark.canvas.parentNode) {
oldSpark.canvas.remove();
globalParticleCount--;
}
}
activeSparks = activeSparks.filter(spark => {
if (!spark.canvas || !spark.canvas.parentNode) {
globalParticleCount--;
return false;
}
return true;
});
console.log(`🧹 Nettoyage: ${activeSparks.length} particules actives, ${globalParticleCount} compteur global`);
}

setInterval(cleanupOldParticles, 3000);

const MAX_ACTIVE_PARTICLES = isMobile ? 15 : 30;
*/
function getMaxLevel(list) {
if (!list || list.length === 0) return 1;
return Math.max(...list.map(k => parseInt(k.Niveau) || 1));
}

function updateStarsForHiragana(hiraganaId, newValidation) {
const cards = document.querySelectorAll('.hiragana-card');
cards.forEach(card => {
const hiraganaChar = card.querySelector('.hiragana-char').textContent;
const hiragana = HiraganaList.find(h => h.Hiragana === hiraganaChar && h.ID == hiraganaId);
if (hiragana) {
const stars = card.querySelectorAll('.star');
const previousValidation = previousValidationStates.get(hiraganaId) || 0;

stars.forEach((star, index) => {
if (index < newValidation && !star.classList.contains('filled')) {
star.classList.add('filled', 'new-star');
setTimeout(() => star.classList.remove('new-star'), 500);
} else if (index < newValidation) {
star.classList.add('filled');
} else {
star.classList.remove('filled', 'new-star');
}
});

if (newValidation >= 5 && previousValidation < 5) {
if (isMobile) {
triggerLightFirework(card);
} else {
triggerAdvancedFirework(card);
}
}

if (newValidation >= 5) {
card.classList.add('completed');
} else {
card.classList.remove('completed');
}

previousValidationStates.set(hiraganaId, newValidation);
}
});
}

function renderHiraganaCards(list, niveau) {
const container = document.getElementById("hiraganaCards");
if (!container) return;
const hiraganas = list.filter(h => parseInt(h.Niveau) === niveau);
container.innerHTML = "";
hiraganas.forEach(hiragana => {
const validation = parseInt(hiragana.Validation || 0);
const isCompleted = validation >= 5;
const card = document.createElement("div");
card.className = `hiragana-card ${isCompleted ? 'completed' : ''}`;
card.innerHTML = `
<div class="hiragana-char">${hiragana.Hiragana}</div>
<div class="stars-container">
${Array.from({length: 5}, (_, i) =>
`<div class="star ${i < validation ? 'filled' : ''}"></div>`
).join('')}
</div>
`;
container.appendChild(card);
previousValidationStates.set(parseInt(hiragana.ID), validation);
});
}

function renderProgressBar(currentLevel, maxLevel) {
const container = document.getElementById("progressBarContainer");
if (!container) return;

container.innerHTML = "";

const leftEmoji = document.createElement("span");
leftEmoji.textContent = "🌱";
leftEmoji.className = "side-emoji";

const rightEmoji = document.createElement("span");
rightEmoji.textContent = "🌳";
rightEmoji.className = "side-emoji";

const barTrack = document.createElement("div");
barTrack.className = "progress-bar-track";

const marker = document.createElement("div");
marker.className = "progress-marker";
marker.innerText = "🐼";  /*  🐼 🐱💩🤡🐶🐯🐱 */

const pct = maxLevel > 1 ? ((currentLevel - 1) / (maxLevel - 1)) * 100 : 0;
marker.style.left = `${Math.min(100, Math.max(0, pct))}%`;

barTrack.appendChild(marker);
container.appendChild(leftEmoji);
container.appendChild(barTrack);
container.appendChild(rightEmoji);
}

function determineNiveauActif(list) {
if (!list || list.length === 0) return 1;
let maxNiveau = Math.max(...list.map(k => parseInt(k.Niveau) || 1));

for (let n = 1; n <= maxNiveau; n++) {
const kanjisNiveau = list.filter(k => parseInt(k.Niveau) === n);
const kanjisValides = kanjisNiveau.filter(k => parseInt(k.Validation) >= 5);
if (kanjisValides.length < kanjisNiveau.length) {
return n;
}
}
return maxNiveau;
}

function updateLevelProgress(list, niveau) {
renderHiraganaCards(list, niveau);
}

// Initialisation avec Google Apps Script
// *** NOUVELLE URL DE VOTRE WEB APP GOOGLE ***
const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbyunFkM7h0FV_xu1GRa4uOiuxeggNSVY1HRCzNungo8QonzHznN0TRNLDOEEOtfQu_8FQ/exec';

// Fonction pour appeler l'API
async function callAPI(action, data = null) {
try {
if (action === 'updateStats') {
// Utiliser GET pour éviter CORS
const params = new URLSearchParams({
action,
id: data.id,
scorePoints: data.scorePoints
});
const response = await fetch(`${WEB_APP_URL}?${params}`);
return await response.json();
} else {
const response = await fetch(`${WEB_APP_URL}?action=${action}`);
return await response.json();
}
} catch (error) {
logError('Erreur API: ' + error.message);
return { error: error.message };
}
}

// Variable globale pour la table romaji
let revisionRomajiTable = {};

// Modifier votre fonction initGame existante
async function initGame() {
const data = await callAPI('getHiraganas');
if (data.error) {
logError('Erreur lors du chargement: ' + data.error);
return;
}

HiraganaList = data;

revisionRomajiTable = generateRevisionRomajiTable(HiraganaList);
revisionKatakanaTable = generateRevisionKatakanaTable(HiraganaList); // Nouvelle table

console.log("📚 Table romaji générée:", Object.keys(revisionRomajiTable).length, "entrées");
console.log("📚 Table katakana générée:", Object.keys(revisionKatakanaTable).length, "entrées");

niveauActif = determineNiveauActif(HiraganaList);
document.getElementById("levelDisplay").innerText = `Niveau actuel : ${niveauActif}`;
updateLevelProgress(HiraganaList, niveauActif);
renderProgressBar(niveauActif, getMaxLevel(HiraganaList));
nextQuestion();
}

function nextQuestion() {
document.getElementById("result").innerText = "";
document.getElementById("continueBtn").style.visibility = "hidden";
selections = { first: null, second: null };
isAnswered = false;

const kanas = HiraganaList.filter(k =>
parseInt(k.Niveau) === niveauActif && parseInt(k.Validation || 0) < 5
);

if (kanas.length === 0) {
const nouveauNiveau = determineNiveauActif(HiraganaList);
if (nouveauNiveau !== niveauActif) {
niveauActif = nouveauNiveau;
document.getElementById("levelDisplay").innerText = `Niveau actuel : ${niveauActif}`;
renderProgressBar(niveauActif, getMaxLevel(HiraganaList));
updateLevelProgress(HiraganaList, niveauActif);
nextQuestion();
return;
}
}

const finalKanas = kanas.length > 0 ? kanas : HiraganaList.filter(k => parseInt(k.Niveau) === niveauActif);

const currentWeights = finalKanas.map(k => {
const validation = parseInt(k.Validation || 0);
return Math.max(0.1, 5 - validation + 0.5);
});

let selected;
do {
const sum = currentWeights.reduce((a, b) => a + b, 0);
const rand = Math.random() * sum;
let acc = 0;
for (let i = 0; i < finalKanas.length; i++) {
acc += currentWeights[i];
if (rand < acc) {
selected = finalKanas[i];
break;
}
}
} while (selected === previousCharacter && finalKanas.length > 1); // Repeat if same as previous and more than one option exists

current = selected;
previousCharacter = current; // Update previous character

const modes = [
{ question: "Hiragana", options1: "Katakana", options2: "Romaji" },
{ question: "Katakana", options1: "Hiragana", options2: "Romaji" },
{ question: "Romaji", options1: "Hiragana", options2: "Katakana" }
];
const mode = modes[Math.floor(Math.random() * modes.length)];
targetFields = [mode.options1, mode.options2];

document.getElementById("question").innerText = current[mode.question];
renderChoices("choices1", generateChoices(mode.options1), "first");
renderChoices("choices2", generateChoices(mode.options2), "second");
}

function generateChoices(field) {
const others = HiraganaList.filter(k => k !== current && parseInt(k.Niveau) === niveauActif);
const values = [current[field], ...others.sort(() => 0.5 - Math.random()).slice(0, 3).map(k => k[field])];
return values.sort(() => 0.5 - Math.random());
}

function renderChoices(id, options, slot) {
const container = document.getElementById(id);
container.innerHTML = "";
options.forEach(text => {
const btn = document.createElement("button");
btn.innerText = text;
btn.className = "arcade-button";
btn.onclick = () => {
if (selections[slot] !== null || isAnswered) return;
selections[slot] = text;

// Ajouter l'effet de halo sans le retirer immédiatement
btn.classList.add("clicked-glow");

// Garder l'effet d'opacité pour les autres boutons
container.querySelectorAll("button").forEach(b => {
b.disabled = true;
if (b === btn) {
b.classList.add("clicked");
}
});
checkAnswer();
};
container.appendChild(btn);
});
}

async function checkAnswer() {
if (selections.first && selections.second && !isAnswered) {
isAnswered = true;
const correct1 = current[targetFields[0]];
const correct2 = current[targetFields[1]];
let score = 0;
const containers = [document.getElementById("choices1"), document.getElementById("choices2")];
const correctAnswers = [correct1, correct2];
const userSelections = [selections.first, selections.second];

// Retirer l'effet de halo
containers.forEach(container => {
container.querySelectorAll("button").forEach(btn => {
btn.classList.remove("clicked-glow", "correct", "incorrect");
});
});

// Appliquer les classes pour les voiles
containers.forEach((container, index) => {
const buttons = container.querySelectorAll("button");
buttons.forEach(btn => {
if (btn.innerText === correctAnswers[index]) {
// Toutes les bonnes réponses (cliquées ou non) ont le voile vert
btn.classList.add("correct");
btn.disabled = true;
if (btn.innerText === userSelections[index]) {
score += 0.5;
btn.classList.add("clicked"); // Maintenir .clicked pour style
}
} else if (btn.innerText === userSelections[index]) {
// Bouton cliqué mais incorrect : voile rouge
btn.classList.add("incorrect");
btn.disabled = true;
} else {
// Bouton non cliqué et incorrect : reste neutre
btn.disabled = true;
}
});
});

// Reste du code inchangé...
const currentValidation = parseInt(current.Validation || 0);
let newValidation = currentValidation;

if (score === 1) {
newValidation = Math.min(5, currentValidation + 1);
} else if (score === 0.5) {
newValidation = Math.max(0, currentValidation - 1);
} else {
newValidation = Math.max(0, currentValidation - 2);
}

const isFinalValidation = score === 1 && currentValidation < 5 && newValidation >= 5;

updateStarsForHiragana(parseInt(current.ID), newValidation);

const hiraganaIndex = HiraganaList.findIndex(h => h.ID == current.ID);
if (hiraganaIndex !== -1) {
HiraganaList[hiraganaIndex].Validation = newValidation.toString();
}

let emoji = "", resultText = "";
if (score === 1) {
const emojisOK = ["🌸", "🎍", "🍵", "🪴", "💮", "🌺", "🌼", "🪷"];
emoji = emojisOK[Math.floor(Math.random() * emojisOK.length)];
resultText = isFinalValidation ? "Validé ! 🎉" : "Parfait !";
if (!isFinalValidation) {
playMarioCoin();
}
} else if (score === 0.5) {
const emojisMid = ["🪨", "🌿", "🪵", "🍃", "🌳", "🎋"];
emoji = emojisMid[Math.floor(Math.random() * emojisMid.length)];
resultText = "Presque...";
playSuccess90s();
} else {
const emojisBad = ["🙈", "🙊", "🪨", "🌊", "🍂", "🍁"];
emoji = emojisBad[Math.floor(Math.random() * emojisBad.length)];
resultText = "Pas tout à fait...";
playFail();
}

document.getElementById("result").innerHTML = `
<div class="result-line">${emoji} ${resultText} ${emoji}</div>
<div class="result-line highlight">
👉 Bonne réponse : <strong>${correct1}</strong> – <strong>${correct2}</strong>
</div>`;

// 🔊 Jouer le fichier MP3 correspondant au Hiragana
if (current && current.Hiragana) {
const audioFile = `${encodeURIComponent(current.Hiragana)}.mp3`;
const audioUrl = `https://emmanuel971-source.github.io/hirakataquizz/${audioFile}`;
console.log("🎧 Lecture du son :", audioUrl);

const audio = new Audio(audioUrl);
audio.play().catch(e => console.warn("Erreur audio :", e));
} else {
console.warn("❗ Aucun Hiragana à prononcer.");
}



if (score === 1) {
document.getElementById("result").innerHTML += "<br><small style='color: #4CAF50;'></small>";
setTimeout(nextQuestion, 1500);
} else {
document.getElementById("continueBtn").style.visibility = "visible";
}

callAPI('updateStats', { id: parseInt(current.ID), scorePoints: score })
.then(response => {
if (response.error) {
console.warn('Erreur sauvegarde:', response.error);
} else {
console.log('✅ Score sauvegardé en arrière-plan');
}
})
.catch(error => {
console.error('Erreur lors de la sauvegarde:', error);
});
}
}

function triggerLightFirework(card) {
const halo = document.createElement("div");
halo.style.position = "absolute";
halo.style.width = "30px";
halo.style.height = "30px";
halo.style.borderRadius = "50%";
halo.style.background = "radial-gradient(circle, rgba(253,193,197,0.9), rgba(253,193,197,0.1))";
halo.style.transform = "translate(-50%, -50%) scale(1)";
halo.style.opacity = "1";
halo.style.pointerEvents = "none";
halo.style.zIndex = "10";

const rect = card.getBoundingClientRect();
const cx = rect.left + rect.width / 2;
const cy = rect.top + rect.height / 2;

halo.style.left = `${cx}px`;
halo.style.top = `${cy}px`;
document.body.appendChild(halo);

halo.animate([
{ transform: "translate(-50%, -50%) scale(1)", opacity: 1 },
{ transform: "translate(-50%, -50%) scale(4)", opacity: 0 }
], {
duration: 800,
easing: "ease-out"
}).onfinish = () => halo.remove();

// Utiliser l'effet de chute de sakura depuis le haut de l'écran
for (let i = 0; i < 30; i++) {
const sakura = document.createElement("div");
sakura.className = "sakura";
sakura.style.left = Math.random() * 100 + "vw";
sakura.style.top = "-10px";
sakura.style.animationDelay = Math.random() * 1.5 + "s";
sakura.style.animationDuration = 2.5 + Math.random() * 1.5 + "s";
document.body.appendChild(sakura);
setTimeout(() => sakura.remove(), 4000);
}

const validatedCount = getValidatedCountForLevel(niveauActif);
if (validatedCount === 0) {
playFireworkSound();
} else if (validatedCount === 1) {
playfireworksound2();
} else if (validatedCount === 2) {
playfireworksound3();
} else if (validatedCount === 3) {
playfireworksound4();
} else if (validatedCount === 4) {
playLevelUp();
triggerLevelUpAnimation(document.body);
}
}

function triggerLevelUpAnimation(container) {
const toHide = ['#question', '#choices1', '#choices2'];
toHide.forEach(id => {
const el = document.querySelector(id);
if (el) el.style.visibility = 'hidden';
});

triggerSakuraFall(container);

setTimeout(() => {
toHide.forEach(id => {
const el = document.querySelector(id);
if (el) {
el.style.visibility = 'visible';
el.style.opacity = 0;
el.animate([
{ opacity: 0 },
{ opacity: 1 }
], {
duration: 600,
fill: 'forwards'
});
}
});
}, 3000);

const msgWrapper = document.createElement("div");
msgWrapper.style.position = "fixed";
msgWrapper.style.top = "30%";
msgWrapper.style.left = "0";
msgWrapper.style.width = "100vw";
msgWrapper.style.textAlign = "center";
msgWrapper.style.zIndex = 9999;
msgWrapper.style.pointerEvents = "none";
document.body.appendChild(msgWrapper);

const msg = document.createElement("div");
msg.innerText = "レベルアップ！";
msg.style.display = "inline-block";
msg.style.fontSize = "5em";
msg.style.fontWeight = "bold";
msg.style.color = "#8B6F47";
msg.style.textShadow = "0 0 20px #A8D5BA, 0 0 40px #FDC1C5";
msg.style.writingMode = "horizontal-tb";
msg.style.whiteSpace = "nowrap";
msgWrapper.appendChild(msg);

msg.animate([
{ transform: "translateY(0)", opacity: 1 },
{ transform: "translateY(-40px)", opacity: 0 }
], {
duration: 5000,
easing: "ease-out"
}).onfinish = () => msgWrapper.remove();

const marker = document.querySelector(".progress-marker");
if (marker) {
marker.animate([
{ transform: "translate(-50%, -50%) rotate(0deg) scale(1)" },
{ transform: "translate(-50%, -50%) rotate(180deg) scale(4)" },
{ transform: "translate(-50%, -50%) rotate(360deg) scale(1)" }
], {
duration: 1000,
easing: "ease-in-out"
});
}
}

function startRevisionQuestion() {
const niveauActif = determineNiveauActif(HiraganaList);
console.log('Niveau actif:', niveauActif);

const excludedKatakanaLevels = [3, 5, 7, 10, 11, 12, 14, 16, 17, 21, 22, 24, 25, 27, 28, 30, 31, 32, 34, 35, 36, 37, 38]; // Niveaux où seuls Hiragana sont proposés

// Items Hiragana disponibles (tous niveaux <= niveauActif)
const hiraganaItems = HiraganaList.filter(h =>
parseInt(h.Niveau || 1) <= niveauActif &&
revisionRomajiTable[h.Hiragana] &&
h.Hiragana && h.Romaji
);

// Items Katakana disponibles (seulement pour niveaux non exclus)
const katakanaItems = HiraganaList.filter(h =>
parseInt(h.Niveau || 1) <= niveauActif &&
!excludedKatakanaLevels.includes(parseInt(h.Niveau || 1)) &&
revisionKatakanaTable[h.Katakana] &&
h.Katakana && h.Romaji
);

// Fusion des items disponibles
const availableItems = [
...hiraganaItems.map(item => ({ ...item, type: 'hiragana', key: item.Hiragana })),
...katakanaItems.map(item => ({ ...item, type: 'katakana', key: item.Katakana }))
];

// Logs de débogage
console.log(`🎯 Items disponibles pour révision: Hiragana=${hiraganaItems.length}, Katakana=${katakanaItems.length}`);
console.log('Items par niveau:', availableItems.reduce((acc, item) => {
const niveau = parseInt(item.Niveau || 1);
acc[niveau] = (acc[niveau] || 0) + 1;
return acc;
}, {}));

if (availableItems.length === 0) {
console.warn('Erreur : Aucun item disponible pour le niveau', niveauActif);
document.getElementById("revision-message").textContent = "Aucun item disponible pour ce niveau";
document.getElementById("revision-message").style.color = "#dc3545";
return;
}

// Sélection pondérée basée sur Validation
const weights = availableItems.map(h => {
const validation = parseInt(h.Validation || 0);
return Math.max(0.1, 5 - validation + 0.5); // Poids entre 0.1 et 5.5
});
const totalWeight = weights.reduce((a, b) => a + b, 0);
let random = Math.random() * totalWeight;
let selectedItem = availableItems[0];

for (let i = 0; i < availableItems.length; i++) {
random -= weights[i];
if (random <= 0) {
selectedItem = availableItems[i];
break;
}
}

// Configurer la question en fonction du type (Hiragana ou Katakana)
revisionMode.currentQuestion = selectedItem.key; // Hiragana ou Katakana
const table = selectedItem.type === 'hiragana' ? revisionRomajiTable : revisionKatakanaTable;
const tableEntry = table[selectedItem.key];
revisionMode.romajiSegments = tableEntry.romaji;
revisionMode.charCounts = tableEntry.charCounts;
revisionMode.fullCorrect = revisionMode.romajiSegments.join("");
revisionMode.currentItem = selectedItem; // Pour stats

// Calculer les positions cumulatives
let cumRom = 0;
revisionMode.cumulativeRomaji = revisionMode.romajiSegments.map(segment => {
cumRom += segment.length;
return cumRom;
});

let cumChar = 0;
revisionMode.cumulativeChars = revisionMode.charCounts.map(count => {
cumChar += count;
return cumChar;
});

// Réinitialiser l'interface
revisionMode.input = "";
document.getElementById("revision-question").innerHTML =
revisionMode.currentQuestion.split("").map((char, index) =>
`<div class="char-card" id="revision-card-${index}">
<span id="revision-char-${index}">${char}</span>
</div>`
).join("");
document.getElementById("revision-input-display").textContent = "";
document.getElementById("revision-message").textContent = "";

// Ajouter pulsation initiale à la première carte
const firstCard = document.getElementById(`revision-card-0`);
if (firstCard) {
firstCard.classList.add("pulsing");
}

console.log(`📝 Question: "${revisionMode.currentQuestion}" (${selectedItem.Romaji}) -> Attendu: "${revisionMode.fullCorrect}"`);
console.log(`🎯 Segments:`, revisionMode.romajiSegments);
}


function updateRevisionFeedback() {
// Reset toutes les classes
for (let i = 0; i < revisionMode.currentQuestion.length; i++) {
const cardElement = document.getElementById(`revision-card-${i}`);
const charElement = document.getElementById(`revision-char-${i}`);
if (cardElement) {
cardElement.classList.remove(
char-correct-1, "char-correct-2", "char-correct-3", "char-correct-4",
char-incorrect-1, "char-incorrect-2", "char-incorrect-3", "char-incorrect-4",
pulsing, "pop-animation"
);
}
if (charElement) {
charElement.classList.remove("pulsing");
}
}

let currentSegment = -1;
const inputLength = revisionMode.input.length;

// Parcourir chaque segment
for (let seg = 0; seg < revisionMode.romajiSegments.length; seg++) {
const romStart = seg > 0 ? revisionMode.cumulativeRomaji[seg - 1] : 0;
const romEnd = revisionMode.cumulativeRomaji[seg];
const charStart = seg > 0 ? revisionMode.cumulativeChars[seg - 1] : 0;
const charEnd = revisionMode.cumulativeChars[seg];
const segmentLength = romEnd - romStart;
const typedLen = Math.max(0, Math.min(inputLength - romStart, segmentLength));
const typedSegment = revisionMode.input.substring(romStart, romStart + typedLen);
const expected = revisionMode.romajiSegments[seg];
let className = "";

console.log(`Segment ${seg}: romStart=${romStart}, romEnd=${romEnd}, typedLen=${typedLen}, typedSegment="${typedSegment}", expected="${expected}"`);

// Gradation basée sur la progression dans le segment
if (typedLen > 0) {
if (expected.startsWith(typedSegment)) {
const level = Math.min(4, typedLen);
className = `char-correct-${level}`;
} else {
const level = Math.min(4, typedLen);
className = `char-incorrect-${level}`;
}
}

// Appliquer la gradation aux cartes du segment
for (let c = charStart; c < charEnd; c++) {
const card = document.getElementById(`revision-card-${c}`);
const span = document.getElementById(`revision-char-${c}`);
if (card) {
card.className = `char-card ${className || ""}`; // Appliquer la gradation
// Ajouter animation "pop" et son si on valide un nouveau caractère
if (inputLength > romStart && c === charStart && !card.classList.contains("pop-animation")) {
card.classList.add("pop-animation");
playPopSound();
setTimeout(() => card.classList.remove("pop-animation"), 300);
}
}
}

// Validation finale uniquement pour le segment courant si entièrement saisi
if (inputLength >= romEnd) {
const fullSegment = revisionMode.input.substring(romStart, romEnd);
if (fullSegment === expected) {
for (let c = charStart; c < charEnd; c++) {
const card = document.getElementById(`revision-card-${c}`);
if (card) {
card.classList.remove("pulsing");
card.className = `char-card char-correct-4`;
}
}
} else if (romStart < inputLength) { // Saisie incorrecte partielle
for (let c = charStart; c < charEnd; c++) {
const card = document.getElementById(`revision-card-${c}`);
if (card) {
card.classList.remove("pulsing");
card.className = `char-card char-incorrect-4`;
}
}
}
}

// Déterminer le segment en cours pour la pulsation
if (romStart <= inputLength && inputLength < romEnd) {
currentSegment = seg;
}
}

// Ajouter la pulsation à la carte en cours
if (currentSegment >= 0) {
const charStart = currentSegment > 0 ? revisionMode.cumulativeChars[currentSegment - 1] : 0;
const charEnd = revisionMode.cumulativeChars[currentSegment];
for (let c = charStart; c < charEnd; c++) {
const cardElement = document.getElementById(`revision-card-${c}`);
if (cardElement) {
cardElement.classList.add("pulsing");
}
}
}
}




// Initialiser les événements du clavier de révision
function initRevisionKeyboard() {
const revisionKeys = document.querySelectorAll('.revision-key');

// Supprimer les anciens event listeners pour éviter les doublons
revisionKeys.forEach(key => {
key.replaceWith(key.cloneNode(true));
});

// Récupérer les nouvelles références après clonage
const newRevisionKeys = document.querySelectorAll('.revision-key');

newRevisionKeys.forEach(key => {
key.addEventListener("click", () => {
if (!revisionMode.isActive) return;

if (key.id === "revision-back") {
// Touche retour
if (revisionMode.input.length > 0) {
revisionMode.input = revisionMode.input.slice(0, -1);
}
} else {
// Touche normale
revisionMode.input += key.textContent;
}

// Mettre à jour l'affichage
document.getElementById("revision-input-display").textContent = revisionMode.input;
updateRevisionFeedback();

// Vérifier si la réponse est complète
const totalLength = revisionMode.cumulativeRomaji[revisionMode.cumulativeRomaji.length - 1] || 1;

// Trouver le caractère Hiragana correspondant à l'ID dans HiraganaList
const hiraganaItem = HiraganaList.find(h => h.ID == revisionMode.currentItem.ID);
const hiraganaChar = hiraganaItem ? hiraganaItem.Hiragana : revisionMode.currentQuestion;

// Vérifier si le niveau est > 38
const niveau = parseInt(revisionMode.currentItem.Niveau || 1);
const isHighLevel = niveau > 38;

// Déterminer si l'item a 2 caractères ou plus (pour niveaux <= 38)
const isMultiChar = revisionMode.romajiSegments.length >= 2;
const katakanaDisplay = (!isHighLevel && isMultiChar) ? ` (${revisionMode.currentItem.Katakana})` : '';

if (revisionMode.input.length === totalLength) {
if (revisionMode.input === revisionMode.fullCorrect) {
// Bonne réponse
document.getElementById("revision-message").textContent = isHighLevel ? "OK" : `🌸 Parfait !${katakanaDisplay} 🌸`;
document.getElementById("revision-message").style.color = "#28a745";
playZenBell(); // Clochette zen
// Jouer le fichier MP3 correspondant au caractère Hiragana
const audioFile = `${encodeURIComponent(hiraganaChar)}.mp3`;
const audioUrl = `https://emmanuel971-source.github.io/hirakataquizz/${audioFile}`;
console.log("🎧 Lecture du son :", audioUrl);
const audio = new Audio(audioUrl);
audio.play().catch(e => console.warn('Erreur audio:', e));
// Mettre à jour les stats via l'API
callAPI('updateStats', { id: parseInt(revisionMode.currentItem.ID), scorePoints: 1 })
.then(response => {
if (response.error) {
console.warn('Erreur sauvegarde:', response.error);
} else {
console.log('✅ Score sauvegardé pour révision');
const hiraganaIndex = HiraganaList.findIndex(h => h.ID == revisionMode.currentItem.ID);
if (hiraganaIndex !== -1) {
const currentValidation = parseInt(HiraganaList[hiraganaIndex].Validation || 0);
HiraganaList[hiraganaIndex].Validation = Math.min(5, currentValidation + 1).toString();
}
}
});
setTimeout(() => {
startRevisionQuestion();
}, 2000);
} else {
// Mauvaise réponse
document.getElementById("revision-message").textContent = isHighLevel
? "Faux"
: `❌ ERREUR : ${revisionMode.fullCorrect}${katakanaDisplay}`;
document.getElementById("revision-message").style.color = "#dc3545";
playSoftError(); // Bip atténué
// Jouer le fichier MP3 correspondant au caractère Hiragana
const audioFile = `${encodeURIComponent(hiraganaChar)}.mp3`;
const audioUrl = `https://emmanuel971-source.github.io/hirakataquizz/${audioFile}`;
console.log("🎧 Lecture du son :", audioUrl);
const audio = new Audio(audioUrl);
audio.play().catch(e => console.warn('Erreur audio:', e));
callAPI('updateStats', { id: parseInt(revisionMode.currentItem.ID), scorePoints: 0 });
setTimeout(() => {
startRevisionQuestion();
}, 3000);
}
} else if (revisionMode.input.length > totalLength) {
// Trop de caractères
document.getElementById("revision-message").textContent = isHighLevel
? "Faux"
: `❌ Trop long ! Correct : ${revisionMode.fullCorrect}${katakanaDisplay}`;
document.getElementById("revision-message").style.color = "#dc3545";
playSoftError(); // Bip atténué
// Jouer le fichier MP3 correspondant au caractère Hiragana
const audioFile = `${encodeURIComponent(hiraganaChar)}.mp3`;
const audioUrl = `https://emmanuel971-source.github.io/hirakataquizz/${audioFile}`;
console.log("🎧 Lecture du son :", audioUrl);
const audio = new Audio(audioUrl);
audio.play().catch(e => console.warn('Erreur audio:', e));
callAPI('updateStats', { id: parseInt(revisionMode.currentItem.ID), scorePoints: 0 });
revisionMode.input = "";
document.getElementById("revision-input-display").textContent = "";
setTimeout(() => {
startRevisionQuestion();
}, 3000);
}
});
});
}


// Appeler l'initialisation au chargement de la page
window.addEventListener('load', () => {
initRevisionKeyboard();
});



// Démarrage du jeu
window.onload = () => {
initGame();
};
// S'assurer que les voix sont bien chargées
speechSynthesis.onvoiceschanged = () => {
console.log("📢 Voix disponibles :", speechSynthesis.getVoices());
};

</script>

</body>
</html>

