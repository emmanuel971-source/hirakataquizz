<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz Vocal Hiragana - Protocole de Test</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/speech-commands@latest/dist/speech-commands.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', sans-serif; text-align: center; padding: 20px; background: #f0f2f5; color: #1c1e21; }
        .container { max-width: 600px; margin: 0 auto; }
        
        /* Cartes */
        .card { background: white; padding: 20px; border-radius: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); margin-bottom: 20px; transition: 0.3s; }
        
        /* Zone Quiz */
        #quiz-card { display: none; border: 4px solid transparent; }
        .quiz-active { border-color: #2196f3 !important; }
        .quiz-success { border-color: #4caf50 !important; background-color: #e8f5e9 !important; }
        .quiz-fail { border-color: #f44336 !important; background-color: #ffebee !important; }

        .hiragana-big { font-size: 5rem; font-weight: bold; color: #333; margin: 10px 0; }
        .romaji-hint { font-size: 1.5rem; color: #888; text-transform: uppercase; font-weight: bold; }
        
        /* Timer */
        .timer-bar { width: 100%; height: 10px; background: #eee; border-radius: 5px; margin-top: 15px; overflow: hidden; }
        .timer-fill { height: 100%; width: 100%; background: #2196f3; transition: width linear; }

        /* Contr√¥les */
        input[type="text"] { padding: 10px; font-size: 16px; border-radius: 8px; border: 1px solid #ccc; width: 70%; margin-bottom: 10px; }
        .btn { padding: 12px 25px; font-size: 16px; border-radius: 8px; border: none; color: white; font-weight: bold; cursor: pointer; margin: 5px; transition: transform 0.1s; }
        .btn:active { transform: scale(0.98); }
        .btn-blue { background: #2196f3; }
        .btn-green { background: #4caf50; }
        .btn-red { background: #f44336; }
        .btn:disabled { background: #b0bec5; cursor: not-allowed; }

        /* Stats et Logs */
        .stats-mini { display: flex; justify-content: space-around; font-size: 0.9rem; color: #555; margin-top: 10px; }
        .hidden { display: none; }
    </style>
</head>
<body>

    <div class="container">
        <div class="card" id="setup-card">
            <h1>üéôÔ∏è Calibrage Hiragana</h1>
            <p>Protocole de test v1.0</p>
            
            <div style="margin: 20px 0;">
                <label style="display:block; margin-bottom:5px; font-weight:bold;">Votre Nom / Appareil :</label>
                <input type="text" id="username" placeholder="ex: Pierre_Android" value="Testeur_01">
            </div>

            <div style="margin: 20px 0;">
                <label>Sensibilit√© Micro : <span id="gain-val">1.0</span>x</label>
                <input type="range" id="gain-slider" min="0.5" max="5" step="0.1" value="1" style="width:100%">
            </div>

            <button id="btn-start" class="btn btn-blue">üöÄ Initialiser & D√©marrer</button>
            <div id="loading" class="hidden">Chargement du mod√®le...</div>
        </div>

        <div class="card" id="quiz-card">
            <div style="display:flex; justify-content:space-between; color:#888;">
                <span>Question: <b id="q-count">0</b></span>
                <span>RMS: <b id="rms-disp">0.00</b></span>
            </div>

            <div class="hiragana-big" id="target-char">?</div>
            <div class="romaji-hint" id="target-romaji">PR√äT ?</div>

            <div class="timer-bar">
                <div class="timer-fill" id="timer-fill"></div>
            </div>

            <div class="stats-mini">
                <span id="feedback-top1">En attente...</span>
            </div>
        </div>

        <div class="card hidden" id="action-card">
            <button id="btn-next" class="btn btn-blue" onclick="nextQuestion()">Suivant (Auto)</button>
            <button id="btn-stop" class="btn btn-red" onclick="stopQuiz()">‚èπÔ∏è Finir & T√©l√©charger CSV</button>
            <div id="log-count" style="margin-top:10px; color:#666; font-size:0.8rem;">0 r√©sultats enregistr√©s</div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        // Remplace par ton URL Teachable Machine
        const URL_MODEL = "https://teachablemachine.withgoogle.com/models/SJdR1p2tx/"; 
        
        // Mapping Romaji -> Hiragana pour l'affichage
        // (Assure-toi que les cl√©s correspondent aux √©tiquettes de ton mod√®le Teachable Machine)
        const HIRAGANA_MAP = {
            'a': '„ÅÇ', 'i': '„ÅÑ', 'u': '„ÅÜ', 'e': '„Åà', 'o': '„Åä'
        };
        const VOWELS = ['„ÅÇ', '„ÅÑ', '„ÅÜ', '„Åà', '„Åä'];

        // --- VARIABLES GLOBALES ---
        let recognizer, audioContext, gainNode, analyser, dataArray;
        let isListening = false;
        let currentTarget = "";
        let logs = [];
        let questionCount = 0;
        
        // Variables de capture pendant les 3 secondes
        let sessionBest = { label: "", score: 0, label2: "", score2: 0 };
        let sessionMaxRMS = 0;
        let sessionAvgRMS = 0;
        let rmsSum = 0;
        let rmsCount = 0;

        // --- INITIALISATION ---
        document.getElementById('btn-start').onclick = async () => {
            const btn = document.getElementById('btn-start');
            const name = document.getElementById('username').value.trim();
            if(!name) { alert("Merci d'entrer un nom !"); return; }

            btn.disabled = true;
            document.getElementById('loading').classList.remove('hidden');

            try {
                // 1. Audio Setup
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const source = audioContext.createMediaStreamSource(stream);
                
                gainNode = audioContext.createGain();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                dataArray = new Float32Array(analyser.fftSize);

                source.connect(gainNode);
                gainNode.connect(analyser); // Pour visualisation RMS
                // On ne connecte pas √† destination pour √©viter le feedback audio

                // 2. Load Model
                recognizer = speechCommands.create("BROWSER_FFT", undefined, URL_MODEL + "model.json", URL_MODEL + "metadata.json");
                await recognizer.ensureModelLoaded();

                // 3. UI Switch
                document.getElementById('setup-card').classList.add('hidden');
                document.getElementById('quiz-card').style.display = 'block';
                document.getElementById('action-card').classList.remove('hidden');

                // 4. Start Loop
                updateRMSLoop();
                startContinuousRecognition();
                
                // Lancer la premi√®re question apr√®s 1s
                setTimeout(nextQuestion, 1000);

            } catch (e) {
                alert("Erreur micro ou mod√®le : " + e);
                console.error(e);
                btn.disabled = false;
            }
        };

       // --- BOUCLE DE RECONNAISSANCE CONTINUE (CORRIG√âE) ---
        function startContinuousRecognition() {
            recognizer.listen(result => {
                if (!isListening) return;

                const labels = recognizer.wordLabels();
                const scores = Array.from(result.scores).map((s, i) => ({ label: labels[i], score: s }));
                
                // Trier par score d√©croissant
                scores.sort((a, b) => b.score - a.score);

                const top1 = scores[0];
                const top2 = scores[1] || {label: "none", score: 0};

                // --- CORRECTION MAGIQUE ICI ---
                
                // 1. D√©tecter si c'est du bruit de fond (adapte les mots-cl√©s si besoin)
                const isBackground = top1.label.toLowerCase().includes("background") || 
                                     top1.label.toLowerCase().includes("bruit");

                // 2. Si c'est du bruit de fond, on l'ignore (sauf si on n'a encore rien trouv√©)
                if (isBackground) {
                    // On ne fait rien, on attend que tu parles
                    // (Sauf si on veut afficher "Silence" √† l'√©cran)
                    return; 
                }

                // 3. LOGIQUE DE PRIORIT√â :
                // Si on entend la BONNE r√©ponse avec un score correct (> 70%), on la verrouille presque √† coup s√ªr
                // Sinon, on garde la meilleure r√©ponse entendue qui n'est pas du bruit.
                
                // Est-ce que ce qu'on entend correspond √† la cible ?
                const isTarget = top1.label === currentTarget;

                // Cas A : On entend la CIBLE avec un bon score
                if (isTarget && top1.score > 0.70) {
                    // On force la mise √† jour car c'est ce qu'on voulait entendre
                    // On privil√©gie la cible m√™me si un autre bruit bizarre avait eu un score un peu plus haut avant
                    if (top1.score > sessionBest.score || sessionBest.label !== currentTarget) {
                         updateSessionBest(top1, top2);
                    }
                } 
                // Cas B : On entend autre chose (une erreur), mais avec un score tr√®s fort
                else if (top1.score > sessionBest.score) {
                    // On met √† jour seulement si c'est mieux que ce qu'on avait avant
                    // Et on v√©rifie qu'on n'√©crase pas une bonne r√©ponse d√©j√† trouv√©e avec une confiance similaire
                    const alreadyFoundTarget = sessionBest.label === currentTarget;
                    
                    if (!alreadyFoundTarget) {
                        updateSessionBest(top1, top2);
                    }
                }

            }, { probabilityThreshold: 0.1, overlapFactor: 0.5 });
        }

        // Petite fonction utilitaire pour √©viter de r√©p√©ter le code
        function updateSessionBest(s1, s2) {
            sessionBest.label = s1.label;
            sessionBest.score = s1.score;
            sessionBest.label2 = s2.label;
            sessionBest.score2 = s2.score;
            
            // Feedback visuel imm√©diat (pour rassurer l'utilisateur)
            const isCorrect = sessionBest.label === currentTarget;
            const color = isCorrect ? "green" : "#d32f2f";
            const icon = isCorrect ? "‚úÖ" : "üëÇ";
            
            document.getElementById('feedback-top1').innerHTML = 
                `<span style="color:${color}; font-weight:bold;">${icon} Retenu: ${sessionBest.label} (${(sessionBest.score*100).toFixed(0)}%)</span>`;
        }
        // --- GESTION DU QUIZ ---
        function nextQuestion() {
            // Reset de l'√©tat
            questionCount++;
            document.getElementById('q-count').innerText = questionCount;
            
            // Choisir une voyelle au hasard
            const randKey = VOWELS[Math.floor(Math.random() * VOWELS.length)];
            currentTarget = randKey;

            // UI Reset
            const card = document.getElementById('quiz-card');
            card.className = "card quiz-active";
            document.getElementById('target-char').innerText = HIRAGANA_MAP[randKey] || randKey;
            document.getElementById('target-romaji').innerText = randKey;
            document.getElementById('feedback-top1').innerText = "√âcoute en cours...";
            
            // Reset Stats Session
            sessionBest = { label: "Silence", score: 0, label2: "-", score2: 0 };
            sessionMaxRMS = 0;
            rmsSum = 0;
            rmsCount = 0;
            
            // Animation Timer (3 secondes)
            const timer = document.getElementById('timer-fill');
            timer.style.transition = 'none';
            timer.style.width = '100%';
            
            setTimeout(() => {
                timer.style.transition = 'width 3s linear';
                timer.style.width = '0%';
                isListening = true; // D√©but √©coute
            }, 50);

            // Fin de la question apr√®s 3s
            setTimeout(finishQuestion, 3050);
        }

        function finishQuestion() {
            isListening = false;
            
            // Calculer Moyenne RMS
            sessionAvgRMS = rmsCount > 0 ? (rmsSum / rmsCount) : 0;

            // Enregistrer le log
            const timestamp = new Date().toLocaleString('fr-FR');
            const username = document.getElementById('username').value.replace(/[^a-zA-Z0-9_-]/g, ""); // Clean name
            const filenameMock = `LiveTest_${username}`; // Pour matcher ton dashboard

            const logEntry = {
                timestamp: timestamp,
                filename: filenameMock,
                expected: currentTarget, // ex: 'a'
                top1: sessionBest.label,
                score1: sessionBest.score.toFixed(4),
                top2: sessionBest.label2,
                score2: sessionBest.score2.toFixed(4),
                rms: sessionAvgRMS.toFixed(6),
                gain: gainNode.gain.value.toFixed(2)
            };
            logs.push(logEntry);
            document.getElementById('log-count').innerText = `${logs.length} r√©sultats enregistr√©s`;

            // Feedback Visuel
            const card = document.getElementById('quiz-card');
            const isCorrect = sessionBest.label === currentTarget;
            
            if (isCorrect) {
                card.classList.remove('quiz-active');
                card.classList.add('quiz-success');
                document.getElementById('feedback-top1').innerHTML = `‚úÖ Bravo ! (${(sessionBest.score*100).toFixed(0)}%)`;
            } else {
                card.classList.remove('quiz-active');
                card.classList.add('quiz-fail');
                document.getElementById('feedback-top1').innerHTML = `‚ùå Entendu : ${sessionBest.label}`;
            }

            // Auto-next rapide
            setTimeout(nextQuestion, 1500);
        }

        // --- EXPORT CSV ---
        function stopQuiz() {
            isListening = false;
            if (logs.length === 0) { alert("Aucune donn√©e √† exporter."); return; }

            // En-t√™tes compatibles avec ton Dashboard
            let csvContent = "Horodatage,NomFichier,Attendu,Top1,Score1,Top2,Score2,RMS,Gain\n";

            logs.forEach(row => {
                csvContent += `${row.timestamp},${row.filename},${row.expected},${row.top1},${row.score1},${row.top2},${row.score2},${row.rms},${row.gain}\n`;
            });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            
            // Nom fichier avec date et utilisateur
            const dateStr = new Date().toISOString().slice(0,10);
            const user = document.getElementById('username').value;
            link.setAttribute("href", url);
            link.setAttribute("download", `resultats_marathon_${user}_${dateStr}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // --- UTILITAIRES ---
        function updateRMSLoop() {
            if (analyser) {
                analyser.getFloatTimeDomainData(dataArray);
                let sum = 0;
                for (let i = 0; i < dataArray.length; i++) { sum += dataArray[i] * dataArray[i]; }
                let rms = Math.sqrt(sum / dataArray.length);
                
                document.getElementById('rms-disp').innerText = rms.toFixed(4);
                
                if (isListening) {
                    rmsSum += rms;
                    rmsCount++;
                    if (rms > sessionMaxRMS) sessionMaxRMS = rms;
                }
            }
            requestAnimationFrame(updateRMSLoop);
        }

        document.getElementById('gain-slider').oninput = (e) => {
            const val = e.target.value;
            document.getElementById('gain-val').innerText = val;
            if (gainNode) gainNode.gain.value = parseFloat(val);
        };
    </script>
</body>
</html>
