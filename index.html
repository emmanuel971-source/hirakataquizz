<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>G√©n√©rateur de Voyelles WAV & ZIP</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', Arial, sans-serif; max-width: 800px; margin: 20px auto; padding: 20px; background-color: #f0f2f5; }
        .container { background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        h1 { color: #1a73e8; text-align: center; }
        .info { background: #e8f0fe; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 5px solid #1a73e8; }
        button { background: #1a73e8; color: white; border: none; padding: 15px; font-size: 16px; border-radius: 8px; cursor: pointer; width: 100%; margin-bottom: 10px; font-weight: bold; }
        button:hover { background: #1557b0; }
        button:disabled { background: #bdc1c6; cursor: not-allowed; }
        .progress { margin-top: 20px; display: none; }
        .progress-bar { width: 100%; height: 20px; background: #e0e0e0; border-radius: 10px; overflow: hidden; margin: 10px 0; }
        .progress-fill { height: 100%; background: #34a853; width: 0%; transition: width 0.2s; }
        .log { max-height: 200px; overflow-y: auto; background: #202124; color: #f1f3f4; padding: 15px; border-radius: 8px; font-family: 'Consolas', monospace; font-size: 11px; margin-top: 15px; }
        .success { color: #81c995; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéôÔ∏è G√©n√©rateur WAV vers ZIP</h1>
        
        <div class="info">
            <strong>Configuration :</strong> 150 fichiers WAV (1 sec) packag√©s dans un ZIP.<br>
            <span id="voiceCount">D√©tection des voix en cours...</span>
        </div>

        <button id="startBtn" onclick="startGeneration()">üöÄ G√©n√©rer le fichier ZIP</button>
        
        <div class="progress" id="progressDiv">
            <div id="statusLabel">Pr√©paration...</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="log" id="log"></div>
        </div>
    </div>

    <script>
        let voices = [];
        const voyelles = ['A', '√â', 'I', 'O', 'U'];
        const zip = new JSZip();
        let generatedCount = 0;

        function loadVoices() {
            voices = speechSynthesis.getVoices().filter(v => v.lang.startsWith('fr'));
            document.getElementById('voiceCount').textContent = `${voices.length} voix fran√ßaises d√©tect√©es`;
        }
        speechSynthesis.onvoiceschanged = loadVoices;
        loadVoices();

        function log(msg, type = '') {
            const l = document.getElementById('log');
            l.innerHTML += `<div class="${type}">${new Date().toLocaleTimeString()} - ${msg}</div>`;
            l.scrollTop = l.scrollHeight;
        }

        // --- Encodeur WAV (Simplifi√© pour 44.1kHz Mono) ---
        function bufferToWave(abuffer, len) {
            let numOfChan = abuffer.numberOfChannels,
                length = len * numOfChan * 2 + 44,
                buffer = new ArrayBuffer(length),
                view = new DataView(buffer),
                channels = [], i, sample, offset = 0, pos = 0;

            setUint32(0x46464952); // "RIFF"
            setUint32(length - 8); // file length
            setUint32(0x45564157); // "WAVE"
            setUint32(0x20746d66); // "fmt " chunk
            setUint32(16);         // length = 16
            setUint16(1);          // PCM (uncompressed)
            setUint16(numOfChan);
            setUint32(abuffer.sampleRate);
            setUint32(abuffer.sampleRate * 2 * numOfChan); // avg. bytes/sec
            setUint16(numOfChan * 2); // block-align
            setUint16(16);         // 16-bit
            setUint32(0x61746164); // "data" chunk
            setUint32(length - pos - 4); // chunk length

            for(i = 0; i < abuffer.numberOfChannels; i++) channels.push(abuffer.getChannelData(i));
            while(pos < length) {
                for(i = 0; i < numOfChan; i++) {
                    sample = Math.max(-1, Math.min(1, channels[i][offset]));
                    sample = (sample < 0 ? sample * 0x8000 : sample * 0x7FFF);
                    view.setInt16(pos, sample, true);
                    pos += 2;
                }
                offset++;
            }
            return new Blob([buffer], {type: "audio/wav"});

            function setUint16(data) { view.setUint16(pos, data, true); pos += 2; }
            function setUint32(data) { view.setUint32(pos, data, true); pos += 4; }
        }

        async function createAudioFile(vowel, vIdx, pitch, rate) {
            return new Promise((resolve) => {
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const utterance = new SpeechSynthesisUtterance(vowel);
                utterance.voice = voices[vIdx % voices.length];
                utterance.pitch = pitch;
                utterance.rate = rate;

                // On utilise un script processor pour capturer le flux
                const dest = audioCtx.createMediaStreamDestination();
                const recorder = new MediaRecorder(dest.stream);
                const chunks = [];

                // Pour garantir 1 seconde, on contr√¥le le flux Web Audio
                const duration = 1000; 
                
                utterance.onstart = () => {
                    recorder.start();
                    setTimeout(() => {
                        if(recorder.state === "recording") recorder.stop();
                    }, duration);
                };

                recorder.ondataavailable = e => chunks.push(e.data);
                recorder.onstop = async () => {
                    const blob = new Blob(chunks);
                    const arrayBuffer = await blob.arrayBuffer();
                    const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                    const wavBlob = bufferToWave(audioBuffer, audioBuffer.length);
                    
                    const name = `voyelle_${vowel}_${generatedCount}.wav`;
                    zip.file(name, wavBlob);
                    
                    generatedCount++;
                    const pct = (generatedCount / 150) * 100;
                    document.getElementById('progressFill').style.width = pct + '%';
                    document.getElementById('statusLabel').textContent = `Progression : ${generatedCount}/150`;
                    
                    audioCtx.close();
                    resolve();
                };

                speechSynthesis.speak(utterance);
            });
        }

        async function startGeneration() {
            if (voices.length === 0) return alert("Attendez que les voix soient charg√©es...");
            
            document.getElementById('startBtn').disabled = true;
            document.getElementById('progressDiv').style.display = 'block';
            generatedCount = 0;
            log("üöÄ D√©but du rendu...");

            for (const v of voyelles) {
                for (let i = 0; i < 30; i++) {
                    const p = 0.5 + (Math.random() * 1.5); // Pitch al√©atoire entre 0.5 et 2
                    const r = 0.8 + (Math.random() * 0.4); // Vitesse naturelle
                    await createAudioFile(v, i, p, r);
                    // Pause courte pour laisser le processeur respirer
                    await new Promise(r => setTimeout(r, 50));
                }
                log(`‚úì Voyelle ${v} termin√©e`, 'success');
            }

            log("üì¶ Cr√©ation du fichier ZIP...");
            const content = await zip.generateAsync({type:"blob"});
            const url = URL.createObjectURL(content);
            const a = document.createElement('a');
            a.href = url;
            a.download = "voyelles_audio.zip";
            a.click();
            
            log("üéâ Termin√© ! Le t√©l√©chargement a d√©marr√©.", 'success');
            document.getElementById('startBtn').disabled = false;
        }
    </script>
</body>
</html>
