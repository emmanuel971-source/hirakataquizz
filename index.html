<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="data:,">
  <base target="_top">
  <style>
    html {
      touch-action: pan-x pan-y;
      -ms-touch-action: pan-x pan-y;
    }

    * {
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      background: #F8F1E9;
      font-family: 'Noto Sans JP', sans-serif;
      color: #8B6F47;
      font-family: sans-serif;
      text-align: center;
      padding: 0.5em 1em 1em 1em;
      margin: 0;
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    body::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      background: url('https://www.transparenttextures.com/patterns/paper-fibers.png');
      opacity: 0.1;
      z-index: -1;
    }
/* H1 DESKTOP */
    h1 {
      margin: 0.5em 0;
      font-size: 1.8em;
      text-align: center;
      color: #8B6F47;
      text-shadow: 0 1px 2px rgba(139, 111, 71, 0.3);
    }
/* H1 SMARTPHONES */
   @media (max-width: 480px) and (-webkit-min-device-pixel-ratio: 2) {
      h1 {
        font-size: 1.4em;
        margin: 0.1em 0;
      }
    }
/* H1 TABLETTES */
    @media (min-width: 600px) and (max-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) {
      h1 {
        font-size: 2.2em;
        margin: 0.15em 0;
      }
    }
/* H2 DESKTOP */
    h2 {
      margin: 0.1em 0;
      font-size: 2.5em;
      text-align: center;
      color: #8B6F47;
      text-shadow: 0 1px 2px rgba(139, 111, 71, 0.3);
      margin-bottom: 5px;
    }
/* H2 SMARTPHONES */
    @media (max-width: 480px) and (-webkit-min-device-pixel-ratio: 2) {
      h2 {
        font-size: 1.4em;
        margin: 0 0;
      }
    }
/* H2 TABLETTES */
    @media (min-width: 481px) and (max-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) {
      h2 {
        font-size: 2.5em;
        margin: 0.15em 0;
      }
    }

/* Desktop - gap normal */
.menu {
  gap: 15px;
}

/* Smartphones - gap réduit */
@media (max-width: 480px) and (-webkit-min-device-pixel-ratio: 2) {
  .menu {
    gap: 10px; /* Au lieu de 15px */
  }
}

/* Tablettes - gap intermédiaire */
@media (min-width: 481px) and (max-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) {
  .menu {
    gap: 15px;
  }
}    
    
    
    
    
    
/* Section Page d'accueil DESKTOP */
#welcome {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  height: 100vh;
  text-align: center;
}

.panda-logo {
  font-size: 12em;
  cursor: pointer;
  transition: transform 0.3s ease;
  animation: pandaPulse 2s ease-in-out infinite;
}

.panda-logo:hover {
  transform: scale(1.1);
}

@keyframes pandaPulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.20); }
}

.welcome-title {
  font-size: 2.5em;
  color: #8B6F47;
  text-shadow: 0 1px 2px rgba(139, 111, 71, 0.3);
  margin-top: 50px;
  margin-bottom: 5px;
}

.welcome-subtitle {
  font-size: 1.2em;
  color: #8B6F47;
  opacity: 0.8;
}

.loading-dots {
  font-size: 1.5em;
  color: #8B6F47;
  margin-top: 30px;
  animation: loadingDots 1.5s infinite;
  margin-bottom: 1px;
}

@keyframes loadingDots {
  0% { opacity: 0.2; }
  20% { opacity: 1; }
  100% { opacity: 0.2; }
}
.hidden {
  display: none !important;
}

/*  Section Page d'accueil SMARTPHONES */
@media (max-width: 480px) and (-webkit-min-device-pixel-ratio: 2) {
  .panda-logo {
    font-size: 8em;
  }
  
  .welcome-title {
    font-size: 1.4em;
  }
  
  .welcome-subtitle {
    font-size: 1em;
  }
  
  .loading-dots {
    font-size: 1.4em;
  }
}

/* Section Page d'accueil TABLETTES */
    @media (min-width: 600px) and (max-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) {
       .panda-logo {
    font-size: 15em;
  }
  
  .welcome-title {
    font-size: 3em;
  }
  
  .welcome-subtitle {
    font-size: 2em;
  }
  
  .loading-dots {
    font-size: 2.5em;
  }
  }
    
/* BARRE DE DEBLOCAGE DU MODE REVISION - DESKTOP */    
/* Conteneur de la barre de progression */
#unlock-progress-container,
.unlock-progress-container {
  margin: 15px auto;            /* Centrer le container */
  padding: 10px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 8px;
  max-width: 400px;             /* Largeur max sur desktop */
  width: 100%;                  /* S'adapte à l'espace dispo */
  box-sizing: border-box;
}

/* La barre */
.unlock-progress-bar {
  position: relative;
  height: 20px; /* Légèrement plus fine */
  background: #e0e0e0;
  border-radius: 10px;
  overflow: hidden;
  border: 2px solid #ccc;
}

/* Le remplissage */
.unlock-progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #ff6b6b, #ff8e8e);
  border-radius: 8px;
  transition: width 0.3s ease;
  position: relative;
}

/* Animation quand on approche du déblocage */
.unlock-progress-fill.proche-deblocage {
  animation: pulse-unlock 1s infinite;
}

    
@keyframes pulse-unlock {
  0%, 100% { background: linear-gradient(90deg, #4CAF50, #66BB6A); }
  50% { background: linear-gradient(90deg, #66BB6A, #81C784); }
}

/* BARRE DE DEBLOCAGE DU MODE REVISION - SMARTPHONE */  
/* Responsive : sur mobile → occupe 90% de la largeur */
@media (max-width: 480px) and (-webkit-min-device-pixel-ratio: 2) {
#unlock-progress-container,
.unlock-progress-container {
  margin: 5px auto;            /* Centrer le container */
  padding: 10px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 4px;
  max-width: 400px;             /* Largeur max sur desktop */
  width: 100%;                  /* S'adapte à l'espace dispo */
  box-sizing: border-box;
}

/* La barre */
.unlock-progress-bar {
  position: relative;
  height: 8px; /* Légèrement plus fine */
  background: #e0e0e0;
  border-radius: 4px;
  overflow: hidden;
  border: 1px solid #ccc;
}

/* Le remplissage */
.unlock-progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #ff6b6b, #ff8e8e);
  border-radius: 4px;
  transition: width 0.3s ease;
  position: relative;
}
}
/* BARRE DE DEBLOCAGE DU MODE REVISION - TABLETTES */  
/* Responsive : sur mobile → occupe 90% de la largeur */
@media (min-width: 481px) and (max-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) {
#unlock-progress-container,
.unlock-progress-container {
  margin: 5px auto;            /* Centrer le container */
  padding: 10px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 4px;
  max-width: 400px;             /* Largeur max sur desktop */
  width: 100%;                  /* S'adapte à l'espace dispo */
  box-sizing: border-box;
}

/* La barre */
.unlock-progress-bar {
  position: relative;
  height: 8px; /* Légèrement plus fine */
  background: #e0e0e0;
  border-radius: 4px;
  overflow: hidden;
  border: 1px solid #ccc;
}

/* Le remplissage */
.unlock-progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #ff6b6b, #ff8e8e);
  border-radius: 4px;
  transition: width 0.3s ease;
  position: relative;
}
}



    
/* BARRE DE PROGRESSION DU MODE APPRENDRE - DESKTOP */        
    #progressBarContainer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5em;
      margin: 1em auto 0.3em auto;
      max-width: 50ch;
      width: 100%;
      margin-bottom: 10px;
    }

    .progress-bar-track {
      position: relative;
      height: 16px;
      background: linear-gradient(to right, #E0F7FA, #355E3B);
      border-radius: 6px;
      flex: 1;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .progress-marker {
      position: absolute;
      top: 45%;
      left: 0;
      transform: translate(-50%, -50%);
      font-size: 2em;
      transition: left 1.5s ease;
      color: #636E72;
    }

    .side-emoji {
      font-size: 1.6em;
      line-height: 1;
      color: #636E72;
    }

    @keyframes pulse {
      0% { transform: translate(-50%, -50%) scale(1); }
      100% { transform: translate(-50%, -50%) scale(1.2); }
    }

    .level {
        font-size: 1.6em;
        margin: 0.4em 0;
        margin-bottom: 50px;
    } 
    /* BARRE DE PROGRESSION DU MODE APPRENDRE - SMARTPHONES */      
 @media (max-width: 480px) and (-webkit-min-device-pixel-ratio: 2) {
      #progressBarContainer {
        max-width: 90%;
        margin: 1.5em auto 0.5em auto;
        gap: 1em;
        
      }

      .progress-bar-track {
        height: 12px;
        border-radius: 4px;
      }

      .progress-marker {
        font-size: 2.0em;
        top: 45%;
        transform: translate(-50%, -50%);
      }

      .side-emoji {
        font-size: 1.2em;
      }

      .level {
        font-size: 1.0em;
        margin: 0.4em 0;
        margin-bottom: 25px;
      } 
    }
    /* BARRE DE PROGRESSION DU MODE APPRENDRE - TABLETTES */  
    @media (min-width: 600px) and (max-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) {
      #progressBarContainer {
        max-width: 80%;
        margin: 1.2em auto 0.3em auto;
        gap: 1em;
        
      }

      .progress-bar-track {
        height: 20px;
        border-radius: 8px;
      }

      .progress-marker {
        font-size: 3.2em;
        top: 45%;
        transform: translate(-50%, -50%);
      }

      .side-emoji {
        font-size: 2.0em;
      }

      .level {
        font-size: 1.2em;
        margin: 0.4em 0;
        margin-bottom: 30px;
      } 
    }



        
/* LES CARTES MODE APPRENDRE - DESKTOP */ 
    .level-hiraganas {
      margin: 1em auto;
      max-width: 800px;
      flex-shrink: 0;
      margin-bottom: 25px;
    }

    .hiraganas-grid {
      display: flex;
      justify-content: center;
      gap: 20px;
      flex-wrap: wrap;
      margin-bottom: 0.5em;
    }

    .hiragana-card {
      text-align: center;
      transition: all 0.3s ease;
      position: relative;
      padding: 10px;
      background: #FFFFFF;
      border-radius: 8px;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25), 0 3px 6px rgba(0, 0, 0, 0.15);
    }

    .hiragana-card.completed {
      background: #DDE6D5;
      animation: completedPulse 2s ease-in-out infinite;
    }

    @keyframes completedPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    .hiragana-char {
      font-size: 2.2em;
      font-weight: bold;
      margin-bottom: 6px;
      color: #8B6F47;
      text-shadow: 0 0 3px rgba(139, 111, 71, 0.3);
    }

    .hiragana-card.completed .hiragana-char {
      color: #A8D5BA;
      text-shadow: 0 0 5px rgba(168, 213, 186, 0.5);
      animation: starGlow 2s ease-in-out infinite;
    }

    .stars-container {
      display: flex;
      justify-content: center;
      gap: 2px;
    }

    .star {
      width: 12px;
      height: 12px;
      background: #E8ECEF;
      clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
      transition: all 0.3s ease;
    }

    .star.filled {
      background: #FDC1C5;
    }

    .star.new-star {
      animation: starFill 0.5s ease-in-out;
    }

    .hiragana-card.completed .star.filled {
      background: #A8D5BA;
      animation: starGlow 2s ease-in-out infinite;
    }

    @keyframes starFill {
      0% { transform: scale(0) rotate(180deg); }
      100% { transform: scale(1) rotate(0deg); }
    }

    @keyframes starGlow {
      0%, 100% { filter: brightness(1); }
      50% { filter: brightness(1.3); }
    }

    .firework {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 0.5em;
      height: 0.5em;
      background: transparent;
      pointer-events: none;
      animation: fireworkExplosion 700ms ease-out forwards;
      z-index: 10;
    }

    @keyframes fireworkExplosion {
      0% {
        box-shadow: 0 0 #ff0, 0 0 #f00, 0 0 #0ff;
        opacity: 1;
        transform: translateX(-50%) scale(1);
      }
      100% {
        box-shadow: 0 -40px #ff0, 30px -30px #f00, 40px 0 #0ff, 30px 30px #0f0, 0 40px #00f, -30px 30px #f0f, -40px 0 #fff, -30px -30px #ff0;
        opacity: 0;
        transform: translateX(-50%) scale(0.5);
      }
    }

    .sakura {
      position: absolute;
      width: 100px;
      height: 10px;
      background: #FDC1C5;
      border-radius: 50%;
      pointer-events: none;
      animation: sakuraFall 3s linear forwards;
      z-index: 10;
    }

    @keyframes sakuraFall {
      0% { transform: translateY(0) rotate(0deg); opacity: 1; }
      100% { transform: translateY(110vh) rotate(720deg); opacity: 0; }
    }

    /* LES CARTES MODE APPRENDRE - SMARTPHONES */ 
   @media (max-width: 480px) and (-webkit-min-device-pixel-ratio: 2) {
      /* Force le conteneur principal à ne pas déborder */
  #quiz {
    overflow-x: hidden;
    width: 100%;
    box-sizing: border-box;
  }
.level-hiraganas {
  width: 100%;
  padding: 0;
  margin: 0;
  box-sizing: border-box;
}

.hiraganas-grid {
  width: 95%;              /* 95% de la largeur de l’écran */
  margin: 0 auto;          /* centre la grille */
  display: flex;
  flex-wrap: wrap;         /* permet le retour à la ligne si besoin */
  justify-content: center; /* centre les cartes dans la grille */
  gap: 6px;
  box-sizing: border-box;
}

.hiragana-card {
  flex: 1 1 calc((100% - 24px) / 5); 
  /* 5 colonnes avec gestion des 4 gaps de 10px = 40px */
  
  min-width: 0;
  height: 80px;
  text-align: center;
  transition: all 0.3s ease;
  position: relative;
  padding: 8px 2px;
  background: #FFFFFF;
  border-radius: 6px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2),
              0 1px 2px rgba(0, 0, 0, 0.1);
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  box-sizing: border-box;
}

  .hiragana-char {
    font-size: 1.4em;
    margin-bottom: 0;
    line-height: 1.2;
    word-wrap: break-word;
    overflow-wrap: break-word;
    flex-grow: 1; /* Prend l'espace disponible */
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .stars-container {
    display: flex;
    justify-content: center; /* Centre les étoiles */
    gap: 1px;
    width: 100%;
    padding: 0;
    margin-top: auto; /* Pousse vers le bas */
  }

  .star {
    width: 10px; /* Taille naturelle conservée */
    height: 10px; /* Proportions 1:1 maintenues */
    flex-shrink: 0;
  }
}
    
  /* LES CARTES MODE APPRENDRE - TABLETTES  */ 
    @media (min-width: 600px) and (max-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) {
        /* Force le conteneur principal à ne pas déborder */
  #quiz {
    overflow-x: hidden;
    width: 100%;
    box-sizing: border-box;
  }
  .level-hiraganas {
  width: 100%;
  padding: 0;
  margin: 0;
  box-sizing: border-box;
}

.hiraganas-grid {
  width: 95%;              /* 95% de la largeur de l’écran */
  margin: 0 auto;          /* centre la grille */
  display: flex;
  flex-wrap: wrap;         /* permet le retour à la ligne si besoin */
  justify-content: center; /* centre les cartes dans la grille */
  gap: 10px;
  box-sizing: border-box;
}

.hiragana-card {
  flex: 1 1 calc((100% - 40px) / 5); 
  /* 5 colonnes avec gestion des 4 gaps de 10px = 40px */
  
  min-width: 0;
  height: 120px;
  text-align: center;
  transition: all 0.3s ease;
  position: relative;
  padding: 8px 2px;
  background: #FFFFFF;
  border-radius: 6px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2),
              0 1px 2px rgba(0, 0, 0, 0.1);
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  box-sizing: border-box;
}

  .hiragana-char {
    font-size: 2.8em;
    margin-bottom: 0;
    line-height: 1.2;
    word-wrap: break-word;
    overflow-wrap: break-word;
    flex-grow: 1; /* Prend l'espace disponible */
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .stars-container {
    display: flex;
    justify-content: center; /* Centre les étoiles */
    gap: 4px;
    width: 100%;
    padding: 0;
    margin-top: auto; /* Pousse vers le bas */
  }

  .star {
    width: 16px; /* Taille naturelle conservée */
    height: 16px; /* Proportions 1:1 maintenues */
    flex-shrink: 0;
  }
}
/* ITEM QUESTION MODE APPRENDRE   - DESKTOP    */
    .quiz-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      min-height: 0;
      padding-bottom: 2em;
    }

    .question {
      font-size: 4em;
      font-weight: bold;
      margin: 0.5em 0;
      height: 1.2em;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #8B6F47;
      text-shadow: 1px 1px 2px rgba(139, 111, 71, 0.4);
      margin-bottom: 53px;
    }

    .answers {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.8em;
      margin-bottom: 1em;
    }
    .sakura {
      width: 12px;
      height: 12px;
    }

 /* ITEM QUESTION MODE APPRENDRE -  SMARTPHONE    */
    @media (max-width: 480px) and (-webkit-min-device-pixel-ratio: 2) {
      .quiz-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        min-height: 0;
        padding-bottom: 2em;
      }

      .question {
        font-size: 3em;
        font-weight: bold;
        margin: 0.5em 0;
        height: 1.2em;
        display: flex;
        align-items: center;
        justify-content: center;
        text-shadow: 1px 1px 2px rgba(139, 111, 71, 0.4);
      }

  .answers {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
    justify-content: center; /* centre le grid */
    gap: 0.8em;
    margin-bottom: 1em;
    width: 100%;
    box-sizing: border-box;
    padding: 0 1em;
  }

      .sakura {
        width: 10px;
        height: 10px;
      }
    }   
/* ITEM QUESTION MODE APPRENDRE -  TABLETTE    */
    @media (min-width: 600px) and (max-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) {
      .quiz-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        min-height: 0;
        padding-bottom: 0.5em;
      }

      .question {
        font-size: 3.5em;
        font-weight: bold;
        margin: 0.5em 0;
        height: 1.2em;
        display: flex;
        align-items: center;
        justify-content: center;
        text-shadow: 1px 1px 2px rgba(139, 111, 71, 0.4);
      }

  .answers {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    justify-content: center; /* centre le grid */
    gap: 0.8em;
    margin-bottom: 1em;
    width: 100%;
    box-sizing: border-box;
    padding: 0 1em;
  }

      .sakura {
        width: 10px;
        height: 10px;
      }
    }
/*  BOUTONS REPONSES MODE APPRENDRE- DESKTOP    */
    .arcade-button {
      position: relative;
      background: #F5E8C7;
      background-image: url('https://www.transparenttextures.com/patterns/light-wood.png');
      border: 2px solid transparent;
      border-radius: 10px;
      padding: 0.8em 1.5em;
      color: #8B6F47;
      font-size: 1.4em;
      line-height: 0.6;
      white-space: normal;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2), inset 0 2px 2px rgba(255, 255, 255, 0.3);
      transition: all 0.15s ease;
      text-shadow: 0 0 8px rgba(139, 111, 71, 0.5);
      overflow: hidden;
      min-width: 120px;
      text-align: center;
    }

    .arcade-button::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 50%;
      background: linear-gradient(to bottom, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0));
      border-top-left-radius: 10px;
      border-top-right-radius: 10px;
      pointer-events: none;
    }

    .arcade-button:hover {
      transform: translateY(-2px) scale(1.02);
      box-shadow: 0 6px 10px rgba(0, 0, 0, 0.25), inset 0 2px 2px rgba(255, 255, 255, 0.3);
   /*   border-color: #7A5C3A; */
    }

    .arcade-button:active {
      transform: translateY(2px) scale(0.98);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2), inset 0 1px 1px rgba(255, 255, 255, 0.3);
    }

    .arcade-button:disabled {
      cursor: not-allowed;
      opacity: 0.8;
    }

    .arcade-button.clicked {
      opacity: 1 !important;
      cursor: default;
    }

    .arcade-button.clicked-glow {
      text-shadow: 0 0 12px #A8D5BA, 0 0 4px #A8D5BA;
      animation: glowPulse 1s ease-in-out infinite;
    }

    .arcade-button.correct {
      background: rgba(168, 213, 186, 0.5) !important;
      color: #8B6F47;
      border-color: #A8D5BA;
      background-image: none !important;
      animation: correctGlow 0.6s ease-in-out;
      opacity: 1 !important;
    }

    .arcade-button.correct::before {
      display: none;
    }

    .arcade-button.incorrect {
      background: rgba(253, 193, 197, 0.5) !important;
      color: #8B6F47;
      border-color: #FDC1C5;
      background-image: none !important;
      animation: incorrectShake 0.6s ease-in-out;
      opacity: 1 !important;
    }

    .arcade-button.incorrect::before {
      display: none;
    }

    @keyframes glowPulse {
      0%, 100% { text-shadow: 0 0 12px #A8D5BA, 0 0 4px #A8D5BA; }
      50% { text-shadow: 0 0 18px #A8D5BA, 0 0 6px #A8D5BA; }
    }

    @keyframes correctGlow {
      0% { box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2), inset 0 2px 2px rgba(255, 255, 255, 0.3); }
      50% { box-shadow: 0 6px 10px rgba(0, 0, 0, 0.25), 0 0 20px rgba(168, 213, 186, 0.6); }
      100% { box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2), inset 0 2px 2px rgba(255, 255, 255, 0.3); }
    }

    @keyframes incorrectShake {
      0% { transform: translateX(0); }
      10% { transform: translateX(-8px); }
      20% { transform: translateX(8px); }
      30% { transform: translateX(-6px); }
      40% { transform: translateX(6px); }
      50% { transform: translateX(-4px); }
      60% { transform: translateX(4px); }
      70% { transform: translateX(-2px); }
      80% { transform: translateX(2px); }
      90% { transform: translateX(-1px); }
      100% { transform: translateX(0); }
    }

/*  BOUTONS REPONSES MODE APPRENDRE- SMARTPHONES   */
@media (max-width: 480px) and (-webkit-min-device-pixel-ratio: 2) {
  button, a, input, textarea {
    -webkit-tap-highlight-color: transparent;
  }
.answers {
    display: grid;
    grid-template-columns: repeat(4, 1fr); /* 4 colonnes fixes */
    gap: 3px; /* espace de 2px entre chaque bouton */
    width: 98%;
    padding: 0;
    margin: 0 auto 0.6em auto;
    box-sizing: border-box;
  }

  .answers .arcade-button {
    flex: 1;
    min-width: 0;
    width: 100%;
    
    /* Dimensions et apparence */
    font-size: 1.30em;
    aspect-ratio: 1 / 0.6; /* conserve la forme rectangulaire */
    box-sizing: border-box;
    padding: 6px 4px;
    border-radius: 3px;
    border: 1px solid transparent;
    /* Alignement */
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
 
}
}
    
/*  BOUTONS REPONSES MODE APPRENDRE- TABLETTES  */
    @media (min-width: 600px) and (max-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) {
      button, a, input, textarea {
    -webkit-tap-highlight-color: transparent;
  }
.answers {
    display: grid;
    grid-template-columns: repeat(4, 1fr); /* 4 colonnes fixes */
    gap: 6px; /* espace de 2px entre chaque bouton */
    width: 95%;
    padding: 0;
    margin: 0 auto 0.5em auto;
    box-sizing: border-box;
  }

  .answers .arcade-button {
    flex: 1;
    min-width: 0;
    width: 98%;
    
    /* Dimensions et apparence */
    font-size: 2.5em;
    aspect-ratio: 1 / 0.5; /* conserve la forme rectangulaire */
    box-sizing: border-box;
    padding: 8px 4px;
    border-radius: 8px;
    border: 4px solid transparent;
    /* Alignement */
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
 
}
    }
/*  AFFICHAGE REPONSE MODE APPRENDRE- DESKTOP   */
    .result {
      animation: fadeIn 0.4s ease-in;
      font-size: 1.3em;
      line-height: 1.4em;
      margin: 0.5em 0 0.2em 0;
      min-height: 4.5em;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      color: #8B6F47;
    }

    .result-line.highlight {
      color: #8B6F47;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    #continueBtn {
      visibility: hidden;
      margin: 0.5em auto;
      display: block;
      width: fit-content;
    }

    #boutonInstaller {
      margin: 0.5em auto;
      height: 3em;
      display: none;
    }
/*  AFFICHAGE REPONSE MODE APPRENDRE- SMARTPHONE   */
    @media (max-width: 480px) and (-webkit-min-device-pixel-ratio: 2) {
      .result {
        margin-top: 1em;
        text-align: center;
        word-break: break-word;
        white-space: normal;
        display: block;
        min-height: auto;
      }

      .result > * {
        width: 100%;
      }

      .result-line {
        font-size: 1.2em;
        width: 100%;
        text-align: center;
      }

  
      .result-line.highlight {
        line-height: 1.0;
        margin-top: 0.5em;
         font-size: 1.0em;
      }

      #continueBtn {
        margin-top: 1em;
        margin-bottom: 1em;
        height: 3em;
        border-radius: 8px;
        border: 4px solid transparent;
      }

      #boutonInstaller {
        margin-top: 1em;
        margin-bottom: 1em;
        height: 3em;
      }
    }
/*  AFFICHAGE REPONSE MODE APPRENDRE- TABLETTE  */
    @media (min-width: 600px) and (max-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) {
      .result {
        margin-top: 1em;
        text-align: center;
        word-break: break-word;
        white-space: normal;
        display: block;
        min-height: auto;
      }

      .result > * {
        width: 100%;
      }

      .result-line {
        font-size: 1.8em;
        width: 100%;
        text-align: center;
      }

  
      .result-line.highlight {
        line-height: 1.8;
        margin-top: 0.4em;
        font-size: 1.8em;
      }

      #continueBtn {
        font-size: 1.8em;
        margin-top: 1em;
        margin-bottom: 0.1em;
        height: 2.4em;
        border: 4px solid transparent;
      }

      #boutonInstaller {
        margin-top: 1em;
        margin-bottom: 1em;
        height: 3em;
      }
    }

 /* ANIMATIONS - DESKTOP */    
    @keyframes confettiFall {
      0% { transform: translateY(0); }
      100% { transform: translateY(110vh) rotate(720deg); }
    }

    body.shake {
      animation: screenShake 0.4s ease-in-out;
    }

    @keyframes screenShake {
      0% { transform: translate(0px, 0px); }
      25% { transform: translate(4px, -4px); }
      50% { transform: translate(-4px, 4px); }
      75% { transform: translate(4px, 4px); }
      100% { transform: translate(0px, 0px); }
    }

  
/* BOUTON  HAMBURGER - Style carte hiragana */
.hamburger {
  position: fixed;
  background: #FFFFFF; /* Fond blanc comme les cartes */
  border: none; /* Supprime la bordure */
  border-radius: 8px; /* Bords arrondis comme les cartes */
  color: #8B6F47;
  padding: 12px;
  cursor: pointer;
  z-index: 1000;
  /* Ombre identique aux cartes hiragana */
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25), 0 3px 6px rgba(0, 0, 0, 0.15);
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}
#welcome.active ~ * .hamburger,
#-section.active ~ * .hamburger {
  display: none;
}
/* Icône hamburger avec 3 barres */
.hamburger-icon {
  display: flex;
  flex-direction: column;
  gap: 4px;
  width: 20px;
  height: 16px;
}

.hamburger-bar {
  width: 100%;
  height: 3px;
  background: rgba(139, 111, 71, 0.3); /* Marron voilé/discret */
  border-radius: 2px;
  transition: all 0.3s ease;
}

/* Desktop - hover révèle les barres */
@media (min-width: 769px) {
  .hamburger {
    top: 20px;
    left: 20px;
    width: 44px;
    height: 44px;
  }

  .hamburger:hover .hamburger-bar {
    background: #8B6F47; /* Marron normal au survol */
  }

  .hamburger:hover {
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3), 0 4px 8px rgba(0, 0, 0, 0.2);
    transform: translateY(-1px);
  }
}

/* BOUTON  HAMBURGER SMARTPHONES */
@media (max-width: 480px) and (-webkit-min-device-pixel-ratio: 2) {
  .hamburger {
    position: fixed !important;
    bottom: 10px !important;
    right: 10px !important;
    left: auto !important;
    top: auto !important;
    width: 40px !important; /* 2x plus gros */
    height: 40px !important;
    padding: 10px;
    display: flex;
    box-sizing: border-box;
  }

  .hamburger-icon {
    width: 30px;
    height: 22px;
    gap: 6px;
  }

  .hamburger-bar {
    height: 4px;
    background: rgba(139, 111, 71, 0.4); /* Légèrement plus visible sur mobile */
  }
}



    
/* BOUTON  HAMBURGER  TABLETTES */
@media (min-width: 600px) and (max-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) {
  .hamburger {
    position: fixed !important;
    bottom: 20px !important;
    right: 20px !important;
    left: auto !important;
    top: auto !important;
    width: 66px !important; /* 2x plus gros */
    height: 66px !important;
    padding: 20px;
    display: flex;
    box-sizing: border-box;
  }

  .hamburger-icon {
    width: 36px;
    height: 28px;
    gap: 6px;
  }

  .hamburger-bar {
    height: 4px;
    background: rgba(139, 111, 71, 0.4); /* Légèrement plus visible sur mobile */
  }
}


/* MENU  DESKTOP  Ajuster la règle générale pour .menu */
    /* ✅ Style menu-message */
#menu-message {
  text-align: center !important;
  font-size: 2.5em !important;
  font-weight: 700 !important;
  color: #8B6F47 !important; /* marron des boutons */
/*  background: #F5E8C7 !important;  fond des boutons */ 
/*  background-image: url('https://www.transparenttextures.com/patterns/light-wood.png') !important  */
  border: none !important; /* supprime le liseret marron */
  padding: 15px !important;
  margin-bottom: 30px !important;
  border-radius: 8px !important;
  line-height: 1.3 !important;
  display: block;
  z-index: 1001;
/*  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25), 0 3px 6px rgba(0, 0, 0, 0.15);  même ombre que les boutons */
  opacity: 0;
  transform: translateY(-10px);
  transition: opacity .45s ease, transform .45s ease;
}
/* quand le menu s’ouvre, on déclenche la transition */
.menu.active #menu-message {
  opacity: 1;
  transform: translateY(0);
}
/* MENU Version responsive SMARTPHONES */
@media (max-width: 480px) and (-webkit-min-device-pixel-ratio: 2) {
  #menu-message {
    font-size: 1.2em !important;
    padding: 10px !important;
    margin-bottom: 100px !important;
    line-height: 1.2 !important;
  }
}                            

/* MENU Version responsive TABLETTES */
@media (min-width: 481px) and (max-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) {
  #menu-message {
    font-size: 2.6em !important;
    padding: 8px !important;
    margin-bottom: 120px !important;
    line-height: 1.2 !important;
  }
}         


    
/* Ajuster la règle générale pour .menu */
   .menu {
      position: fixed;
      top: 0;
      right: 0;
      width: 100%;
      height: 100%;
      background: rgba(248, 241, 233, 0.95); /* Voile blanc cassé */
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
 /*  gap: 15px; */
      transform: translateX(100%);
      transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
      opacity: 0;
      z-index: 999;
    }

    .menu.active {
      transform: translateX(0);
      opacity: 1;
    }

 .menu .arcade-button {
    width: 300px !important; /* Plus large que les 200px actuels */
    height: 80px !important; /* Hauteur fixe pour tous */
    min-height: 80px !important; /* Force la hauteur minimum */
    max-height: 80px !important; /* Limite la hauteur maximum */
    line-height: 80px !important; /* Centre le texte verticalement */
    padding: 0 1.5em !important; /* Padding horizontal seulement */
    font-size: 1.6em !important; /* Taille de police cohérente */
    box-sizing: border-box !important;
  }

.arcade-button.disabled {
  background: #E0E0E0 !important;
  color: #999999 !important;
  cursor: not-allowed !important;
  opacity: 0.6;
  border-color: #CCCCCC !important;
}

.arcade-button.disabled:hover {
  transform: none !important;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2) !important;
}
.options-menu,
.options-sub {
  display: flex;
  flex-direction: column !important;
  align-items: center;
  gap: 15px;
  width: 100%;
}

.options-sub .arcade-button,
.options-menu .arcade-button {
  width: 300px !important;  /* même largeur que ton menu principal */
}

.options-sub .arcade-button:first-child {
  margin-bottom: 20px; /* espace entre ← Retour et le titre */
}

/* Animation d'apparition des sous-rubriques */
.options-sub {
  opacity: 0;
  transform: translateY(10px);
  transition: opacity 0.3s ease, transform 0.3s ease;
}

.options-sub.active {
  opacity: 1;
  transform: translateY(0);
}


    
/* BOUTONS MENUS - VERSION SMARTPHONES*/
    @media (max-width: 480px) and (-webkit-min-device-pixel-ratio: 2) {
      .menu .arcade-button {
    width: 700px !important;
    font-size: 1.4em !important;
    padding: 0.2em 1em !important;
    line-height: 60px !important; /* ? Centre le texte */
    height: 60px !important; /* ? Hauteur fixe pour TOUS */
    max-height: 60px !important; /* ? Remplace l'ancien 2.5em */
    border: 2px solid solid transparent;
        
  }
  
  /* Correction spécifique Chrome */
  @supports (-webkit-appearance: none) {
    .menu .arcade-button {
      width: min(80vw, 700px) !important; /* Plus conservateur */
      height: 60px !important; /* ? Hauteur fixe */
      max-height: 60px !important; /* ? Remplace l'ancien max-height */
      line-height: 60px !important; /* ? Centre le texte verticalement */
      padding: 0.2em 1em !important; /* ? Supprime padding vertical */
      border: 2px solid solid transparent;
      
    }
  }
}

/* BOUTONS MENUS - VERSION TABLETTES*/
@media (min-width: 481px) and (max-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) {
  .menu .arcade-button {
    width: 400px !important;
    font-size: 2.6em !important;
    padding: 0.2em 1em !important;
    line-height: 100px !important; /* ? Centre le texte */
    height: 100px !important; /* ? Hauteur fixe pour TOUS */
    max-height: 100px !important; /* ? Remplace l'ancien 2.5em */
    border: 5px solid transparent;
   
  }
  
  /* Correction spécifique Chrome */
  @supports (-webkit-appearance: none) {
    .menu .arcade-button {
      width: min(80vw, 400px) !important; /* Plus conservateur */
      height: 100px !important; /* ? Hauteur fixe */
      max-height: 100px !important; /* ? Remplace l'ancien max-height */
      line-height: 50px !important; /* ? Centre le texte verticalement */
      padding: 0.2em 1em !important; /* ? Supprime padding vertical */
      border: 5px solid transparent;
      
    }
  }
}
    .section {
      display: none;
    }

    .section.active {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }



/* MODE REVISIONS  - DESKTOP */
#revision-question {
  font-size: 1.5em;
  margin-bottom: 10px;
  color: #8B6F47;
  text-shadow: 1px 1px 2px rgba(139, 111, 71, 0.4);
}

.char-correct {
  background-color: #d4edda;
  border-radius: 5px;
  padding: 2px 4px;
}

.char-incorrect {
  background-color: #f8e7e6;
  border-radius: 5px;
  padding: 2px 4px;
}

.pulsing {
  animation: revisionPulse 0.8s infinite;
}

@keyframes revisionPulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); }
}

#revision-input-display {
  font-size: 2em;
  margin: 0 auto 10px auto; /* Centre horizontalement et garde 10px en bas */
  height: 65px; /* Hauteur fixe */
  padding: 10px;
  border: 2px solid transparent;
  border-radius: 8px;
  width: 300px;
  text-align: center;
  background: #FFFFFF;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  display: flex; /* Utilise flexbox pour centrer le contenu verticalement */
  align-items: center; /* Centre verticalement le texte */
  justify-content: center; /* Centre horizontalement le texte */
  overflow: hidden; /* Empêche le contenu de déborder */
}
    
 .revision-keyboard {
      display: grid;
      grid-template-columns: repeat(5, 60px);
      gap: 8px;
      justify-content: center;
      margin-bottom: 10px;
      margin-top: 0;
 }

       .revision-key {
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid transparent;
      border-radius: 10px;
      cursor: pointer;
      font-family: 'Poppins', sans-serif;
      font-weight: 500;
      font-size: 1.2em;
      position: relative;
      overflow: hidden;
      touch-action: manipulation; /* Améliore la réactivité tactile */
      background: linear-gradient(145deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.1));
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1), 0 4px 8px rgba(0, 0, 0, 0.15);
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
    }

    /* Animation d'enfoncement et retour */
    .revision-key:active,
    .revision-key.active {
      animation: pressAndRelease 0.3s ease forwards;
    }

    /* Effet de scintillement au clic */
    .revision-key::after {
      content: '';
      position: absolute;
      width: 100px;
      height: 100px;
      background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.5), transparent);
      transform: translateX(-100%) rotate(45deg);
      transition: transform 0.3s ease;
      pointer-events: none;
    }

    .revision-key:active::after,
    .revision-key.active::after {
      transform: translateX(100%) rotate(45deg);
    }

    /* Animation pour l'enfoncement et le retour */
    @keyframes pressAndRelease {
      0% {
        transform: translateY(0);
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1), 0 4px 8px rgba(0, 0, 0, 0.15);
      }
      50% {
        transform: translateY(3px);
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2), 0 1px 2px rgba(0, 0, 0, 0.1);
      }
      100% {
        transform: translateY(0);
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1), 0 4px 8px rgba(0, 0, 0, 0.15);
      }
    }

    /* Couleurs des touches et des lettres */
    .revision-key:nth-child(-n+5) {
      background-color: #d1e7ff; /* Bleu clair */
      color: #1a3c66; /* Bleu foncé complémentaire */
    }

    .revision-key:nth-child(6),
    .revision-key:nth-child(7) {
      background-color: #fff3cd; /* Jaune pâle */
      color: #664d1a; /* Marron doré complémentaire */
    }

    .revision-key:nth-child(8) {
      background-color: #d1e7ff; /* Bleu clair */
      color: #1a3c66; /* Bleu foncé complémentaire */
    }

    .revision-key:nth-child(9),
    .revision-key:nth-child(10) {
      background-color: #f8e7e6; /* Rose pâle */
      color: #661a1a; /* Rouge foncé complémentaire */
    }

    .revision-key:nth-child(n+11):nth-child(-n+15) {
      background-color: #d4edda; /* Vert pâle */
      color: #1a6642; /* Vert foncé complémentaire */
    }

    .revision-key:nth-child(n+16):nth-child(-n+20) {
      background-color: #ffe4b5; /* Orange pâle */
      color: #663b1a; /* Marron orangé complémentaire */
    }

    .revision-key:nth-child(n+21):nth-child(-n+24) {
      background-color: #dee2e6; /* Gris clair */
      color: #3c3f41; /* Gris foncé complémentaire */
    }

    .revision-key:nth-child(25) {
      background-color: #ffffff; /* Blanc */
      color: #333333; /* Gris très foncé pour contraste */
    }
#revision-message {
  margin-top: 10px;
  margin-bottom: 10px;
  font-size: 1.8em;
  color: #8B6F47;
  min-height: 1.5em;
}

/* MODE REVISIONS  - SMARTPHONES */
@media (max-width: 480px) and (-webkit-min-device-pixel-ratio: 2) {
  #revision-question {
   
    font-size: 1em;
    margin-top: 15px;  /*Pousse la carte plus bas */
  }
  
#revision-input-display {
    height: 23px; /* Hauteur fixe */   
    font-size: 1.8em;
    width: 80%;
    padding: 05px;
    position: fixed;
    bottom: calc(85vw + 83px); /*  au-dessus du clavier */
    left: 50%;
    transform: translateX(-50%);
  /*   z-index: 1000; S'assurer que l'élément est au-dessus */
  }
  
 #revision-message {
    position: fixed;
    bottom: calc(85vw + 130px); /* Juste au-dessus de l'input */
    left: 50%;
    transform: translateX(-50%);
    width: 80%;
    text-align: center;
    line-height: 1.0;
    font-size: 1.0em;
    margin-bottom: 0; /* Retire le margin */
    font-weight: bold;
  }
   
   .revision-keyboard {
    
    gap: 7px;
    grid-template-columns: repeat(5, 1fr);
    width: 85%;
    padding: 0 5px;
    position: fixed;
    bottom: calc(60px - 5vw); /* laisse la place pour bouton hamburgeur 40px + 2x 10 px car keyboard 95% */ 
    left: 50%;
    transform: translateX(-50%);
  }
  
  .revision-key {
    width: 100%;
    height: auto;
    aspect-ratio: 1;
    min-width: 50px;
    font-size: clamp(2.5em, 8vw, 5em);
    font-weight: bold;
    line-height: 1;
  }
}

/* MODE REVISIONS  - TABLETTES */
 @media (min-width: 481px) and (max-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) {
  #revision-question {
   
    font-size: 1em;
    margin-top: 15px;  /*Pousse la carte plus bas */
  }
  
#revision-input-display {
    height: 40px; /* Hauteur fixe */   
    font-size: 1.8em;
    width: 60%;
    padding: 05px;
    position: fixed;
    bottom: calc(60vw + 120px); /*  au-dessus du clavier */
    left: 50%;
    transform: translateX(-50%);
  /*   z-index: 1000; S'assurer que l'élément est au-dessus */
  }
  
  #revision-message {
    position: fixed;
    bottom: calc(60vw + 185px); /* Juste au-dessus de l'input */
    left: 50%;
    transform: translateX(-50%);
    width: 60%;
    text-align: center;
    line-height: 1.0;
    font-size: 1.5em;
    margin-bottom: 0;
    font-weight: bold;
  }
   
   .revision-keyboard {
    
    gap: 7px;
    grid-template-columns: repeat(5, 1fr);
    width: 60%;
    padding: 0 5px;
    position: fixed;
    bottom: calc(120px - 5vw); /* laisse la place pour bouton hamburgeur 40px + 2x 10 px car keyboard 95% */ 
    left: 50%;
    transform: translateX(-50%);
  }
  
  .revision-key {
    width: 100%;
    height: auto;
    aspect-ratio: 1;
    min-width: 50px;
    font-size: clamp(2.5em, 8vw, 5em);
    font-weight: bold;
    line-height: 1;
  }
}





    
/* ? NOUVEAUX STYLES POUR LES CARTES  MODES REVISION- DESKTOP  */
.char-card {
  display: inline-flex;
  padding: 15px;
  margin: 5px;
  border-radius: 8px; /* Même rayon que les cartes hiragana */
  min-width: 60px;
  min-height: 60px;
  text-align: center;
  font-size: 2.2em;
  font-weight: bold;
  color: #8B6F47;
  text-shadow: 0 0 3px rgba(139, 111, 71, 0.3);
  
  /* ? MODE REVISION MÊME STYLE QUE LES CARTES HIRAGANA -  DESKTOP*/
  background: #FFFFFF;
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25), 0 3px 6px rgba(0, 0, 0, 0.15);
  transition: all 0.4s ease; /* Transition plus fluide */
  
  align-items: center;
  justify-content: center;
}

/* ?? GRADATIONS ULTRA-SUBTILES (couleurs beaucoup plus douces) */
.char-correct-1 { 
  background: #f9fdf9; /* Vert ultra-discret, à peine visible */
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25), 0 3px 6px rgba(0, 0, 0, 0.15), inset 0 0 2px rgba(139, 195, 74, 0.1);
}
.char-correct-2 { 
  background: #f5faf5; /* Vert très pâle */
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25), 0 3px 6px rgba(0, 0, 0, 0.15), inset 0 0 3px rgba(139, 195, 74, 0.15);
}
.char-correct-3 { 
  background: #f0f8f0; /* Vert léger */
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25), 0 3px 6px rgba(0, 0, 0, 0.15), inset 0 0 4px rgba(139, 195, 74, 0.2);
}
.char-correct-4 { 
  background: #ebf5eb; /* Vert final très soft */
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25), 0 3px 6px rgba(0, 0, 0, 0.15), inset 0 0 5px rgba(139, 195, 74, 0.25);
}

/* ?? GRADATIONS ROSES SAKURA ULTRA-SUBTILES */
.char-incorrect-1 { 
  background: #fdfafa; /* Rose ultra-discret */
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25), 0 3px 6px rgba(0, 0, 0, 0.15), inset 0 0 2px rgba(253, 193, 197, 0.1);
}
.char-incorrect-2 { 
  background: #fcf5f5; /* Rose très pâle */
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25), 0 3px 6px rgba(0, 0, 0, 0.15), inset 0 0 3px rgba(253, 193, 197, 0.15);
}
.char-incorrect-3 { 
  background: #faf0f1; /* Rose léger */
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25), 0 3px 6px rgba(0, 0, 0, 0.15), inset 0 0 4px rgba(253, 193, 197, 0.2);
}
.char-incorrect-4 { 
  background: #f8ebec; /* Rose final très soft */
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25), 0 3px 6px rgba(0, 0, 0, 0.15), inset 0 0 5px rgba(253, 193, 197, 0.25);
}

/* ?? PULSATION AMÉLIORÉE - Plus fluide et prononcée */
.pulsing {
  animation: pulse-revision 1.8s infinite ease-in-out;
}

@keyframes pulse-revision {
  0% { 
    transform: scale(1); 
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25), 0 3px 6px rgba(0, 0, 0, 0.15);
  }
  50% { 
    transform: scale(1.08);
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3), 0 4px 8px rgba(0, 0, 0, 0.2), 0 0 8px rgba(139, 111, 71, 0.3);
  }
  100% { 
    transform: scale(1); 
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25), 0 3px 6px rgba(0, 0, 0, 0.15);
  }
}
/* Style de base pour le titre mode révision*/
#mode2 .title {
   margin: 0.5em 0;
      font-size: 1.8em;
      text-align: center;
      color: #8B6F47;
      text-shadow: 0 1px 2px rgba(139, 111, 71, 0.3);
}

/* MODE REVISIONS  - CARTES SMARTHONES */
@media (max-width: 480px) and (-webkit-min-device-pixel-ratio: 2) {
.char-card {
  
  display: inline-flex;
  padding: 5px;
  margin: 5px;
  border-radius: 8px; /* Même rayon que les cartes hiragana */
  min-width: 60px;
  min-height: 60px;
  text-align: center;
  font-size: 2.2em;
  font-weight: bold;
  color: #8B6F47;
  text-shadow: 0 0 3px rgba(139, 111, 71, 0.3);


   } 
  }

 /* MODE REVISIONS  - CARTES TABLETTES */
@media (min-width: 481px) and (max-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) {
.char-card {
  
  display: inline-flex;
  padding: 3px;
  margin: 3px;
  border-radius: 8px; /* Même rayon que les cartes hiragana */
  min-width: 100px;
  min-height: 100px;
  text-align: center;
  font-size: 4em;
  font-weight: bold;
  color: #8B6F47;
  text-shadow: 0 0 3px rgba(139, 111, 71, 0.3);


   } 
  }   
    
  
/* TITRE MODE REVISIONS - MOBILES  */
@media screen and (max-width: 768px), screen and (-webkit-min-device-pixel-ratio: 2) {
  #mode2 .title {
      margin: 0.1em 0;
      font-size: 1em;
      text-align: center;
      color: #8B6F47;
      text-shadow: 0 1px 2px rgba(139, 111, 71, 0.3);
  }
}
<!-- ========================================
     STYLES À AJOUTER DANS LA SECTION <style>
     ======================================== -->

/* Section Mon compte - Desktop */
.account-section {
  padding: 2em;
  max-width: 500px;
  margin: 0 auto;
  text-align: center;
}

.pseudo-display {
  font-size: 2.5em;
  font-weight: bold;
  color: #8B6F47;
  margin: 1em 0;
  padding: 0.5em;
  background: #FFFFFF;
  border-radius: 12px;
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25), 0 3px 6px rgba(0, 0, 0, 0.15);
  min-height: 1.5em;
  display: flex;
  align-items: center;
  justify-content: center;
}

.pin-input-container {
  margin: 2em 0;
}

.pin-input {
  font-size: 2em;
  padding: 0.5em;
  width: 200px;
  text-align: center;
  border: 2px solid #8B6F47;
  border-radius: 8px;
  background: #FFFFFF;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

.pin-input:focus {
  outline: none;
  border-color: #A8D5BA;
  box-shadow: 0 6px 12px rgba(168, 213, 186, 0.4);
}

.pin-label {
  font-size: 1.2em;
  color: #8B6F47;
  margin-bottom: 0.5em;
  display: block;
}

.account-info {
  margin: 2em 0;
  padding: 1em;
  background: rgba(255, 255, 255, 0.5);
  border-radius: 8px;
}

.account-info-line {
  font-size: 1.2em;
  color: #8B6F47;
  margin: 0.5em 0;
}

.button-group {
  display: flex;
  flex-direction: column;
  gap: 1em;
  margin-top: 2em;
}

.error-message {
  color: #dc3545;
  font-size: 1.1em;
  margin: 1em 0;
  padding: 0.5em;
  background: rgba(220, 53, 69, 0.1);
  border-radius: 8px;
}

.success-message {
  color: #28a745;
  font-size: 1.1em;
  margin: 1em 0;
  padding: 0.5em;
  background: rgba(40, 167, 69, 0.1);
  border-radius: 8px;
}

/* Mobile */
@media (max-width: 480px) and (-webkit-min-device-pixel-ratio: 2) {
  .account-section {
    padding: 1em;
  }

  .pseudo-display {
    font-size: 1.8em;
    padding: 0.4em;
  }

  .pin-input {
    font-size: 1.5em;
    width: 150px;
  }

  .pin-label {
    font-size: 1em;
  }

  .account-info-line {
    font-size: 1em;
  }
}

/* Tablettes */
@media (min-width: 481px) and (max-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) {
  .pseudo-display {
    font-size: 2.2em;
  }

  .pin-input {
    font-size: 1.8em;
    width: 180px;
  }
}
  </style>
</head>
<body>
  <!-- Bouton hamburger  <button class="hamburger" onclick="toggleMenu()">☰</button>  -->
<!-- Bouton hamburger -->
<button class="hamburger" onclick="toggleMenu()">

  <div class="hamburger-icon">
    <div class="hamburger-bar"></div>
    <div class="hamburger-bar"></div>
    <div class="hamburger-bar"></div>
  </div>
</button>
<!-- Menu -->
<nav class="menu" id="menu">
  <div id="menu-message" class="menu-message"></div>
  <button class="arcade-button" onclick="showSection('quiz')" data-i18n="menu_learn">Apprendre</button>
  <button class="arcade-button" id="revision-button" onclick="showSection('mode2')" data-i18n="menu_revision">Mode révisions</button>
  <button class="arcade-button" onclick="showSection('options')" data-i18n="menu_options">Options</button>
  <button class="arcade-button" onclick="toggleMenu()" data-i18n="menu_close">Fermer</button>
  <button class="arcade-button" onclick="showSection('account')" data-i18n="account_title">Options</button>
</nav>

<!-- Section Page d'accueil -->
<div id="welcome" class="section active">
  <div class="panda-logo" onclick="">🐼</div>
  <h1 class="welcome-title" data-i18n="welcome_title">🎌🌸 Kanas-Zen-Garden 🌸🎌</h1>
  <p class="welcome-subtitle" data-i18n="welcome_subtitle">Apprenez à Lire le Japonais</p>
  <div class="loading-dots" id="loadingText">(Chargement... )</div>

<!-- ✅ NOUVEAU : Barre de progression -->
<div id="loading-progress-container" style="display: none; width: 80%; max-width: 400px; margin: 20px auto;">
  <div style="background: rgba(139, 111, 71, 0.2); border-radius: 10px; overflow: hidden; height: 20px;">
    <div id="loading-progress-fill" style="background: linear-gradient(90deg, #A8D5BA, #8B6F47); height: 100%; width: 0%; transition: width 0.3s ease;"></div>
  </div>
  <div id="loading-message" style="text-align: center; margin-top: 10px; font-size: 1em; color: #8B6F47;"></div>
</div>
</div>
  <!-- Section Menu -->


<!-- Section Quiz -->
<div id="quiz" class="section">
  <h1 data-i18n="quiz_title">🎌⛩️ Apprenez les Kanas ⛩️🎌</h1>
  <div id="progressBarContainer"></div>
  <div class="level" id="levelDisplay">Niveau actuel : 1</div>
    <div class="level-hiraganas">
      <div class="hiraganas-grid" id="hiraganaCards"></div>
    </div>
    <div class="quiz-container">
      <div class="question" id="question">load...</div>
      <div>
        <div class="answers" id="choices1"></div>
        <div class="answers" id="choices2"></div>
      </div>
      <div>
        <div class="result" id="result"></div>
  <button class="arcade-button" id="continueBtn" onclick="nextQuestion()" data-i18n="quiz_continue">🌱 OK... j'ai capté 🌱</button>
  <button class="arcade-button" id="boutonInstaller" data-i18n="quiz_install">Ajouter à l'écran d'accueil</button>
</div>
    </div>
  </div>

  <!-- Section Mode Katakana -->
<!-- Section Mode révisions -->
<div id="mode2" class="section">
  <h2 data-i18n="revision_title">🎌⛩️ Réviser les Kanas ⛩️🎌</h2>
<div id="unlock-progress-container" class="unlock-progress-container" style="display: none;">
  <div class="unlock-progress-bar">
    <div class="unlock-progress-fill" id="unlock-progress-fill"></div>
  </div>
</div>

  <div id="revision-question"></div>
  
  <div id="revision-input-display"></div>
    <div class="revision-keyboard">
    <div class="revision-key">a</div>
    <div class="revision-key">i</div>
    <div class="revision-key">u</div>
    <div class="revision-key">e</div>
    <div class="revision-key">o</div>
    <div class="revision-key">k</div>
    <div class="revision-key">g</div>
    <div class="revision-key">y</div>
    <div class="revision-key">h</div>
    <div class="revision-key">f</div>
    <div class="revision-key">t</div>
    <div class="revision-key">ts</div>
    <div class="revision-key">d</div>
    <div class="revision-key">b</div>
    <div class="revision-key">p</div>
    <div class="revision-key">s</div>
    <div class="revision-key">sh</div>
    <div class="revision-key">z</div>
    <div class="revision-key">j</div>
    <div class="revision-key">ch</div>
    <div class="revision-key">m</div>
    <div class="revision-key">n</div>
    <div class="revision-key">r</div>
    <div class="revision-key">w</div>
    <div class="revision-key" id="revision-back">←</div>
  </div>
 <div id="revision-message"></div> 
</div>

<!-- Section Options -->
<div id="options" class="section">
  <h1 data-i18n="options_title">Options</h1>
  <div class="options-menu">
    <button class="arcade-button" onclick="showSubOptions('difficulty')" data-i18n="options_difficulty">Difficulté</button>
    <button class="arcade-button" onclick="showSubOptions('sound')" data-i18n="options_sound">Son</button>
    <button class="arcade-button" onclick="showSubOptions('language')" data-i18n="options_language">Langue</button>
  </div>

  <!-- Sous-rubrique Difficulté -->
  <div id="options-difficulty" class="options-sub hidden">
    <button class="arcade-button" onclick="backToOptions()" data-i18n="options_back">← Retour</button>
    <h2 data-i18n="options_difficulty">Difficulté</h2>
    <button class="arcade-button" onclick="setDifficulty(6)" data-i18n="difficulty_easy">Facile (6)</button>
    <button class="arcade-button" onclick="setDifficulty(8)" data-i18n="difficulty_medium">Moyen (8)</button>
    <button class="arcade-button" onclick="setDifficulty(10)" data-i18n="difficulty_hard">Hard (10)</button>
  </div>

  <!-- Sous-rubrique Son -->
  <div id="options-sound" class="options-sub hidden">
    <button class="arcade-button" onclick="backToOptions()" data-i18n="options_back">← Retour</button>
    <h2 data-i18n="options_sound">Son</h2>
    <p>🔊 Ici tu pourras ajouter des réglages (volume, mute, etc.)</p>
  </div>
<!-- Sous-rubrique Langue -->
<div id="options-language" class="options-sub hidden">
  <button class="arcade-button" onclick="backToOptions()"><span data-i18n="options_back">← Retour</span></button>
  <h2 data-i18n="options_language">Langue</h2>
  <button class="arcade-button" onclick="setLanguage('fr')">🇫🇷 Français</button>
  <button class="arcade-button" onclick="setLanguage('en')">🇬🇧 English</button>
  <button class="arcade-button" onclick="setLanguage('es')">🇪🇸 Español</button>
</div>
</div>
<!-- ========================================
     HTML À AJOUTER APRÈS LA SECTION OPTIONS
     ======================================== -->

<!-- Section Mon compte -->
<div id="account" class="section">
  <h1 data-i18n="account_title">Mon compte</h1>
  
  <div class="account-section">
    <div class="account-info">
      <div class="account-info-line">
        🐼 <strong>Pseudo :</strong> <span id="account-pseudo">-</span>
      </div>
      <div class="account-info-line">
        📊 <strong>Niveau :</strong> <span id="account-level">-</span>
      </div>
    </div>

    <div class="button-group">
      <button class="arcade-button" onclick="showChangeDevice()" data-i18n="account_change_device">
        📱 Changer d'appareil
      </button>
      <button class="arcade-button" onclick="backToMenu()" data-i18n="options_back">
        ← Retour au menu
      </button>
    </div>
  </div>
</div>

<!-- Section Création de compte (première visite) -->
<div id="create-account" class="section">
  <h1 data-i18n="create_account_title">Bienvenue ! 🌸</h1>
  
  <div class="account-section">
    <p data-i18n="create_account_subtitle">Choisissons ton pseudo zen</p>
    
    <div class="pseudo-display" id="pseudo-proposal">
      <span id="pseudo-text">🐼</span>
    </div>

    <div id="create-error" class="error-message" style="display: none;"></div>

    <div class="button-group">
      <button class="arcade-button" onclick="generateNewPseudo()" data-i18n="create_account_regenerate">
        🔄 Autre pseudo
      </button>
      <button class="arcade-button" onclick="showPinInput()" data-i18n="create_account_validate" id="validate-pseudo-btn">
        ✅ Je valide ce pseudo
      </button>
    </div>

    <!-- Zone de saisie du PIN (cachée au début) -->
    <div id="pin-input-section" style="display: none;">
      <div class="pin-input-container">
        <label class="pin-label" data-i18n="create_account_pin_label">
          Sécurise ton compte avec ta date de naissance (JJMM)
        </label>
        <input 
          type="number" 
          id="pin-input" 
          class="pin-input" 
          placeholder="0000"
          maxlength="4"
          pattern="[0-9]{4}"
        />
        <div style="font-size: 0.9em; color: #8B6F47; margin-top: 0.5em;">
          <span data-i18n="create_account_pin_example">Exemple : né(e) le 12 mai → 1205</span>
        </div>
      </div>

      <div class="button-group">
        <button class="arcade-button" onclick="validateAccount()" data-i18n="create_account_confirm">
          🎌 Valider mon compte
        </button>
        <button class="arcade-button" onclick="hidePinInput()" data-i18n="create_account_back">
          ← Changer de pseudo
        </button>
      </div>
     
    </div>
  </div>
   <!-- Zone de confirmation du PIN (cachée au début) -->
<div id="pin-confirm-section" style="display: none;">
  <div class="pin-confirm-box" style="background: rgba(168, 213, 186, 0.1); border: 2px solid #8B6F47; border-radius: 10px; padding: 20px; margin: 20px 0;">
    <p style="font-size: 1.2em; margin-bottom: 10px;">📅 Confirmation de ta date de naissance</p>
    <p style="font-size: 1.5em; font-weight: bold; color: #8B6F47; margin: 15px 0;" id="pin-confirm-text"></p>
    <p style="font-size: 0.9em; color: #dc3545; font-weight: bold;">⚠️ Cette date te servira à récupérer ton compte en cas de besoin</p>
  </div>

  <div class="button-group">
    <button class="arcade-button" onclick="confirmPinAndCreateAccount()" data-i18n="create_account_confirm_yes">
      ✅ Oui, c'est correct
    </button>
    <button class="arcade-button" onclick="correctPin()" data-i18n="create_account_correct_pin">
      ✏️ Non, corriger
    </button>
  </div>
</div>
</div>

<!-- Section Connexion (changement d'appareil) -->
<div id="login" class="section">
  <h1 data-i18n="login_title">Connexion 🔐</h1>
  
  <div class="account-section">
    <p data-i18n="login_subtitle">Retrouve ton compte</p>

    <div class="pin-input-container">
      <label class="pin-label" data-i18n="login_pseudo_label">Ton pseudo</label>
      <input 
        type="text" 
        id="login-pseudo" 
        class="pin-input" 
        placeholder="さくらDragon"
        style="font-size: 1.5em; width: 250px;"
      />
    </div>

    <div class="pin-input-container">
      <label class="pin-label" data-i18n="login_pin_label">Ton PIN (JJMM)</label>
      <input 
        type="number" 
        id="login-pin" 
        class="pin-input" 
        placeholder="0000"
        maxlength="4"
      />
    </div>

    <div id="login-error" class="error-message" style="display: none;"></div>
    <div id="login-success" class="success-message" style="display: none;"></div>

    <div class="button-group">
      <button class="arcade-button" onclick="loginUser()" data-i18n="login_connect">
        🎋 Me connecter
      </button>
      <button class="arcade-button" onclick="backToMenu()" data-i18n="options_back">
        ← Retour
      </button>
    </div>
  </div>
</div>
  <script>
    // === SYSTÈME DE TRADUCTION ===
const translations = {
  fr: {
    // Menu
    menu_learn: "Apprendre",
    menu_revision: "Mode révisions",
    menu_options: "Options",
    menu_close: "Fermer",
    
    // Page d'accueil
    welcome_title: "🎌🌸 Kanas-Zen-Garden 🌸🎌",
    welcome_subtitle: "Apprenez à Lire le Japonais",
    welcome_loading: "Chargement...",
    welcome_touch: "Touchez le panda pour entrer !",
    
    // Quiz
    quiz_title: "🎌⛩️ Apprenez les Kanas ⛩️🎌",
    quiz_level: "Niveau actuel :",
    quiz_continue: "🌱 OK... j'ai capté 🌱",
    quiz_install: "Ajouter à l'écran d'accueil",
    
    // Révisions
    revision_title: "🎌⛩️ Réviser les Kanas ⛩️🎌",
    
    // Options
    options_title: "Options",
    options_difficulty: "Difficulté",
    options_sound: "Son",
    options_language: "Langue",
    options_back: "← Retour",
    
    // Difficulté
    difficulty_easy: "Facile (6)",
    difficulty_medium: "Moyen (8)",
    difficulty_hard: "Hard (10)",
    difficulty_set: "Difficulté réglée sur :",
    
    // Messages
    msg_perfect: "Parfait !",
    msg_validated: "Validé ! 🎉",
    msg_almost: "Presque...",
    msg_notquite: "Pas tout à fait...",
    msg_correct: "👉 Bonne réponse :",
    msg_level_up: "🍃LEVEL UP!🎋",
    
    // Messages menu
    menu_msg_blocked: "Mode Apprendre bloqué",
    menu_msg_unblocked: "Mode Apprendre débloqué !",
    menu_msg_still_blocked: "Mode Apprendre encore bloqué",
    menu_msg_revision_unlocked: "🎮 Mode révisions débloqué 🎮",
    
    // Révision disponibilité
    revision_available_level4: "Mode révision disponible à partir du niveau 4",
    revision_no_items: "Aucun item disponible pour révision",

     // Mon compte
  account_title: "Mon compte",
  account_change_device: "📱 Changer d'appareil",
  
  // Création de compte
  create_account_title: "Bienvenue ! 🌸",
  create_account_subtitle: "Choisissons ton pseudo zen",
  create_account_regenerate: "🔄 Autre pseudo",
  create_account_validate: "✅ Je valide ce pseudo",
  create_account_pin_label: "Sécurise ton compte avec ta date de naissance (JJMM)",
  create_account_pin_example: "Exemple : né(e) le 12 mai → 1205",
  create_account_confirm: "🎌 Valider mon compte",
  create_account_back: "← Changer de pseudo",
  
  // Connexion
  login_title: "Connexion 🔐",
  login_subtitle: "Retrouve ton compte",
  login_pseudo_label: "Ton pseudo",
  login_pin_label: "Ton PIN (JJMM)",
  login_connect: "🎋 Me connecter",
  create_account_confirm_yes: "✅ Oui, c'est correct", // FR
  create_account_correct_pin: "✏️ Non, corriger", // FR  
  },
  
  en: {
    // Menu
    menu_learn: "Learn",
    menu_revision: "Revision Mode",
    menu_options: "Options",
    menu_close: "Close",
    
    // Welcome page
    welcome_title: "🎌🌸 Kanas-Zen-Garden 🌸🎌",
    welcome_subtitle: "Learn to Read Japanese",
    welcome_loading: "Loading...",
    welcome_touch: "Touch the panda to enter!",
    
    // Quiz
    quiz_title: "🎌⛩️ Learn the Kanas ⛩️🎌",
    quiz_level: "Current level:",
    quiz_continue: "🌱 OK... got it 🌱",
    quiz_install: "Add to home screen",
    
    // Revision
    revision_title: "🎌⛩️ Review the Kanas ⛩️🎌",
    
    // Options
    options_title: "Options",
    options_difficulty: "Difficulty",
    options_sound: "Sound",
    options_language: "Language",
    options_back: "← Back",
    
    // Difficulty
    difficulty_easy: "Easy (6)",
    difficulty_medium: "Medium (8)",
    difficulty_hard: "Hard (10)",
    difficulty_set: "Difficulty set to:",
    
    // Messages
    msg_perfect: "Perfect!",
    msg_validated: "Validated! 🎉",
    msg_almost: "Almost...",
    msg_notquite: "Not quite...",
    msg_correct: "👉 Correct answer:",
    msg_level_up: "🍃LEVEL UP!🎋",
    
    // Menu messages
    menu_msg_blocked: "Learn Mode blocked",
    menu_msg_unblocked: "Learn Mode unblocked!",
    menu_msg_still_blocked: "Learn Mode still blocked",
    menu_msg_revision_unlocked: "🎮 Revision mode unlocked 🎮",
    
    // Revision availability
    revision_available_level4: "Revision mode available from level 4",
    revision_no_items: "No items available for revision",

    // My account
  account_title: "My Account",
  account_change_device: "📱 Change Device",
  
  // Account creation
  create_account_title: "Welcome! 🌸",
  create_account_subtitle: "Choose your zen nickname",
  create_account_regenerate: "🔄 Another nickname",
  create_account_validate: "✅ I validate this nickname",
  create_account_pin_label: "Secure your account with your birth date (DDMM)",
  create_account_pin_example: "Example: born May 12th → 1205",
  create_account_confirm: "🎌 Validate my account",
  create_account_back: "← Change nickname",
  
  // Login
  login_title: "Login 🔐",
  login_subtitle: "Find your account",
  login_pseudo_label: "Your nickname",
  login_pin_label: "Your PIN (DDMM)",
  login_connect: "🎋 Connect",
  create_account_confirm_yes: "✅ Yes, that's correct", // EN
  create_account_correct_pin: "✏️ No, correct it", // EN  
  },
  
  es: {
    // Menu
    menu_learn: "Aprender",
    menu_revision: "Modo revisión",
    menu_options: "Opciones",
    menu_close: "Cerrar",
    
    // Página de bienvenida
    welcome_title: "🎌🌸 Kanas-Zen-Garden 🌸🎌",
    welcome_subtitle: "Aprende a Leer Japonés",
    welcome_loading: "Cargando...",
    welcome_touch: "¡Toca el panda para entrar!",
    
    // Quiz
    quiz_title: "🎌⛩️ Aprende los Kanas ⛩️🎌",
    quiz_level: "Nivel actual:",
    quiz_continue: "🌱 OK... lo entendí 🌱",
    quiz_install: "Añadir a pantalla de inicio",
    
    // Revisión
    revision_title: "🎌⛩️ Revisar los Kanas ⛩️🎌",
    
    // Opciones
    options_title: "Opciones",
    options_difficulty: "Dificultad",
    options_sound: "Sonido",
    options_language: "Idioma",
    options_back: "← Volver",
    
    // Dificultad
    difficulty_easy: "Fácil (6)",
    difficulty_medium: "Medio (8)",
    difficulty_hard: "Difícil (10)",
    difficulty_set: "Dificultad ajustada a:",
    
    // Mensajes
    msg_perfect: "¡Perfecto!",
    msg_validated: "¡Validado! 🎉",
    msg_almost: "Casi...",
    msg_notquite: "No del todo...",
    msg_correct: "👉 Respuesta correcta:",
    msg_level_up: "🍃¡SUBIDA DE NIVEL!🎋",
    
    // Mensajes del menú
    menu_msg_blocked: "Modo Aprender bloqueado",
    menu_msg_unblocked: "¡Modo Aprender desbloqueado!",
    menu_msg_still_blocked: "Modo Aprender aún bloqueado",
    menu_msg_revision_unlocked: "🎮 Modo revisión desbloqueado 🎮",
    
    // Disponibilidad revisión
    revision_available_level4: "Modo revisión disponible desde el nivel 4",
    revision_no_items: "No hay elementos disponibles para revisión",
     // Mi cuenta
  account_title: "Mi Cuenta",
  account_change_device: "📱 Cambiar de Dispositivo",
  
  // Creación de cuenta
  create_account_title: "¡Bienvenido! 🌸",
  create_account_subtitle: "Elige tu apodo zen",
  create_account_regenerate: "🔄 Otro apodo",
  create_account_validate: "✅ Valido este apodo",
  create_account_pin_label: "Asegura tu cuenta con tu fecha de nacimiento (DDMM)",
  create_account_pin_example: "Ejemplo: nacido el 12 de mayo → 1205",
  create_account_confirm: "🎌 Validar mi cuenta",
  create_account_back: "← Cambiar apodo",
  
  // Conexión
  login_title: "Conexión 🔐",
  login_subtitle: "Encuentra tu cuenta",
  login_pseudo_label: "Tu apodo",
  login_pin_label: "Tu PIN (DDMM)",
  login_connect: "🎋 Conectarme",
  create_account_confirm_yes: "✅ Sí, es correcto", // ES
  create_account_correct_pin: "✏️ No, corregir" // ES  
  }
};

// Langue actuelle (par défaut français)
let currentLanguage = localStorage.getItem('appLanguage') || 'fr';

// Fonction pour obtenir une traduction
function t(key) {
  return translations[currentLanguage][key] || translations['fr'][key] || key;
}
// Fonction pour obtenir la bonne valeur Katakana selon la langue
function getLocalizedKatakana(item) {
  if (currentLanguage === 'en' && item.KatakanaEN) {
    return item.KatakanaEN;
  } else if (currentLanguage === 'es' && item.KatakanaES) {
    return item.KatakanaES;
  }
  return item.Katakana; // Fallback sur français
}
// Fonction pour changer de langue
function setLanguage(lang) {
  if (translations[lang]) {
    currentLanguage = lang;
    localStorage.setItem('appLanguage', lang);
    
    // ✅ NOUVEAU : Régénérer les tables Katakana avec la nouvelle langue
    if (HiraganaList.length > 0) {
      revisionKatakanaTable = generateRevisionKatakanaTable(HiraganaList);
      console.log(`🔄 Table katakana régénérée pour langue ${lang}:`, Object.keys(revisionKatakanaTable).length, "entrées");
    }
    
    updateAllTexts();
    if (revisionMode.isActive) {
  startRevisionQuestion();
} else {
  nextQuestion();
}
  }
}
// Fonction pour mettre à jour tous les textes de l'interface
function updateAllTexts() {
  // Mettre à jour tous les éléments avec data-i18n
  document.querySelectorAll('[data-i18n]').forEach(element => {
    const key = element.getAttribute('data-i18n');
    element.textContent = t(key);
  });
  
  // Mettre à jour le niveau actuel
  const levelDisplay = document.getElementById("levelDisplay");
  if (levelDisplay) {
    levelDisplay.innerText = `${t('quiz_level')} ${niveauActif}`;
  }
  
  // Mettre à jour les titres des sections
  updateSectionTitles();
  
  // Mettre à jour les messages du menu si visible
  updateMenuMessage();
  
  // Mettre à jour le message de chargement si présent
  const loadingText = document.getElementById("loadingText");
  if (loadingText && loadingText.textContent.includes("Chargement") || loadingText.textContent.includes("Loading") || loadingText.textContent.includes("Cargando")) {
    if (gameDataLoaded) {
      loadingText.textContent = t('welcome_touch');
    } else {
      loadingText.textContent = `(${t('welcome_loading')})`;
    }
  }
}

// Fonction auxiliaire pour mettre à jour les titres
function updateSectionTitles() {
  // Titre page d'accueil
  const welcomeTitle = document.querySelector('.welcome-title');
  if (welcomeTitle) welcomeTitle.textContent = t('welcome_title');
  
  const welcomeSubtitle = document.querySelector('.welcome-subtitle');
  if (welcomeSubtitle) welcomeSubtitle.textContent = t('welcome_subtitle');
}    
     // Ajout du support pour les événements tactiles
    document.querySelectorAll('.revision-key').forEach(key => {
      key.addEventListener('touchstart', function() {
        this.classList.add('active');
        setTimeout(() => {
          this.classList.remove('active');
        }, 300); // Correspond à la durée de l'animation (0.3s)
      });
    });
// ========================================
// GESTION UTILISATEUR - À AJOUTER DANS <script>
// ========================================

// Variables globales utilisateur
let currentUser = null;
let currentPseudoProposal = null;
let userToken = null;

// ========================================
// INITIALISATION AU CHARGEMENT
// ========================================
async function initUserSystem() {
  // Vérifier si un token existe déjà
  userToken = localStorage.getItem('userToken');
  
  if (userToken) {
    // L'utilisateur a déjà un compte
    const result = await callAPI('getUserByToken', { token: userToken });
    
    if (result.success) {
      currentUser = result.user;
      await loadUserProgress();
      console.log('✅ Utilisateur connecté:', currentUser.pseudo);
      updateAccountDisplay();
    } else {
      // Token invalide, demander création de compte
      console.warn('⚠️ Token invalide, création de compte nécessaire');
      localStorage.removeItem('userToken');
      userToken = null;
    }
  }
  
  // Si pas de token valide, l'utilisateur verra la page d'accueil
  // et pourra cliquer sur le panda pour créer son compte
}
// ========================================
// CACHE DE PSEUDOS - À AJOUTER APRÈS currentUser, currentPseudoProposal, userToken
// ========================================
let pseudoCache = [];
let currentPseudoIndex = 0;

// Générer un batch de 10 pseudos localement
// Générer un batch de 10 pseudos localement
function generatePseudoBatch() {
  const wordListsStr = localStorage.getItem('wordLists');
  if (!wordListsStr) {
    console.error('❌ WordLists non disponibles dans localStorage');
    return [];
  }
  
  let wordLists;
  try {
    wordLists = JSON.parse(wordListsStr);
  } catch (e) {
    console.error('❌ Erreur parsing wordLists:', e);
    return [];
  }
  
  // 🔍 DEBUG : Afficher la structure
  console.log('📦 Structure wordLists:', Object.keys(wordLists));
  
  // ✅ Adapter selon la structure réelle
  // Si c'est un tableau d'objets {jpn: "...", eng: "..."}
  if (Array.isArray(wordLists)) {
    const batch = [];
    for (let i = 0; i < 10; i++) {
      const randomWord = wordLists[Math.floor(Math.random() * wordLists.length)];
      batch.push({
        pseudo: randomWord.jpn + randomWord.eng,
        jpnWord: randomWord.jpn,
        engWord: randomWord.eng
      });
    }
    console.log(`✅ Batch de ${batch.length} pseudos générés (format array)`);
    return batch;
  }
  
  // Si c'est un objet {jpn: [...], eng: [...]}
  if (wordLists.jpn && wordLists.eng) {
    const batch = [];
    for (let i = 0; i < 10; i++) {
      const jpnWord = wordLists.jpn[Math.floor(Math.random() * wordLists.jpn.length)];
      const engWord = wordLists.eng[Math.floor(Math.random() * wordLists.eng.length)];
      batch.push({
        pseudo: jpnWord + engWord,
        jpnWord: jpnWord,
        engWord: engWord
      });
    }
    console.log(`✅ Batch de ${batch.length} pseudos générés (format objet)`);
    return batch;
  }
  
  console.error('❌ Structure wordLists non reconnue:', wordLists);
  return [];
}
// Initialiser le cache au premier affichage de create-account
function initPseudoCache() {
  if (pseudoCache.length === 0) {
    pseudoCache = generatePseudoBatch();
    currentPseudoIndex = 0;
  }
}
// ========================================
// GÉNÉRATION DE PSEUDO - REMPLACER LA FONCTION EXISTANTE
// ========================================
async function generateNewPseudo() {
  const pseudoText = document.getElementById('pseudo-text');
  const errorDiv = document.getElementById('create-error');
  const validateBtn = document.getElementById('validate-pseudo-btn');
  
  errorDiv.style.display = 'none';
  
  // Si cache vide ou épuisé, régénérer un batch
  if (currentPseudoIndex >= pseudoCache.length) {
    pseudoCache = generatePseudoBatch();
    currentPseudoIndex = 0;
    
    if (pseudoCache.length === 0) {
      errorDiv.textContent = 'Erreur : listes de mots non chargées';
      errorDiv.style.display = 'block';
      pseudoText.textContent = '❌';
      return;
    }
  }
  
  // Proposer le prochain pseudo du cache
  currentPseudoProposal = pseudoCache[currentPseudoIndex];
  currentPseudoIndex++;
  
  pseudoText.textContent = currentPseudoProposal.pseudo;
  validateBtn.disabled = false;
  
  console.log(`🎯 Pseudo proposé: ${currentPseudoProposal.pseudo} (${currentPseudoIndex}/${pseudoCache.length} du cache)`);
}

// ========================================
// AFFICHER LA SAISIE DU PIN
// ========================================
// ========================================
// AFFICHER LA SAISIE DU PIN (VERSION AMÉLIORÉE)
// ========================================
function showPinInput() {
  if (!currentPseudoProposal) {
    alert('Veuillez générer un pseudo d\'abord');
    return;
  }
  
  document.getElementById('validate-pseudo-btn').style.display = 'none';
  document.querySelector('button[onclick="generateNewPseudo()"]').style.display = 'none';
  document.getElementById('pin-input-section').style.display = 'block';
  document.getElementById('pin-input').focus();
  
  // Réinitialiser la confirmation si elle existe
  const confirmSection = document.getElementById('pin-confirm-section');
  if (confirmSection) confirmSection.style.display = 'none';
}

// ========================================
// MASQUER LA SAISIE DU PIN
// ========================================
function hidePinInput() {
  document.getElementById('validate-pseudo-btn').style.display = 'block';
  document.querySelector('button[onclick="generateNewPseudo()"]').style.display = 'block';
  document.getElementById('pin-input-section').style.display = 'none';
  document.getElementById('pin-input').value = '';
}

// ========================================
// VALIDER LE COMPTE (VERSION AVEC CONFIRMATION)
// ========================================
async function validateAccount() {
  const pinInput = document.getElementById('pin-input');
  const pin = pinInput.value.trim();
  const errorDiv = document.getElementById('create-error');
  
  // Validation du PIN
  const validation = validatePin(pin);
  if (!validation.valid) {
    errorDiv.textContent = validation.error;
    errorDiv.style.display = 'block';
    pinInput.focus();
    return;
  }
  
  errorDiv.style.display = 'none';
  
  // Afficher la confirmation
  const dateInfo = formatPinToDate(pin);
  document.getElementById('pin-confirm-text').textContent = 
    `Tu es né(e) le ${dateInfo.day} ${dateInfo.monthName} ?`;
  
  // Masquer la saisie, afficher la confirmation
  document.getElementById('pin-input-section').style.display = 'none';
  document.getElementById('pin-confirm-section').style.display = 'block';
  
  // Stocker temporairement le PIN pour la confirmation
  window.tempPin = pin;
}

// ========================================
// CONNEXION (changement d'appareil)
// ========================================
async function loginUser() {
  const pseudo = document.getElementById('login-pseudo').value.trim();
  const pin = document.getElementById('login-pin').value.trim();
  const errorDiv = document.getElementById('login-error');
  const successDiv = document.getElementById('login-success');
  
  // Réinitialiser les messages
  errorDiv.style.display = 'none';
  successDiv.style.display = 'none';
  
  // Validation
  if (!pseudo || !pin) {
    errorDiv.textContent = 'Veuillez remplir tous les champs';
    errorDiv.style.display = 'block';
    return;
  }
  
  if (pin.length !== 4 || !/^\d{4}$/.test(pin)) {
    errorDiv.textContent = 'Le PIN doit contenir 4 chiffres';
    errorDiv.style.display = 'block';
    return;
  }
  
  try {
    // 1. Authentifier l'utilisateur
    const authResult = await callAPI('authenticateUser', { pseudo, pin });
    
    if (!authResult.success) {
      errorDiv.textContent = authResult.error || 'Pseudo ou PIN incorrect';
      errorDiv.style.display = 'block';
      return;
    }
    
    // 2. Générer un nouveau token
    const newToken = crypto.randomUUID();
    
    // 3. Mettre à jour le token dans la base
    const updateResult = await callAPI('updateUserToken', {
      pseudo,
      pin,
      newToken
    });
    
    if (updateResult.success) {
      // Sauvegarder le nouveau token localement
      userToken = newToken;
      localStorage.setItem('userToken', newToken);
      currentUser = authResult.user;
      await loadUserProgress();
      currentUser.token = newToken;
      
      console.log('✅ Connexion réussie:', currentUser.pseudo);
      
      successDiv.textContent = `Bienvenue ${currentUser.pseudo} ! 🎌`;
      successDiv.style.display = 'block';
      
      // Rediriger vers le menu après 1.5s
      setTimeout(() => {
        showSection('menu-section');
        updateAccountDisplay();
      }, 1500);
      
    } else {
      errorDiv.textContent = 'Erreur lors de la mise à jour du token';
      errorDiv.style.display = 'block';
    }
    
  } catch (error) {
    errorDiv.textContent = 'Erreur de connexion';
    errorDiv.style.display = 'block';
    console.error('❌ Erreur connexion:', error);
  }
}

// ========================================
// AFFICHER LA PAGE DE CONNEXION
// ========================================
function showChangeDevice() {
  showSection('login');
}

// ========================================
// METTRE À JOUR L'AFFICHAGE DU COMPTE
// ========================================
function updateAccountDisplay() {
  if (currentUser) {
    document.getElementById('account-pseudo').textContent = currentUser.pseudo;
    document.getElementById('account-level').textContent = currentUser.niveau_atteint || niveauActif;
  }
}
// ========================================
// VALIDATION ET FORMATAGE DATE DE NAISSANCE
// ========================================
function formatPinToDate(pin) {
  if (!pin || pin.length !== 4) return null;
  const day = pin.substring(0, 2);
  const month = pin.substring(2, 4);
  
  const months = ['janvier', 'février', 'mars', 'avril', 'mai', 'juin', 
                  'juillet', 'août', 'septembre', 'octobre', 'novembre', 'décembre'];
  const monthName = months[parseInt(month) - 1];
  
  return { day, month, monthName, formatted: `${day}/${month}` };
}

function validatePin(pin) {
  if (!pin || pin.length !== 4) {
    return { valid: false, error: 'Le PIN doit contenir exactement 4 chiffres' };
  }
  
  if (!/^\d{4}$/.test(pin)) {
    return { valid: false, error: 'Le PIN doit contenir uniquement des chiffres' };
  }
  
  const day = parseInt(pin.substring(0, 2));
  const month = parseInt(pin.substring(2, 4));
  
  if (day < 1 || day > 31) {
    return { valid: false, error: 'Le jour doit être entre 01 et 31' };
  }
  
  if (month < 1 || month > 12) {
    return { valid: false, error: 'Le mois doit être entre 01 et 12' };
  }
  
  return { valid: true };
}
// ========================================
// RETOUR AU MENU
// ========================================
function backToMenu() {
  showSection('menu-section');
  toggleMenu();
}
// Nouvelle fonction : Charger progrès per-user et merger
// Amélioration de loadUserProgress() : Ajoute logs et defaults
async function loadUserProgress() {
  if (!userToken) {
    console.warn('⚠️ Pas de token - Stats non chargées');
    return;
  }
  
  const userStats = await callAPI('getUserStats', { token: userToken });
  if (userStats.success) {
    const stats = userStats.stats || {};
    let mergedCount = 0;
    
    // Merge stats dans HiraganaList
    HiraganaList.forEach(item => {
      const itemStats = stats[item.ID.toString()] || { validation: 0, tentatives: 0, reussites: 0 };
      // Forcer l’ajout des propriétés si absentes
      if (item.Validation !== itemStats.validation || 
          item.Tentatives !== itemStats.tentatives || 
          item['Réussites'] !== itemStats.reussites) {
        item.Validation = itemStats.validation;
        item.Tentatives = itemStats.tentatives;
        item['Réussites'] = itemStats.reussites;
        mergedCount++;
      }
    });
    
    console.log(`📊 Progrès user chargé: ${mergedCount} items mis à jour | Niveau serveur: ${userStats.niveau_atteint}`);
    
    // Recalculer niveauActif
    niveauActif = determineNiveauActif(HiraganaList);
    if (userStats.niveau_atteint > niveauActif) {
      niveauActif = userStats.niveau_atteint; // Fallback si serveur plus haut
      console.log(`🔄 Niveau forcé à ${niveauActif} (serveur)`);
    }
    
    // Régénérer tables avec stats mergées
    revisionRomajiTable = generateRevisionRomajiTable(HiraganaList);
    revisionKatakanaTable = generateRevisionKatakanaTable(HiraganaList);
    console.log(`📚 Tables régénérées après merge: Romaji=${revisionRomajiTable.length}, Katakana=${revisionKatakanaTable.length}`);
    
    // Rafraîchir UI
    document.getElementById("levelDisplay").innerText = `${t('quiz_level')} ${niveauActif}`;
    updateLevelProgress(HiraganaList, niveauActif);
    renderProgressBar(niveauActif, getMaxLevel(HiraganaList));
    renderHiraganaCards(HiraganaList, niveauActif); // Afficher étoiles
    updateMenuButtonStates();
    
  } else {
    console.error('⚠️ Erreur chargement stats user:', userStats.error);
    // Fallback niveau 1
    niveauActif = 1;
    document.getElementById("levelDisplay").innerText = `${t('quiz_level')} 1`;
  }
} 
// ========================================
// CONFIRMER ET CRÉER LE COMPTE
// ========================================
async function confirmPinAndCreateAccount() {
  const pin = window.tempPin;
  const errorDiv = document.getElementById('create-error');
  
  // Générer un token unique
  userToken = crypto.randomUUID();
  
  try {
    const result = await callAPI('assignPseudo', {
      token: userToken,
      pseudo: currentPseudoProposal.pseudo,
      jpnWord: currentPseudoProposal.jpnWord,
      engWord: currentPseudoProposal.engWord,
      pin: pin
    });
    
    if (result.success) {
      // Sauvegarder le token localement
      localStorage.setItem('userToken', userToken);
      currentUser = result.user;
      await loadUserProgress();
      console.log('✅ Compte créé avec succès:', currentUser.pseudo);
      
      // Afficher message de succès
      document.getElementById('pseudo-text').textContent = '✅ Compte créé !';
      document.getElementById('pin-confirm-section').style.display = 'none';
      
      // Rediriger vers le menu après 1.5s
      setTimeout(() => {
        showSection('menu-section');
        updateAccountDisplay();
      }, 1500);
      
    } else {
      errorDiv.textContent = result.error || 'Erreur lors de la création du compte';
      errorDiv.style.display = 'block';
      document.getElementById('pin-confirm-section').style.display = 'none';
      document.getElementById('pin-input-section').style.display = 'block';
      console.error('❌ Erreur création compte:', result.error);
    }
  } catch (error) {
    errorDiv.textContent = 'Erreur de connexion';
    errorDiv.style.display = 'block';
    document.getElementById('pin-confirm-section').style.display = 'none';
    document.getElementById('pin-input-section').style.display = 'block';
    console.error('❌ Erreur:', error);
  }
  
  // Nettoyer le PIN temporaire
  delete window.tempPin;
}

// ========================================
// CORRIGER LE PIN
// ========================================
function correctPin() {
  // Retour à la saisie
  document.getElementById('pin-confirm-section').style.display = 'none';
  document.getElementById('pin-input-section').style.display = 'block';
  document.getElementById('pin-input').value = window.tempPin || '';
  document.getElementById('pin-input').focus();
  
  // Nettoyer le PIN temporaire
  delete window.tempPin;
}    
function toggleMenu() {
  const menu = document.getElementById('menu');
  menu.classList.toggle('active');
  
  // NOUVEAU : Vérifier l'état des boutons à chaque ouverture du menu
  if (menu.classList.contains('active')) {
    updateMenuButtonStates();
  }
}
function loadDifficulty() {
  const saved = localStorage.getItem("difficulty");
  if (saved) {
    seuilValidation = parseInt(saved, 10);
    console.log("Difficulté restaurée :", seuilValidation);
  } else {
    // valeur par défaut si rien n'est encore enregistré
    seuilValidation = 6; // Moyen par défaut
  }
}
function showSubOptions(section) {
  // Masquer le menu principal
  document.querySelector(".options-menu").classList.add("hidden");

  // Masquer toutes les sous-rubriques
  document.querySelectorAll('.options-sub').forEach(div => {
    div.classList.remove("active");
    div.classList.add("hidden");
  });

  // Afficher la sous-rubrique choisie avec animation
  const sub = document.getElementById('options-' + section);
  sub.classList.remove("hidden");
  setTimeout(() => sub.classList.add("active"), 10);
}

function backToOptions() {
  // Masquer toutes les sous-rubriques
  document.querySelectorAll('.options-sub').forEach(div => {
    div.classList.remove("active");
    div.classList.add("hidden");
  });

  // Réafficher le menu principal Options
  const menu = document.querySelector(".options-menu");
  menu.classList.remove("hidden");
}

function setDifficulty(value) {
  seuilValidation = value; 
  localStorage.setItem("difficulty", value);

  // Mise en surbrillance du bouton choisi
  document.querySelectorAll("#options-difficulty .arcade-button").forEach(btn => {
    btn.classList.remove("clicked-glow");
  });
  event.target.classList.add("clicked-glow");

  // ✅ Mettre à jour le bouton Apprendre
  updateApprendreButtonState();

alert(`${t('difficulty_set')} ${value}`);

 niveauActif = determineNiveauActif(HiraganaList);
  document.getElementById("levelDisplay").innerText = `Niveau actuel : ${niveauActif}`;
  updateLevelProgress(HiraganaList, niveauActif);
  renderProgressBar(niveauActif, getMaxLevel(HiraganaList));
  nextQuestion();      


}
function showSection(sectionId) {
  // NOUVEAU : Vérifier le blocage seulement lors du retour au menu depuis le mode révision
  if (sectionId === 'menu-section' && revisionMode.isActive) {
    const wasBlocked = hasShownBlockedMenu; // État précédent
    const isNowBlocked = isApprentissageBloque();
    
    // Mettre à jour l'état des boutons
    updateApprendreButtonState();
    
    // Afficher message approprié
    if (isNowBlocked && !wasBlocked) {
      // Passage de débloqué à bloqué
      setTimeout(() => {
        const menu = document.getElementById('menu');
        const menuMessage = document.getElementById('menu-message');
        menu.classList.add('active');
        menuMessage.innerText = t('menu_msg_blocked'); // ✅ MODIFIÉ
        hasShownBlockedMenu = true;
      }, 500);
    } else if (!isNowBlocked && wasBlocked) {
      // Passage de bloqué à débloqué
      setTimeout(() => {
        const menu = document.getElementById('menu');
        const menuMessage = document.getElementById('menu-message');
        menu.classList.add('active');
        menuMessage.innerText = t('menu_msg_unblocked'); // ✅ MODIFIÉ
        hasShownBlockedMenu = false;
        hasShownUnblockedMenu = true;
      }, 500);
    } else if (isNowBlocked) {
      // Toujours bloqué
      setTimeout(() => {
        const menuMessage = document.getElementById('menu-message');
        if (menuMessage) {
          menuMessage.innerText = t('menu_msg_still_blocked'); // ✅ MODIFIÉ
        }
      }, 500);
    }
    // Si on quitte le mode révision
  if (sectionId !== 'mode2') { // 'mode2' est l'ID de la section révision
    revisionMode.isActive = false;
    hasUnlockedInRevision = false; // Réinitialiser pour la prochaine session
  }
  }

  // NOUVEAU : Vérifier systématiquement l'état du bouton Apprendre à chaque passage par le menu
  if (sectionId === 'menu-section') {
    updateApprendreButtonState();
    updateMenuSectionMessage();
  }

  // Vérifier si on essaie d'accéder au mode révision
  if (sectionId === 'mode2' && !isRevisionModeAvailable()) {
    console.log('Mode révision non disponible');
    return;
  }

  // SUPPRIMER la redirection automatique vers le mode révision
  // Le bouton bloqué ne doit plus rediriger, il doit juste être inopérant
  
  document.querySelectorAll('.section').forEach(section => {
    section.classList.remove('active');
  });
  document.getElementById(sectionId).classList.add('active');
  if (sectionId === 'create-account') {
  initPseudoCache();
  generateNewPseudo(); // Afficher le premier pseudo automatiquement
}
  // Démarrer le mode révisions si c'est le mode sélectionné
if (sectionId === 'mode2') {
  wasBlockedWhenEnteringRevision = isApprentissageBloque();
  if (wasBlockedWhenEnteringRevision) {
    deficitInitialRevision = calculerDeficitValidation();
    pointsGagnesEnRevision = 0; // ✅ RESET du compteur à l'entrée
    console.log(`🎯 Déficit initial capturé: ${deficitInitialRevision} points`);
  }
  hasUnlockedInRevision = false;
  revisionMode.isActive = true;
  setTimeout(() => {
    initRevisionKeyboard();
    startRevisionQuestion();
    // ✅ La barre s'affichera via startRevisionQuestion()
  }, 100);
} else {
    revisionMode.isActive = false;
    // Remettre à false quand on quitte le mode révision
    wasBlockedWhenEnteringRevision = false;
  }
 /* toggleMenu(); */
}

   
function forceRevisionMode() {
  document.querySelectorAll('.section').forEach(section => {
    section.classList.remove('active');
  });
  document.getElementById('mode2').classList.add('active');
  
  revisionMode.isActive = true;
  setTimeout(() => {
    initRevisionKeyboard();
    startRevisionQuestion();
    updateUnlockProgress(); // Ajouter cette ligne
  }, 100);
}    
function updateMenuMessage() {
  const menuMessage = document.getElementById('menu-message');
  if (menuMessage && menuMessage.innerText === '') {
    // Messages neutres multilingues (les emojis sont universels)
    const messages = [
      '⛩️ Kanas-Zen-Garden ⛩️',
      '🎌 Kanas-Zen-Garden 🎌',
      '🍃 Kanas-Zen-Garden 🍵',
    ];
    menuMessage.innerText = messages[Math.floor(Math.random() * messages.length)];
  }
}
  </script>
<script>
let pointsGagnesEnRevision = 0; // ✅ NOUVEAU : compteur de progression  
let wasBlockedWhenEnteringRevision = false;
let deficitInitialRevision = 0;  
let hasUnlockedInRevision = false; // Nouvelle variable pour suivre le déblocage  
let gameDataLoaded = false; // Nouvelle variable globale  
let HiraganaList = [];
let current = {};
let selections = { first: null, second: null };
let targetFields = [];
let isAnswered = false;
let niveauActif = 1;
let previousValidationStates = new Map();
let activeSparks = []; // Variable globale pour les particules
let globalParticleCount = 0; // Compteur global
let previousCharacter = null;
let hasShownLevel4Menu = false; // Variable pour suivre si le menu a été affiché au niveau 4  
let validationCache = {}; // Ajouter cette ligne près des autres variables globales
let statsCache = {
  items: {}, // { [hiragana/katakana]: { tentatives, reussites, pourcentage } }
  globalPourcentage: 0
};
let seuilValidation = parseInt(localStorage.getItem('seuilValidation')) || 10;  
// Variables pour le mode révisions
let revisionMode = {
  currentQuestion: "",
  input: "",
  romajiSegments: [],
  charCounts: [],
  fullCorrect: "",
  cumulativeRomaji: [],
  cumulativeChars: [],
  isActive: false
};
const GROUPES = {
  1: { niveaux: [1, 2, 3], nom: "Groupe 1" },
  2: { niveaux: [4, 5], nom: "Groupe 2" },
  3: { niveaux: [6, 7, 8], nom: "Groupe 3" },
  4: { niveaux: [9, 10, 11, 12], nom: "Groupe 4" },
  5: { niveaux: [13, 14, 15, 16, 17], nom: "Groupe 5" },
  6: { niveaux: [18, 19, 20, 21, 22], nom: "Groupe 6" },
  7: { niveaux: [23, 24, 25, 26, 27], nom: "Groupe 7" },
  8: { niveaux: [28, 29, 30, 31, 32, 33], nom: "Groupe 8" },
  9: { niveaux: [34, 35, 36, 37, 38, 39], nom: "Groupe 9" },
  10: { niveaux: [40, 41, 42, 43, 44, 45, 46], nom: "Groupe 10" }
};

let hasShownBlockedMenu = false;
let hasShownUnblockedMenu = false;
function startApp() {
  if (!gameDataLoaded) {
    document.getElementById("loadingText").textContent = t('welcome_loading'); // ✅ MODIFIÉ
    return;
  }
  
  updateMenuMessage();
}
function updateMenuSectionMessage() {
  const messages = [
    'Continues à apprendre ! 🌸',
    'Explores les options ! ⚙️',
    'Progresses chaque jour ! 🐼',
    'Un pas après l\'autre 🌸',
    'Bravo, tu progresses 🎌'
  ];
  const menuMessage = document.getElementById('menu-message');
  if (menuMessage) {
    menuMessage.innerText = messages[Math.floor(Math.random() * messages.length)];
  }
}  
function getNiveauGroupe(niveau) {
  for (const [groupeId, groupe] of Object.entries(GROUPES)) {
    if (groupe.niveaux.includes(niveau)) {
      return parseInt(groupeId);
    }
  }
  return 1;
}
function getItemCountForLevel(level) {
 return HiraganaList.filter(h => parseInt(h.Niveau) === level && parseInt(h.Niveau) >= level).length;
  
}
function calculerDeficitValidation() {
  const groupeActuel = getNiveauGroupe(niveauActif);
  if (groupeActuel < 3) return 0; // Pas de blocage avant le groupe 3
  
  let deficitTotal = 0;
  
  // Parcourir TOUS les groupes précédents (1 à groupeActuel-1)
  for (let g = 1; g < groupeActuel; g++) {
    const niveauxGroupe = GROUPES[g].niveaux;
    
    for (const niveau of niveauxGroupe) {
      const itemsNiveau = HiraganaList.filter(h => parseInt(h.Niveau) === niveau);
      for (const item of itemsNiveau) {
        const validation = parseInt(item.Validation || 0);
        if (validation < seuilValidation) {
  deficitTotal += (seuilValidation - validation);
        }
      }
    }
  }
  
  return deficitTotal;
}
function calculerDeficitMaximum() {
  const groupeActuel = getNiveauGroupe(niveauActif);
  if (groupeActuel < 3) return 0;
  
  let totalItems = 0;
  
  // Parcourir TOUS les groupes précédents (1 à groupeActuel-1)
  for (let g = 1; g < groupeActuel; g++) {
    const niveauxGroupe = GROUPES[g].niveaux;
    
    for (const niveau of niveauxGroupe) {
      const itemsNiveau = HiraganaList.filter(h => parseInt(h.Niveau) === niveau);
      totalItems += itemsNiveau.length;
    }
  }
  
  return totalItems * (seuilValidation - 5); // Déficit max = passage de 5 au seuil
}
function updateUnlockProgress() {
  const container = document.getElementById('unlock-progress-container');
  const fill = document.getElementById('unlock-progress-fill');

  if (!container || !fill) return;

  if (!revisionMode.isActive || !wasBlockedWhenEnteringRevision || hasUnlockedInRevision) {
    container.style.display = 'none';
    return;
  }

  container.style.display = 'block';

  const deficitRestant = Math.max(0, deficitInitialRevision - pointsGagnesEnRevision);
  const pourcentage = deficitInitialRevision > 0 ? (deficitRestant / deficitInitialRevision * 100) : 0;

  fill.style.width = `${pourcentage}%`;

  console.log(`📊 Progress: ${deficitRestant}/${deficitInitialRevision} (${pourcentage.toFixed(1)}%) | Points: ${pointsGagnesEnRevision}`);

  if (pointsGagnesEnRevision >= deficitInitialRevision) {
    container.style.display = 'none';
    hasUnlockedInRevision = true;
    localStorage.setItem('apprentissageBloque', 'false');
    updateApprendreButtonState();
    console.log('🎉 Déblocage atteint');
  }

  if (pourcentage < 10 && pourcentage > 0) {
    fill.classList.add('proche-deblocage');
  } else {
    fill.classList.remove('proche-deblocage');
  }
}
function isGroupeDebloque(groupeId) {
  if (groupeId <= 2) return true; // Groupes 1 et 2 toujours débloqués
  
  // Vérifier TOUS les groupes précédents (1 à groupeId-1)
  for (let g = 1; g < groupeId; g++) {
    const niveauxGroupe = GROUPES[g].niveaux;
    
    for (const niveau of niveauxGroupe) {
      const itemsNiveau = HiraganaList.filter(h => parseInt(h.Niveau) === niveau);
      const itemsValides = itemsNiveau.filter(h => parseInt(h.Validation || 0) >= seuilValidation);
      
      if (itemsValides.length < itemsNiveau.length) {
        return false;
      }
    }
  }
  return true;
}
function isApprentissageBloque() {
  const groupeActuel = getNiveauGroupe(niveauActif);
  // Pour les niveaux ≤ 5 : logique actuelle
  if (niveauActif <= 5) {
    return groupeActuel >= 3 && !isGroupeDebloque(groupeActuel);
  }
  // Pour les niveaux > 5 : bloquer si déficit > 2, débloquer SEULEMENT si déficit = 0
  else {
    const deficit = calculerDeficitValidation();
    // Si actuellement bloqué, ne débloquer que si déficit = 0
    const wasBlocked = localStorage.getItem('apprentissageBloque') === 'true';
    
    if (wasBlocked) {
      // Déjà bloqué : on ne débloque QUE si déficit = 0
      const shouldUnblock = deficit === 0;
      if (shouldUnblock) {
        localStorage.setItem('apprentissageBloque', 'false');
      }
      return !shouldUnblock;
    } else {
      // Pas encore bloqué : on bloque si déficit > 2
      const shouldBlock = deficit > 2;
      if (shouldBlock) {
        localStorage.setItem('apprentissageBloque', 'true');
      }
      return shouldBlock;
    }
  }
}
  
// Initialisation du contexte audio (à placer au début du script, une seule fois)
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  
// Fonction pour générer la table romaji à partir des données  Sheet (VERSION CORRIGÉE)
function generateRevisionRomajiTable(hiraganaList) {
  const table = {};
  let validItems = 0;
  let invalidItems = 0;
  
  hiraganaList.forEach((item, index) => {
    const hiragana = item.Hiragana;
    const romaji = item.Romaji;
    
    // ✅ VÉRIFICATIONS ROBUSTES
    if (!hiragana || !romaji) {
      console.warn(`⚠️ Item ${index} ignoré - données manquantes:`, {hiragana, romaji});
      invalidItems++;
      return;
    }
    
    // Convertir en string si ce n'est pas déjà le cas
    const hiraganaStr = String(hiragana).trim();
    const romajiStr = String(romaji).trim();
    
    if (hiraganaStr === '' || romajiStr === '' || romajiStr === 'undefined' || romajiStr === 'null') {
      console.warn(`⚠️ Item ${index} ignoré - données vides:`, {hiragana: hiraganaStr, romaji: romajiStr});
      invalidItems++;
      return;
    }
    
    try {
      // Analyser le romaji pour créer les segments
      const segments = analyzeRomajiSegments(romajiStr);
      table[hiraganaStr] = {
        romaji: segments.segments,
        charCounts: segments.charCounts,
        originalRomaji: romajiStr,
        niveau: item.Niveau,
        validation: item.Validation
      };
      validItems++;
    } catch (error) {
      console.error(`❌ Erreur lors de l'analyse de l'item ${index}:`, {hiragana: hiraganaStr, romaji: romajiStr}, error);
      invalidItems++;
    }
  });
  
  console.log(`📊 Génération table romaji: ${validItems} items valides, ${invalidItems} items ignorés`);
  return table;
}
function generateRevisionKatakanaTable(hiraganaList) {
  const table = {};
  let validItems = 0;
  let invalidItems = 0;
  
  hiraganaList.forEach((item, index) => {
    const katakana = getLocalizedKatakana(item); // ✅ NOUVEAU
    const romaji = item.Romaji;
    
    if (!katakana || !romaji) {
      console.warn(`⚠️ Item ${index} ignoré pour Katakana - données manquantes:`, {katakana, romaji});
      invalidItems++;
      return;
    }
    
    const katakanaStr = String(katakana).trim();
    const romajiStr = String(romaji).trim();
    
    if (katakanaStr === '' || romajiStr === '' || romajiStr === 'undefined' || romajiStr === 'null') {
      invalidItems++;
      return;
    }
    
    try {
      const segments = analyzeRomajiSegments(romajiStr);
      table[katakanaStr] = {
        romaji: segments.segments,
        charCounts: segments.charCounts,
        originalRomaji: romajiStr,
        niveau: item.Niveau,
        validation: item.Validation
      };
      validItems++;
    } catch (error) {
      invalidItems++;
    }
  });
  
  console.log(`📊 Génération table katakana: ${validItems} items valides, ${invalidItems} items ignorés`);
  return table;
}
// Fonction pour analyser et segmenter le romaji (VERSION CORRIGÉE)
function analyzeRomajiSegments(romajiInput) {
  if (!romajiInput) {
    throw new Error("Romaji vide ou null");
  }
  
  let romajiString = String(romajiInput).toLowerCase().trim();
  romajiString = romajiString.replace(/[^a-z]/g, '');

  if (romajiString === '') {
    throw new Error(`Romaji vide après nettoyage des caractères spéciaux`);
  }

  // Segmenter intelligemment
  const segments = smartSegmentRomaji(romajiString);
  
  return {
    segments: segments,
    charCounts: segments.map(() => 1) // Chaque segment = 1 caractère visuel
  };
}
  
// Fonction pour segmenter intelligemment le romaji (INCHANGÉE mais ajout de vérifications)
function smartSegmentRomaji(romaji) {
  if (!romaji || typeof romaji !== 'string') {
    console.warn("smartSegmentRomaji: romaji invalide", romaji);
    return [romaji || ''];
  }
  
  const specialSyllables = [
    'tsu', 'shi', 'chi', 'sha', 'sho', 'shu', 'cha', 'cho', 'chu',
    'nya', 'nyo', 'nyu', 'hya', 'hyo', 'hyu', 'mya', 'myo', 'myu',
    'rya', 'ryo', 'ryu', 'gya', 'gyo', 'gyu', 'bya', 'byo', 'byu',
    'pya', 'pyo', 'pyu', 'kya', 'kyo', 'kyu', 'ja', 'ji', 'ju', 'jo'
  ];

  const basicSyllables = [
    'ka', 'ki', 'ku', 'ke', 'ko', 'ga', 'gi', 'gu', 'ge', 'go',
    'sa', 'shi', 'su', 'se', 'so', 'za', 'ji', 'zu', 'ze', 'zo',
    'ta', 'chi', 'tsu', 'te', 'to', 'da', 'ji', 'zu', 'de', 'do',
    'na', 'ni', 'nu', 'ne', 'no',
    'ha', 'hi', 'fu', 'he', 'ho', 'ba', 'bi', 'bu', 'be', 'bo', 'pa', 'pi', 'pu', 'pe', 'po',
    'ma', 'mi', 'mu', 'me', 'mo',
    'ya', 'yu', 'yo',
    'ra', 'ri', 'ru', 're', 'ro',
    'wa', 'wi', 'we', 'wo', 'n'
  ];

  const vowels = ['a', 'i', 'u', 'e', 'o'];

  const allSyllables = [...specialSyllables, ...basicSyllables, ...vowels];

  const segments = [];
  let remaining = romaji.toLowerCase();
  
  while (remaining.length > 0) {
    let found = false;
    
    // Essayer les syllabes les plus longues d'abord
    for (const syllable of allSyllables.sort((a, b) => b.length - a.length)) {
      if (remaining.startsWith(syllable)) {
        segments.push(syllable);
        remaining = remaining.slice(syllable.length);
        found = true;
        break;
      }
    }
    
    // Fallback : prendre 2 caractères si possible (consonne + voyelle), sinon 1
    if (!found) {
      if (remaining.length >= 2 && !vowels.includes(remaining[0])) { // Si commence par consonne
        segments.push(remaining.slice(0, 2));
        remaining = remaining.slice(2);
      } else {
        segments.push(remaining[0]);
        remaining = remaining.slice(1);
      }
    }
  }
  
  return segments.length > 0 ? segments : [romaji];
}
  
  
  
function logError(msg) {
console.warn(msg);
}
function updateRevisionButtonState() {
  const revisionButton = document.getElementById('revision-button');
  if (!revisionButton) return;
  
  if (isRevisionModeAvailable()) {
    revisionButton.classList.remove('disabled');
    revisionButton.onclick = () => showSection('mode2');
    revisionButton.title = '';
  } else {
    revisionButton.classList.add('disabled');
    revisionButton.onclick = (e) => {
      e.preventDefault();
      // Optionnel : afficher un message
      console.log('Mode révision disponible à partir du niveau 4');
    };
    revisionButton.title = 'Disponible à partir du niveau 4';
  }
}

function testFeu() {
const container = document.querySelector('.quiz-container');
if (isMobile) {
triggerLightFirework(container);
} else {
triggerAdvancedFirework(container);
}
}

function triggerSakuraFall(container) {
for (let i = 0; i < 30; i++) {
const sakura = document.createElement("div");
sakura.className = "sakura";
sakura.style.left = Math.random() * 100 + "vw";
sakura.style.top = "-10px";
sakura.style.animationDelay = Math.random() * 1.5 + "s";
sakura.style.animationDuration = 2.5 + Math.random() * 1.5 + "s";
document.body.appendChild(sakura);
setTimeout(() => sakura.remove(), 4000);
}


}


// 🎯 GESTIONNAIRE DE PARTICULES OPTIMISÉ
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
const MAX_ACTIVE_PARTICLES = isMobile ? 15 : 30; // Limite stricte

// Fonction de nettoyage des particules
function cleanupOldParticles() {
// Supprimer les particules les plus anciennes si on dépasse la limite
while (activeSparks.length > MAX_ACTIVE_PARTICLES) {
const oldSpark = activeSparks.shift();
if (oldSpark && oldSpark.canvas && oldSpark.canvas.parentNode) {
oldSpark.canvas.remove();
globalParticleCount--;
}
}
// Nettoyer les particules orphelines
activeSparks = activeSparks.filter(spark => {
if (!spark.canvas || !spark.canvas.parentNode) {
globalParticleCount--;
return false;
}
return true;
});
console.log(`🧹 Nettoyage: ${activeSparks.length} particules actives, ${globalParticleCount} compteur global`);
}

// Nettoyage automatique toutes les 3 secondes
setInterval(cleanupOldParticles, 3000);

// Audio
let audioContext;
let audioInitialized = false;

function initAudio() {
try {
if (!audioInitialized) {
audioContext = new (window.AudioContext || window.webkitAudioContext)();
audioInitialized = true;
}
} catch (error) {
console.error("Erreur lors de l'initialisation audio:", error.message);
}
}

function getValidatedCountForLevel(level) {
return HiraganaList.filter(h => parseInt(h.Niveau) === level && parseInt(h.Validation) >= 5).length;
}
function playPopSound() {
  initAudio();
  try {
    const osc = audioContext.createOscillator();
    const gain = audioContext.createGain();
    osc.connect(gain);
    gain.connect(audioContext.destination);
    osc.type = 'sine';
    osc.frequency.value = 1000; // Son aigu pour "pop"
    gain.gain.setValueAtTime(0.05, audioContext.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
    osc.start();
    osc.stop(audioContext.currentTime + 0.1);
  } catch (error) {
    logError('Erreur son pop: ' + error.message);
  }
}
function playMarioCoin() {
initAudio();
const notes = [659.25, 1046.50];
const durations = [0.1, 0.2];
notes.forEach((freq, i) => {
setTimeout(() => {
const osc = audioContext.createOscillator();
const gain = audioContext.createGain();
osc.connect(gain);
gain.connect(audioContext.destination);
osc.type = 'sine';
osc.frequency.value = freq;
gain.gain.setValueAtTime(0.05, audioContext.currentTime);
gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + durations[i]);
osc.start();
osc.stop(audioContext.currentTime + durations[i]);
}, i * 100);
});
}

function playSuccess90s() {
initAudio();
const baseFreq = 587.33;
const osc1 = audioContext.createOscillator();
const gain1 = audioContext.createGain();
const osc2 = audioContext.createOscillator();
const gain2 = audioContext.createGain();
osc1.connect(gain1);
osc2.connect(gain2);
gain1.connect(audioContext.destination);
gain2.connect(audioContext.destination);
osc1.type = 'sine';
osc2.type = 'sine';
osc1.frequency.value = baseFreq;
osc2.frequency.setValueAtTime(baseFreq * 1.5, audioContext.currentTime);
osc2.frequency.exponentialRampToValueAtTime(baseFreq * 3, audioContext.currentTime + 0.3);
gain1.gain.setValueAtTime(0.03, audioContext.currentTime);
gain1.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
gain2.gain.setValueAtTime(0.01, audioContext.currentTime);
gain2.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
osc1.start();
osc2.start();
osc1.stop(audioContext.currentTime + 0.4);
osc2.stop(audioContext.currentTime + 0.3);
}

function playFail() {
initAudio();
const oscillator = audioContext.createOscillator();
const gainNode = audioContext.createGain();
oscillator.connect(gainNode);
gainNode.connect(audioContext.destination);
oscillator.type = 'sine';
gainNode.gain.setValueAtTime(0.04, audioContext.currentTime);
gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
oscillator.frequency.exponentialRampToValueAtTime(110, audioContext.currentTime + 0.4);
oscillator.start(audioContext.currentTime);
oscillator.stop(audioContext.currentTime + 0.4);
}

function playFireworkSound() {
initAudio();
try {
const frequencies = [329.63, 415.30, 523.25, 659.25];
frequencies.forEach((freq, i) => {
setTimeout(() => {
const osc = audioContext.createOscillator();
const gain = audioContext.createGain();
const filter = audioContext.createBiquadFilter();
osc.connect(filter);
filter.connect(gain);
gain.connect(audioContext.destination);
osc.type = 'triangle';
osc.frequency.value = freq;
filter.type = 'lowpass';
filter.frequency.value = freq * 2;
gain.gain.setValueAtTime(0.03, audioContext.currentTime);
gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
osc.start();
osc.stop(audioContext.currentTime + 0.4);
}, i * 150);
});
} catch (error) {
logError('Erreur Firework: ' + error.message);
}
}

function playfireworksound2() {
initAudio();
try {
const sequence = [554.37, 659.25, 830.61, 987.77];
sequence.forEach((freq, i) => {
setTimeout(() => {
const osc = audioContext.createOscillator();
const gain = audioContext.createGain();
osc.connect(gain);
gain.connect(audioContext.destination);
osc.type = 'sine';
osc.frequency.value = freq;
gain.gain.setValueAtTime(0.035, audioContext.currentTime);
gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
osc.start();
osc.stop(audioContext.currentTime + 0.2);
}, i * 100);
});
} catch (error) {
logError('Erreur fireworksound 2: ' + error.message);
}
}

function playfireworksound3() {
initAudio();
try {
const sequence = [659.25, 783.99, 987.77, 1174.66];
sequence.forEach((freq, i) => {
setTimeout(() => {
const osc = audioContext.createOscillator();
const gain = audioContext.createGain();
osc.connect(gain);
gain.connect(audioContext.destination);
osc.type = 'sine';
osc.frequency.value = freq;
gain.gain.setValueAtTime(0.035, audioContext.currentTime);
gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
osc.start();
osc.stop(audioContext.currentTime + 0.2);
}, i * 100);
});
} catch (error) {
logError('Erreur fireworksound 3: ' + error.message);
}
}

function playfireworksound4() {
initAudio();
try {
const sequence = [783.99, 987.77, 1174.66, 1396.91];
sequence.forEach((freq, i) => {
setTimeout(() => {
const osc = audioContext.createOscillator();
const gain = audioContext.createGain();
osc.connect(gain);
gain.connect(audioContext.destination);
osc.type = 'sine';
osc.frequency.value = freq;
gain.gain.setValueAtTime(0.035, audioContext.currentTime);
gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
osc.start();
osc.stop(audioContext.currentTime + 0.2);
}, i * 100);
});
} catch (error) {
logError('Erreur fireworksound 4: ' + error.message);
}
}

function playLevelUp() {
initAudio();
try {
const sequence = [523.25, 659.25, 783.99, 1046.50];
const flourish = [783.99, 1046.50, 1318.51];
sequence.forEach((freq, i) => {
setTimeout(() => {
const osc = audioContext.createOscillator();
const gain = audioContext.createGain();
osc.connect(gain);
gain.connect(audioContext.destination);
osc.type = 'sine';
osc.frequency.value = freq;
gain.gain.setValueAtTime(0.04, audioContext.currentTime);
gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.12);
osc.start();
osc.stop(audioContext.currentTime + 0.12);
}, i * 120);
});
flourish.forEach((freq, i) => {
setTimeout(() => {
const osc = audioContext.createOscillator();
const gain = audioContext.createGain();
osc.connect(gain);
gain.connect(audioContext.destination);
osc.type = 'sine';
osc.frequency.value = freq;
gain.gain.setValueAtTime(0.04, audioContext.currentTime);
gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
osc.start();
osc.stop(audioContext.currentTime + 0.1);
}, 480 + i * 100);
});
setTimeout(() => {
const osc = audioContext.createOscillator();
const gain = audioContext.createGain();
const mod = audioContext.createOscillator();
const modGain = audioContext.createGain();
mod.connect(modGain);
modGain.connect(osc.frequency);
osc.connect(gain);
gain.connect(audioContext.destination);
osc.type = 'sine';
mod.type = 'sine';
osc.frequency.value = 1318.51;
mod.frequency.value = 5;
modGain.gain.value = 10;
gain.gain.setValueAtTime(0.04, audioContext.currentTime);
gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 2.0);
osc.start();
mod.start();
osc.stop(audioContext.currentTime + 2.0);
mod.stop(audioContext.currentTime + 2.0);
}, 780);
} catch (error) {
logError('Erreur Level Up: ' + error.message);
}
}

// Son pour réponses correctes : Clochette zen
function playZenBell() {
  const oscillator = audioCtx.createOscillator();
  const gainNode = audioCtx.createGain();
  
  oscillator.connect(gainNode);
  gainNode.connect(audioCtx.destination);
  
  // Fréquences cristallines
  const frequencies = [1047, 1319, 1568, 1760]; // C6, E6, G6, A6
  oscillator.frequency.setValueAtTime(
    frequencies[Math.floor(Math.random() * frequencies.length)], 
    audioCtx.currentTime
  );
  oscillator.type = 'sine';
  
  // Enveloppe rapide comme une goutte
  gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
  gainNode.gain.linearRampToValueAtTime((typeof globalVolume !== 'undefined' ? globalVolume : 1) * 0.3, audioCtx.currentTime + 0.01);
  gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
  
  oscillator.start(audioCtx.currentTime);
  oscillator.stop(audioCtx.currentTime + 0.3);
  console.log('🎶 Son joué : Goutte cristalline (fréquence aléatoire, 0.3s)');
}
// Son pour réponses incorrectes : Bip atténué
function playSoftError() {
  const oscillator = audioCtx.createOscillator();
  const gainNode = audioCtx.createGain();
  oscillator.connect(gainNode);
  gainNode.connect(audioCtx.destination);

  oscillator.type = 'triangle';
  oscillator.frequency.setValueAtTime(220, audioCtx.currentTime);
  gainNode.gain.setValueAtTime(0.4, audioCtx.currentTime);
  gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);

  oscillator.start();
  oscillator.stop(audioCtx.currentTime + 0.4);
}
  
function drawStar(ctx, x, y, radius, rotation = 0) {
const points = 5;
const outerRadius = radius;
const innerRadius = radius / 2;
ctx.beginPath();
for (let i = 0; i < points * 2; i++) {
const r = i % 2 === 0 ? outerRadius : innerRadius;
const angle = (i * Math.PI / points) + rotation - Math.PI / 2;
ctx.lineTo(
x + r * Math.cos(angle),
y + r * Math.sin(angle)
);
}
ctx.closePath();
ctx.fill();
}

function triggerAdvancedFirework(container) {
initAudio();
const validatedCount = getValidatedCountForLevel(niveauActif);
const canvas = document.createElement('canvas');
canvas.style.position = 'absolute';
canvas.style.left = '50%';
canvas.style.top = '50%';
canvas.style.transform = 'translate(-50%, -50%)';
canvas.style.pointerEvents = 'none';
canvas.style.zIndex = '20';
canvas.width = 400;
canvas.height = 400;
container.appendChild(canvas);
const ctx = canvas.getContext('2d');

const colorPalettes = [
['#6B8E23', '#9ACD32', '#32CD32', '#228B22', '#008000', '#006400'], // Palette verte
['#A8D5BA', '#76FF03', '#64DD17', '#00C853', '#AEEA00', '#00E676'],
['#FDC1C5', '#F48FB1', '#EC407A', '#D81B60', '#AD1457', '#FF80AB'],
];
const colors = colorPalettes[Math.floor(Math.random() * colorPalettes.length)];

const maxLifeBase = isMobile ? 30 : 50;
const numParticles = isMobile ? 9 : 12;
const numSalvos = isMobile ? 3 : 3;
const gravity = 0.1;
const salvoDelay = 150;
const dispersionBase = 3;
const itemCount = getItemCountForLevel(niveauActif);
const particles = [];
const trails = [];

const halo = document.createElement('div');
halo.style.position = 'absolute';
halo.style.left = '50%';
halo.style.top = '50%';
halo.style.width = '20px';
halo.style.height = '20px';
halo.style.borderRadius = '50%';
halo.style.background = 'radial-gradient(circle, rgba(255,255,255,0.9), rgba(255,255,255,0.05))';
halo.style.transform = 'translate(-50%, -50%) scale(1)';
halo.style.opacity = '1';
halo.style.zIndex = '0';
halo.style.pointerEvents = 'none';
container.appendChild(halo);
halo.animate([
{ transform: 'translate(-50%, -50%) scale(1)', opacity: 1 },
{ transform: 'translate(-50%, -50%) scale(6)', opacity: 0 }
], {
duration: 700,
easing: 'ease-out'
}).onfinish = () => halo.remove();

console.log("🎯 nbre d'items dans le niveau =", itemCount, "niveau =", niveauActif);
console.log("🎯 nbre d'items validés =", validatedCount, "niveau =", niveauActif);  
if (validatedCount === itemCount-1) {
  playLevelUp();
  triggerLevelUpAnimation(document.body);
} else if (validatedCount === 3) {
playfireworksound4();
} else if (validatedCount === 2) {
playfireworksound3();
} else if (validatedCount === 1) {
playfireworksound2();
} else if (validatedCount === 0) {
playFireworkSound();
}

for (let salvo = 0; salvo < numSalvos; salvo++) {
setTimeout(() => {
if (activeSparks.length >= MAX_ACTIVE_PARTICLES) {
console.warn(`⚠️ Salvo ${salvo} annulée - limite atteinte`);
return;
}

const biasDirection = Math.random() < 0.5 ? -1 : 1;
const biasMagnitude = (Math.random() * 0.2 - 0.1) * biasDirection;

for (let i = 0; i < numParticles; i++) {
if (activeSparks.length >= MAX_ACTIVE_PARTICLES) {
console.warn(`🛑 Particule ${i} du salvo ${salvo} ignorée - limite atteinte`);
break;
}

const angleOffset = (Math.random() * 10 - 5) * (Math.PI / 180);
const angle = angleOffset + (i * (360 / numParticles)) * (Math.PI / 180);
const isUpward = (angle >= 3 * Math.PI / 2 || angle <= Math.PI / 2);
let speed = dispersionBase + Math.random() * 3;
if (isUpward) {
speed = Math.max(7, speed);
if ((angle >= 3 * Math.PI / 2 && biasDirection === -1) || (angle <= Math.PI / 2 && biasDirection === 1)) {
speed *= (1 + biasMagnitude);
}
}

const v0x = speed * Math.cos(angle);
const v0y = speed * Math.sin(angle) * -1;
const color = colors[Math.floor(Math.random() * colors.length)];

particles.push({
x: canvas.width / 2,
y: canvas.height / 2,
vx: v0x,
vy: v0y,
life: maxLifeBase + Math.random() * 20,
maxLife: maxLifeBase + Math.random() * 20,
color: color,
rotation: Math.random() * Math.PI * 2
});
activeSparks.push({ canvas });
globalParticleCount++;
console.log(`Particule ajoutée: ${particles.length} particules, ${activeSparks.length} sparks`);
}
}, salvo * salvoDelay);
}

function animate() {
ctx.clearRect(0, 0, canvas.width, canvas.height);

if (!isMobile) {
particles.forEach(p => {
if (Math.random() < 0.2) {
trails.push({
x: p.x,
y: p.y,
color: p.color,
life: 10
});
}
});
}

trails.forEach((t, i) => {
t.life--;
if (t.life <= 0) {
trails.splice(i, 1);
return;
}
ctx.fillStyle = t.color;
ctx.globalAlpha = t.life / 10 * 0.3;
ctx.beginPath();
ctx.arc(t.x, t.y, isMobile ? 2 : 3, 0, 2 * Math.PI);
ctx.fill();
});

particles.forEach((p, i) => {
p.x += p.vx;
p.y += p.vy;
p.vy += gravity;
p.life--;
p.rotation += 0.05;
if (p.life <= 0) {
particles.splice(i, 1);
activeSparks.splice(i, 1);
globalParticleCount--;
return;
}
ctx.fillStyle = p.color;
ctx.globalAlpha = Math.max(0, p.life / p.maxLife);
ctx.save();
ctx.translate(p.x, p.y);
drawStar(ctx, 0, 0, isMobile ? 4 : 6, p.rotation);
ctx.restore();
});

if (particles.length > 0 || Date.now() < Date.now() + numSalvos * salvoDelay) {
requestAnimationFrame(animate);
} else {
canvas.remove();
activeSparks = activeSparks.filter(spark => spark.canvas !== canvas);
globalParticleCount = Math.max(0, globalParticleCount - particles.length);
console.log('Animation terminée');
}
}
requestAnimationFrame(animate);
}
/*
function cleanupOldParticles() {
while (activeSparks.length > MAX_ACTIVE_PARTICLES) {
const oldSpark = activeSparks.shift();
if (oldSpark && oldSpark.canvas && oldSpark.canvas.parentNode) {
oldSpark.canvas.remove();
globalParticleCount--;
}
}
activeSparks = activeSparks.filter(spark => {
if (!spark.canvas || !spark.canvas.parentNode) {
globalParticleCount--;
return false;
}
return true;
});
console.log(`🧹 Nettoyage: ${activeSparks.length} particules actives, ${globalParticleCount} compteur global`);
}

setInterval(cleanupOldParticles, 3000);

const MAX_ACTIVE_PARTICLES = isMobile ? 15 : 30;
*/
function getMaxLevel(list) {
if (!list || list.length === 0) return 1;
return Math.max(...list.map(k => parseInt(k.Niveau) || 1));
}

function updateStarsForHiragana(hiraganaId, newValidation) {
const cards = document.querySelectorAll('.hiragana-card');
cards.forEach(card => {
const hiraganaChar = card.querySelector('.hiragana-char').textContent;
const hiragana = HiraganaList.find(h => h.Hiragana === hiraganaChar && h.ID == hiraganaId);
if (hiragana) {
const stars = card.querySelectorAll('.star');
const previousValidation = previousValidationStates.get(hiraganaId) || 0;

stars.forEach((star, index) => {
if (index < newValidation && !star.classList.contains('filled')) {
star.classList.add('filled', 'new-star');
setTimeout(() => star.classList.remove('new-star'), 500);
} else if (index < newValidation) {
star.classList.add('filled');
} else {
star.classList.remove('filled', 'new-star');
}
});

if (newValidation >= 5 && previousValidation < 5) {
if (isMobile) {
triggerLightFirework(card);
} else {
triggerAdvancedFirework(card);
}
}

if (newValidation >= 5) {
card.classList.add('completed');
} else {
card.classList.remove('completed');
}

previousValidationStates.set(hiraganaId, newValidation);
}
});
}

function renderHiraganaCards(list, niveau) {
const container = document.getElementById("hiraganaCards");
if (!container) return;
const hiraganas = list.filter(h => parseInt(h.Niveau) === niveau);
container.innerHTML = "";
hiraganas.forEach(hiragana => {
const validation = parseInt(hiragana.Validation || 0);
const isCompleted = validation >= 5;
const card = document.createElement("div");
card.className = `hiragana-card ${isCompleted ? 'completed' : ''}`;
card.innerHTML = `
<div class="hiragana-char">${hiragana.Hiragana}</div>
<div class="stars-container">
${Array.from({length: 5}, (_, i) =>
`<div class="star ${i < validation ? 'filled' : ''}"></div>`
).join('')}
</div>
`;
container.appendChild(card);
previousValidationStates.set(parseInt(hiragana.ID), validation);
});
}

function renderProgressBar(currentLevel, maxLevel) {
const container = document.getElementById("progressBarContainer");
if (!container) return;

container.innerHTML = "";

const leftEmoji = document.createElement("span");
leftEmoji.textContent = "🌱";
leftEmoji.className = "side-emoji";

const rightEmoji = document.createElement("span");
rightEmoji.textContent = "🌳";
rightEmoji.className = "side-emoji";

const barTrack = document.createElement("div");
barTrack.className = "progress-bar-track";

const marker = document.createElement("div");
marker.className = "progress-marker";
marker.innerText = "🐼";  /*  🐼 🐱💩🤡🐶🐯🐱 */

const pct = maxLevel > 1 ? ((currentLevel - 1) / (maxLevel - 1)) * 100 : 0;
marker.style.left = `${Math.min(100, Math.max(0, pct))}%`;

barTrack.appendChild(marker);
container.appendChild(leftEmoji);
container.appendChild(barTrack);
container.appendChild(rightEmoji);
}

function determineNiveauActif(list) {
  if (!list || list.length === 0) return 1;
  let maxNiveau = Math.max(...list.map(k => parseInt(k.Niveau) || 1));

  for (let n = 1; n <= maxNiveau; n++) {
    const groupeActuel = getNiveauGroupe(n);
    
    // Vérifier si le groupe est bloqué (à partir du groupe 3)
    if (groupeActuel >= 3 && !isGroupeDebloque(groupeActuel)) {
      return n;
    }
    
    const kanjisNiveau = list.filter(k => parseInt(k.Niveau) === n);
    const kanjisValides = kanjisNiveau.filter(k => parseInt(k.Validation) >= 5);
    if (kanjisValides.length < kanjisNiveau.length) {
      return n;
    }
  }
  return maxNiveau;
}
function updateApprendreButtonState() {
  const apprendreButton = document.querySelector('button[onclick="showSection(\'quiz\')"]');
  if (!apprendreButton) return;
  
  if (isApprentissageBloque()) {
    apprendreButton.classList.add('disabled');
    // Complètement bloquer le clic
    apprendreButton.onclick = (e) => {
      e.preventDefault();
      e.stopPropagation();
      // Optionnel : feedback visuel ou sonore pour indiquer que c'est bloqué
      console.log('Mode apprentissage bloqué - utilisez le mode révision');
      return false;
    };
    apprendreButton.title = 'Mode bloqué - Pratiquez le mode révision pour débloquer';
    apprendreButton.style.opacity = '0.5';
    apprendreButton.style.cursor = 'not-allowed';
  } else {
    apprendreButton.classList.remove('disabled');
    apprendreButton.onclick = () => showSection('quiz');
    apprendreButton.title = '';
    apprendreButton.style.opacity = '1';
    apprendreButton.style.cursor = 'pointer';
  }
}
function updateMenuButtonStates() {
  updateApprendreButtonState();
  updateRevisionButtonState();
}  
function updateLevelProgress(list, niveau) {
renderHiraganaCards(list, niveau);
}

// Initialisation avec  Apps Script
// *** NOUVELLE URL DE VOTRE WEB APP  ***
  const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbwI1_UA70pdmkWOXfzyNm-wNoUrXHBz1GPvveCmdLYnmduKIU6G8nxAX8_cHO8ThHL6cg/exec';
// const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycby1y-ThlFkq3WwR--BaPr8D4TlyQhoTdVVqSx3N87qbY9YzSwEWDn3YvjRLwo8ABbYk5g/exec';

// Fonction pour appeler l'API
async function callAPI(action, data = null) {
  try {
    let params = new URLSearchParams({ action });

    if (data) {
      Object.entries(data).forEach(([key, value]) => {
        params.append(key, value);
      });
    }

    const url = `${WEB_APP_URL}?${params.toString()}`;
    console.log(`🔍 Appel API: ${action} -> ${url}`);

    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    const result = await response.json();
    console.log(`🔍 Réponse brute de ${action}:`, JSON.stringify(result, null, 2));
    return result;
  } catch (error) {
    logError(`Erreur API (${action}): ${error.message}`);
    console.error(`⚠️ Détails erreur:`, error);
    return { error: error.message };
  }
}
// Variable globale pour la table romaji
let revisionRomajiTable = {};

// Modifier votre fonction initGame existante
// Variable globale pour le chargement background
let backgroundLoadingInProgress = false;

async function initGame() {
  try {
    gameDataLoaded = false;
    console.log('🛠️ Initialisation du jeu avec chunking...');
    
    // Masquer le texte "Chargement..." classique
    document.getElementById("loadingText").style.display = "none";
    
    // Afficher la barre de progression
    const progressContainer = document.getElementById('loading-progress-container');
    progressContainer.style.display = 'block';
    
    // ==========================================
    // PHASE 1 : DÉTECTION PROFIL (0-15%)
    // ==========================================
    updateLoadingProgress(5, "Connexion au serveur...");
    
    const token = localStorage.getItem('userToken');
    const profileResult = await callAPI('getProfile', { token: token || '' });
    
    if (!profileResult.success) {
      throw new Error('Erreur détection profil');
    }
    
    const profile = profileResult.profile;
    console.log('👤 Profil détecté:', profile);
    updateLoadingProgress(15, "Profil détecté !");
    
    // ==========================================
    // PHASE 2 : CHARGEMENT PRIORITAIRE (15-60%)
    // ==========================================
    
    if (profile.isNew) {
      // 🆕 NEW USER : WordLists + Niveaux 1-3
      updateLoadingProgress(20, "Chargement des listes de mots...");
      const wordListsResult = await callAPI('getWordLists');
      if (wordListsResult.success) {
        // Stocker pour generatePseudo côté client si besoin
        localStorage.setItem('wordLists', JSON.stringify(wordListsResult.words));
        console.log(`📚 ${wordListsResult.count} mots chargés`);
      }
      
      updateLoadingProgress(35, "Chargement niveaux 1-3...");
      const chunk1Result = await callAPI('getHiraganaChunk', { startLevel: 1, endLevel: 3 });
      
      if (chunk1Result.success) {
        HiraganaList = chunk1Result.data.map(item => ({
          ...item,
          Validation: 0,
          Tentatives: 0,
          Réussites: 0
        }));
        console.log(`📊 Chunk 1: ${chunk1Result.count} items chargés (niveaux ${chunk1Result.startLevel}-${chunk1Result.endLevel})`);
      }
      
      updateLoadingProgress(60, "Prêt à jouer !");
      

 } else {
  // 🔁 RETURNING USER : Niveaux 1 à (niveau+2)
  const maxLevel = Math.min(profile.niveau + 2, profile.totalLevels);
  
  updateLoadingProgress(25, `Chargement niveaux 1-${maxLevel}...`);
  const chunkResult = await callAPI('getHiraganaChunk', { startLevel: 1, endLevel: maxLevel });
  
  if (chunkResult.success) {
    HiraganaList = chunkResult.data.map(item => ({
      ...item,
      Validation: 0,
      Tentatives: 0,
      Réussites: 0
    }));
    console.log(`📊 Chunk returning user: ${chunkResult.count} items chargés (niveaux ${chunkResult.startLevel}-${chunkResult.endLevel})`);
  }
  
  // ✅ CORRECTION : Initialiser userToken et currentUser AVANT loadUserProgress
  updateLoadingProgress(40, "Récupération de votre profil...");
  userToken = token;
  const userResult = await callAPI('getUserByToken', { token: token });
  if (userResult.success) {
    currentUser = userResult.user;
    console.log('👤 Utilisateur récupéré:', currentUser.pseudo);
  }
  
  // ✅ MAINTENANT loadUserProgress peut merger les stats
  updateLoadingProgress(50, "Chargement de vos statistiques...");
  await loadUserProgress(); // Merge stats_json dans HiraganaList
  
  updateLoadingProgress(60, "Profil chargé !");
}
    
    // ==========================================
    // PHASE 3 : INTERFACE JOUABLE (60-80%)
    // ==========================================
    updateLoadingProgress(70, "Initialisation de l'interface...");
    
    // Initialiser le système utilisateur
// ✅ Mettre à jour l'affichage du compte (pour new + returning)
if (currentUser) {
  updateAccountDisplay();
}
    
    // Déterminer niveau actif
    niveauActif = determineNiveauActif(HiraganaList);
    console.log(`🎮 Niveau actif calculé: ${niveauActif}`);
    
    // Initialiser l'UI
    document.getElementById("levelDisplay").innerText = `${t('quiz_level')} ${niveauActif}`;
    updateLevelProgress(HiraganaList, niveauActif);
    renderProgressBar(niveauActif, getMaxLevel(HiraganaList));
    renderHiraganaCards(HiraganaList, niveauActif);
    updateMenuButtonStates();
    
    updateLoadingProgress(80, "Presque prêt...");
    
    // ==========================================
    // PHASE 4 : CHARGEMENT BACKGROUND (80-100%)
    // ==========================================
    gameDataLoaded = true;
    updateLoadingProgress(90, "Finalisation...");
    
    // Afficher le panda et masquer la barre
    const panda = document.querySelector(".panda-logo");
    const loadingText = document.getElementById("loadingText");
    if (panda && loadingText) {
      panda.style.opacity = "1";
      panda.style.pointerEvents = "auto";
      loadingText.textContent = t('welcome_touch');
      loadingText.style.display = "block";
    }
    
    updateLoadingProgress(100, "Chargement terminé !");
    
    // Masquer la barre après 500ms
    setTimeout(() => {
      progressContainer.style.display = 'none';
    }, 500);
    
    console.log('✅ initGame terminé avec succès');
    
    // ==========================================
    // PHASE 5 : CHARGEMENT EN ARRIÈRE-PLAN
    // ==========================================
    loadRemainingDataInBackground(profile);
    
  } catch (error) {
    console.error('❌ Erreur dans initGame:', error.message);
    document.getElementById('loading-message').textContent = 'Erreur : ' + error.message;
    document.getElementById('loading-message').style.color = '#dc3545';
    gameDataLoaded = false;
  }
}

// Fonction helper pour mettre à jour la barre
function updateLoadingProgress(percent, message) {
  const fill = document.getElementById('loading-progress-fill');
  const msg = document.getElementById('loading-message');
  
  if (fill) fill.style.width = percent + '%';
  if (msg) msg.textContent = message;
  
  console.log(`📊 ${percent}% - ${message}`);
}

// Chargement en arrière-plan des données restantes
async function loadRemainingDataInBackground(profile) {
  if (backgroundLoadingInProgress) return;
  backgroundLoadingInProgress = true;
  
  console.log('🔄 Démarrage chargement background...');
  
  try {
    if (profile.isNew) {
      // Charger niveaux 4-46 par paquets de 10
      for (let start = 4; start <= profile.totalLevels; start += 10) {
        const end = Math.min(start + 9, profile.totalLevels);
        console.log(`📥 Background: chargement niveaux ${start}-${end}...`);
        
        const chunkResult = await callAPI('getHiraganaChunk', { startLevel: start, endLevel: end });
        
        if (chunkResult.success) {
          // Merger avec HiraganaList existante
          const newItems = chunkResult.data.map(item => ({
            ...item,
            Validation: 0,
            Tentatives: 0,
            Réussites: 0
          }));
          
          HiraganaList.push(...newItems);
          console.log(`✅ Background: ${newItems.length} items ajoutés (total: ${HiraganaList.length})`);
        }
        
        // Petit délai pour ne pas surcharger
        await new Promise(resolve => setTimeout(resolve, 200));
      }
      
    } else {
      // Charger le reste des niveaux + WordLists (cas changement appareil)
      const currentMax = Math.min(profile.niveau + 2, profile.totalLevels);
      
      if (currentMax < profile.totalLevels) {
        console.log(`📥 Background: chargement niveaux ${currentMax + 1}-${profile.totalLevels}...`);
        
        const chunkResult = await callAPI('getHiraganaChunk', { 
          startLevel: currentMax + 1, 
          endLevel: profile.totalLevels 
        });
        
        if (chunkResult.success) {
          const newItems = chunkResult.data.map(item => ({
            ...item,
            Validation: 0,
            Tentatives: 0,
            Réussites: 0
          }));
          
          HiraganaList.push(...newItems);
          console.log(`✅ Background: ${newItems.length} items ajoutés (total: ${HiraganaList.length})`);
        }
      }
      
      // Charger WordLists pour futur changement d'appareil
      console.log('📥 Background: chargement WordLists...');
      const wordListsResult = await callAPI('getWordLists');
      if (wordListsResult.success) {
        localStorage.setItem('wordLists', JSON.stringify(wordListsResult.words));
        console.log(`✅ Background: ${wordListsResult.count} mots stockés`);
      }
    }
    
    // Régénérer les tables de révision avec toutes les données
    revisionRomajiTable = generateRevisionRomajiTable(HiraganaList);
    revisionKatakanaTable = generateRevisionKatakanaTable(HiraganaList);
    console.log(`📚 Tables régénérées: Romaji=${Object.keys(revisionRomajiTable).length}, Katakana=${Object.keys(revisionKatakanaTable).length}`);
    
    console.log('✅ Chargement background terminé !');
    
  } catch (error) {
    console.error('❌ Erreur chargement background:', error.message);
  } finally {
    backgroundLoadingInProgress = false;
  }
}
function nextQuestion() {
document.getElementById("result").innerText = "";
document.getElementById("continueBtn").style.visibility = "hidden";
selections = { first: null, second: null };
isAnswered = false;

const kanas = HiraganaList.filter(k =>
parseInt(k.Niveau) === niveauActif && parseInt(k.Validation || 0) < 5
);

if (kanas.length === 0) {
const nouveauNiveau = determineNiveauActif(HiraganaList);
if (nouveauNiveau !== niveauActif) {

const ancienGroupe = getNiveauGroupe(niveauActif);
const nouveauGroupe = getNiveauGroupe(nouveauNiveau);  
niveauActif = nouveauNiveau;  
document.getElementById("levelDisplay").innerText = `Niveau actuel : ${niveauActif}`;
renderProgressBar(niveauActif, getMaxLevel(HiraganaList));
updateLevelProgress(HiraganaList, niveauActif);
updateRevisionButtonState();  
updateApprendreButtonState(); // Nouvelle ligne  
// Ajouter ici
if (niveauActif === 4 && !hasShownLevel4Menu) {
    const menu = document.getElementById('menu');
    const menuMessage = document.getElementById('menu-message');
    menu.classList.add('active');
    menuMessage.innerText = '🎮 Mode révisions débloqué 🎮';
    hasShownLevel4Menu = true;
}
if (nouveauGroupe > ancienGroupe && nouveauGroupe >= 3 && isApprentissageBloque() && !hasShownBlockedMenu) {
  // Passer automatiquement en mode révision AVANT d'afficher le menu
  setTimeout(() => {
    forceRevisionMode();
    // Puis afficher le menu après un court délai
    setTimeout(() => {
      const menu = document.getElementById('menu');
      const menuMessage = document.getElementById('menu-message');
      menu.classList.add('active');
      menuMessage.innerText = 'Mode Apprendre bloqué';
      hasShownBlockedMenu = true;
    }, 500);
  }, 3000);
} 
nextQuestion();
return;
}
}

const finalKanas = kanas.length > 0 ? kanas : HiraganaList.filter(k => parseInt(k.Niveau) === niveauActif);

const currentWeights = finalKanas.map(k => {
const validation = parseInt(k.Validation || 0);
return Math.max(0.1, 5 - validation + 0.5);
});

let selected;
do {
const sum = currentWeights.reduce((a, b) => a + b, 0);
const rand = Math.random() * sum;
let acc = 0;
for (let i = 0; i < finalKanas.length; i++) {
acc += currentWeights[i];
if (rand < acc) {
selected = finalKanas[i];
break;
}
}
} while (selected === previousCharacter && finalKanas.length > 1); // Repeat if same as previous and more than one option exists

current = selected;
previousCharacter = current; // Update previous character

const modes = [
{ question: "Hiragana", options1: "Katakana", options2: "Romaji" },
{ question: "Katakana", options1: "Hiragana", options2: "Romaji" },
{ question: "Romaji", options1: "Hiragana", options2: "Katakana" }
];
const mode = modes[Math.floor(Math.random() * modes.length)];
targetFields = [mode.options1, mode.options2];

document.getElementById("question").innerText = (mode.question === 'Katakana') 
  ? getLocalizedKatakana(current) 
  : current[mode.question];
renderChoices("choices1", generateChoices(mode.options1), "first");
renderChoices("choices2", generateChoices(mode.options2), "second");
previousCharacter = current; // Met à jour après avoir défini current  
}

function generateChoices(field) {
const others = HiraganaList.filter(k => k !== current && parseInt(k.Niveau) === niveauActif);
    // ✅ NOUVEAU : Gérer les Katakana localisés
  const getValue = (item, fieldName) => {
    if (fieldName === 'Katakana') {
      return getLocalizedKatakana(item);
    }
    return item[fieldName];
  };
const values = [
  getValue(current, field), 
  ...others.sort(() => 0.5 - Math.random()).slice(0, 3).map(k => getValue(k, field))
];
return values.sort(() => 0.5 - Math.random());
}

function renderChoices(id, options, slot) {
const container = document.getElementById(id);
container.innerHTML = "";
options.forEach(text => {
const btn = document.createElement("button");
btn.innerText = text;
btn.className = "arcade-button";
btn.onclick = () => {
if (selections[slot] !== null || isAnswered) return;
selections[slot] = text;

// Ajouter l'effet de halo sans le retirer immédiatement
btn.classList.add("clicked-glow");

// Garder l'effet d'opacité pour les autres boutons
container.querySelectorAll("button").forEach(b => {
b.disabled = true;
if (b === btn) {
b.classList.add("clicked");
}
});
checkAnswer();
};
container.appendChild(btn);
});
}

// File d'attente globale pour les mises à jour API
// File d'attente globale pour les mises à jour API
let pendingUpdates = [];

async function queueUpdateStats(params) {
  pendingUpdates.push(params);
  if (pendingUpdates.length === 1) {
    while (pendingUpdates.length > 0) {
      const update = pendingUpdates[0];
      try {
        // ✅ Construire l'objet avec tous les paramètres nécessaires
        const apiParams = {
          token: update.token,
          id: update.id,
          scorePoints: update.scorePoints,
          isRevisionMode: update.isRevisionMode || false  // ✅ Ajouter ce paramètre
        };
        
        const result = await callAPI('updateStats', apiParams);
        
        if (result.success) {
          console.log(`✅ File: Stats synchronisées pour item ${update.id}: Validation=${result.newValidation}, NewLevel=${result.newLevel}`);
          const hiraganaIndex = HiraganaList.findIndex(h => h.ID == update.id);
          if (hiraganaIndex !== -1) {
            HiraganaList[hiraganaIndex].Validation = result.newValidation;
            HiraganaList[hiraganaIndex].Tentatives = (HiraganaList[hiraganaIndex].Tentatives || 0) + 1;
            HiraganaList[hiraganaIndex]['Réussites'] = (HiraganaList[hiraganaIndex]['Réussites'] || 0) + update.scorePoints;
            validationCache[update.id] = result.newValidation;
            console.log(`🔄 HiraganaList[${hiraganaIndex}] synchronisé avec serveur:`, HiraganaList[hiraganaIndex]);
          }
          if (result.newLevel && result.newLevel > niveauActif) {
            niveauActif = result.newLevel;
            console.log(`📈 Level up détecté (serveur): Niveau ${niveauActif}`);
            document.getElementById("levelDisplay").innerText = `${t('quiz_level')} ${niveauActif}`;
            updateLevelProgress(HiraganaList, niveauActif);
            renderProgressBar(niveauActif, getMaxLevel(HiraganaList));
            renderHiraganaCards(HiraganaList, niveauActif);
            updateMenuButtonStates();
            triggerLevelUpAnimation(document.body);
          }
        } else {
          console.error(`❌ File: Erreur API updateStats pour item ${update.id}: ${result.error}`);
        }
      } catch (error) {
        console.error(`❌ File: Erreur réseau updateStats pour item ${update.id}: ${error.message}`);
      }
      pendingUpdates.shift();
    }
  }
}
async function checkAnswer() {
  if (selections.first && selections.second && !isAnswered) {
    isAnswered = true;

    const getValue = (fieldName) => {
      if (fieldName === 'Katakana') {
        return getLocalizedKatakana(current);
      }
      return current[fieldName];
    };

    const correct1 = getValue(targetFields[0]);
    const correct2 = getValue(targetFields[1]);
    let score = 0;
    const containers = [document.getElementById("choices1"), document.getElementById("choices2")];
    const correctAnswers = [correct1, correct2];
    const userSelections = [selections.first, selections.second];

    containers.forEach(container => {
      container.querySelectorAll("button").forEach(btn => {
        btn.classList.remove("clicked-glow", "correct", "incorrect");
      });
    });

    containers.forEach((container, index) => {
      const buttons = container.querySelectorAll("button");
      buttons.forEach(btn => {
        if (btn.innerText === correctAnswers[index]) {
          btn.classList.add("correct");
          btn.disabled = true;
          if (btn.innerText === userSelections[index]) {
            score += 0.5;
            btn.classList.add("clicked");
          }
        } else if (btn.innerText === userSelections[index]) {
          btn.classList.add("incorrect");
          btn.disabled = true;
        } else {
          btn.disabled = true;
        }
      });
    });

    const currentValidation = parseInt(current.Validation || 0);
    let newValidation = currentValidation;
    if (score === 1) {
      newValidation = Math.min(5, currentValidation + 1);
    } else if (score === 0.5) {
      newValidation = Math.max(0, currentValidation - 1);
    } else {
      newValidation = Math.max(0, currentValidation - 2);
    }
    const isFinalValidation = score === 1 && currentValidation < 5 && newValidation >= 5;

    const currentItemId = parseInt(current.ID);
    console.log(`📝 Réponse pour item ${currentItemId} (score: ${score})`);

    updateStarsForHiragana(currentItemId, newValidation);
    const hiraganaIndex = HiraganaList.findIndex(h => h.ID == currentItemId);
    if (hiraganaIndex !== -1) {
      HiraganaList[hiraganaIndex].Validation = newValidation.toString();
      HiraganaList[hiraganaIndex].Tentatives = (HiraganaList[hiraganaIndex].Tentatives || 0) + 1;
      HiraganaList[hiraganaIndex]['Réussites'] = (HiraganaList[hiraganaIndex]['Réussites'] || 0) + score;
      validationCache[currentItemId] = newValidation;
      console.log(`🔄 HiraganaList[${hiraganaIndex}] mis à jour localement:`, HiraganaList[hiraganaIndex]);
    }

    let emoji = "", resultText = "";
    if (score === 1) {
      const emojisOK = ["🌸", "🎍", "🍵", "🪴", "💮", "🌺", "🌼", "🪷"];
      emoji = emojisOK[Math.floor(Math.random() * emojisOK.length)];
      resultText = isFinalValidation ? t('msg_validated') : t('msg_perfect');
      if (!isFinalValidation) {
        playMarioCoin();
      }
    } else if (score === 0.5) {
      const emojisMid = ["🪨", "🌿", "🪵", "🍃", "🌳", "🎋"];
      emoji = emojisMid[Math.floor(Math.random() * emojisMid.length)];
      resultText = t('msg_almost');
      playSuccess90s();
    } else {
      const emojisBad = ["🙈", "🙊", "🪨", "🌊", "🍂", "🍁"];
      emoji = emojisBad[Math.floor(Math.random() * emojisBad.length)];
      resultText = t('msg_notquite');
      playFail();
    }

    document.getElementById("result").innerHTML = `
      <div class="result-line">${emoji} ${resultText} ${emoji}</div>
      <div class="result-line highlight">
        👉 Bonne réponse : <strong>${correct1}</strong> – <strong>${correct2}</strong>
      </div>`;

    if (current && current.Hiragana) {
      const audioFile = `${encodeURIComponent(current.Hiragana)}.mp3`;
      const audioUrl = `https://emmanuel971-source.github.io/hirakataquizz/${audioFile}`;
      console.log("🎧 Lecture du son :", audioUrl);
      const audio = new Audio(audioUrl);
      audio.play().catch(e => console.warn("Erreur audio :", e));
    } else {
      console.warn("❗ Aucun Hiragana à prononcer.");
    }

    const previousNiveau = niveauActif;
    niveauActif = determineNiveauActif(HiraganaList);
    document.getElementById("levelDisplay").innerText = `${t('quiz_level')} ${niveauActif}`;
    updateLevelProgress(HiraganaList, niveauActif);
    renderProgressBar(niveauActif, getMaxLevel(HiraganaList));
    renderHiraganaCards(HiraganaList, niveauActif);
    updateMenuButtonStates();

    // Si level up local, déclencher l'animation
    if (niveauActif > previousNiveau) {
      triggerLevelUpAnimation(document.body);
    }

    queueUpdateStats({
      token: userToken,
      id: currentItemId,
      scorePoints: score,
      isRevisionMode: revisionMode.isActive
    });

    if (!revisionMode.isActive) {
      if (score === 1) {
        setTimeout(() => {
          nextQuestion();
        }, niveauActif > previousNiveau ? 4000 : 1500); // Attendre plus longtemps si level up
      } else {
        document.getElementById("continueBtn").style.visibility = "visible";
      }
    } else {
      document.getElementById("continueBtn").style.visibility = "visible";
    }
  }
}
function triggerLightFirework(card) {
const halo = document.createElement("div");
halo.style.position = "absolute";
halo.style.width = "30px";
halo.style.height = "30px";
halo.style.borderRadius = "50%";
halo.style.background = "radial-gradient(circle, rgba(253,193,197,0.9), rgba(253,193,197,0.1))";
halo.style.transform = "translate(-50%, -50%) scale(1)";
halo.style.opacity = "1";
halo.style.pointerEvents = "none";
halo.style.zIndex = "10";

const rect = card.getBoundingClientRect();
const cx = rect.left + rect.width / 2;
const cy = rect.top + rect.height / 2;

halo.style.left = `${cx}px`;
halo.style.top = `${cy}px`;
document.body.appendChild(halo);

halo.animate([
{ transform: "translate(-50%, -50%) scale(1)", opacity: 1 },
{ transform: "translate(-50%, -50%) scale(4)", opacity: 0 }
], {
duration: 800,
easing: "ease-out"
}).onfinish = () => halo.remove();

// Utiliser l'effet de chute de sakura depuis le haut de l'écran
for (let i = 0; i < 30; i++) {
const sakura = document.createElement("div");
sakura.className = "sakura";
sakura.style.left = Math.random() * 100 + "vw";
sakura.style.top = "-10px";
sakura.style.animationDelay = Math.random() * 1.5 + "s";
sakura.style.animationDuration = 2.5 + Math.random() * 1.5 + "s";
document.body.appendChild(sakura);
setTimeout(() => sakura.remove(), 4000);
}
const validatedCount = getValidatedCountForLevel(niveauActif);
const itemCount = getItemCountForLevel(niveauActif);
console.log("🎯 nbre d'items dans le niveau =", itemCount, "niveau =", niveauActif);
console.log("🎯 nbre d'items validés =", validatedCount, "niveau =", niveauActif);  


if (validatedCount === itemCount-1) {
  playLevelUp();
  triggerLevelUpAnimation(document.body);
} else if (validatedCount === 3) {
playfireworksound4();
} else if (validatedCount === 2) {
playfireworksound3();
} else if (validatedCount === 1) {
playfireworksound2();
} else if (validatedCount === 0) {
playFireworkSound();
}
 
}

function triggerLevelUpAnimation(container) {
const toHide = ['#question', '#choices1', '#choices2'];
toHide.forEach(id => {
const el = document.querySelector(id);
if (el) el.style.visibility = 'hidden';
});

triggerSakuraFall(container);

setTimeout(() => {
toHide.forEach(id => {
const el = document.querySelector(id);
if (el) {
el.style.visibility = 'visible';
el.style.opacity = 0;
el.animate([
{ opacity: 0 },
{ opacity: 1 }
], {
duration: 600,
fill: 'forwards'
});
}
});
}, 3000);

const msgWrapper = document.createElement("div");
msgWrapper.style.position = "fixed";
msgWrapper.style.top = "40%";
msgWrapper.style.left = "0";
msgWrapper.style.width = "100vw";
msgWrapper.style.textAlign = "center";
msgWrapper.style.zIndex = 9999;
msgWrapper.style.pointerEvents = "none";
document.body.appendChild(msgWrapper);

  const msg = document.createElement("div");
  msg.innerText = t('msg_level_up'); // ✅ MODIFIÉ
  msg.style.display = "inline-block";
msg.style.fontSize = "3em";
msg.style.fontWeight = "bold";
msg.style.color = "#8B6F47";
msg.style.textShadow = "0 0 20px #A8D5BA, 0 0 40px #FDC1C5";
msg.style.writingMode = "horizontal-tb";
msg.style.whiteSpace = "nowrap";
msgWrapper.appendChild(msg);

msg.animate([
{ transform: "translateY(0)", opacity: 1 },
{ transform: "translateY(-40px)", opacity: 0 }
], {
duration: 3000,
easing: "ease-out"
}).onfinish = () => msgWrapper.remove();

const marker = document.querySelector(".progress-marker");
if (marker) {
marker.animate([
{ transform: "translate(-50%, -50%) rotate(0deg) scale(1)" },
{ transform: "translate(-50%, -50%) rotate(180deg) scale(4)" },
{ transform: "translate(-50%, -50%) rotate(360deg) scale(1)" }
], {
duration: 1000,
easing: "ease-in-out"
});
}
}

function startRevisionQuestion() {


  const niveauActif = determineNiveauActif(HiraganaList);
  const excludedKatakanaLevels = [3, 5, 7, 10, 11, 12, 14, 16, 17, 21, 22, 24, 25, 27, 28, 30, 31, 32, 34, 35, 36, 37, 38];
  const hiraganaItems = HiraganaList.filter(h => 
    parseInt(h.Niveau || 1) < niveauActif && 
    revisionRomajiTable[h.Hiragana] &&
    h.Hiragana && h.Romaji
  );
  const katakanaItems = HiraganaList.filter(h => 
    parseInt(h.Niveau || 1) < niveauActif && 
    !excludedKatakanaLevels.includes(parseInt(h.Niveau || 1)) && 
    revisionKatakanaTable[h.Katakana] &&
    h.Katakana && h.Romaji
  );
  const availableItems = [
    ...hiraganaItems.map(item => ({ ...item, type: 'hiragana', key: item.Hiragana })), 
    ...katakanaItems.map(item => ({ ...item, type: 'katakana', key: getLocalizedKatakana(item) }))
  ];

  console.log(`🎯 Items disponibles pour révision: Hiragana=${hiraganaItems.length}, Katakana=${katakanaItems.length}`);

 if (availableItems.length === 0) {
    document.getElementById("revision-message").textContent = 
      niveauActif < 4 ? 
      t('revision_available_level4') :  // ✅ MODIFIÉ
      t('revision_no_items');            // ✅ MODIFIÉ
    document.getElementById("revision-message").style.color = "#dc3545";
    return;
  }

  // Tampon des 3 derniers tirages - convertir en numbers
  const recentItems = JSON.parse(localStorage.getItem('recentRevisionItems') || '[]').map(id => parseInt(id));

  let selectedItem;
  const RANDOM_RATIO = 0.2; // 20% pour tirage aléatoire pur

  if (Math.random() < RANDOM_RATIO) {
    // 🎲 TIRAGE ALÉATOIRE PUR (20%) - Filtré seulement par le tampon
    const randomItems = availableItems.filter(item => !recentItems.includes(parseInt(item.ID)));
    const finalRandomItems = randomItems.length >= 4 ? randomItems : availableItems;
    
    selectedItem = finalRandomItems[Math.floor(Math.random() * finalRandomItems.length)];
    
    console.log(`🎲 TIRAGE ALÉATOIRE (20%)`);
    console.log(`📋 Items disponibles pour tirage aléatoire: ${finalRandomItems.length}/${availableItems.length}`);
    console.log(`🔍 Items filtrés par tampon:`, finalRandomItems.map(item => `${item.key}(ID:${item.ID})`).join(', '));
    
  } else {
    // ⚖️ TIRAGE PONDÉRÉ (80%) - Filtré par Validation ≤ 10 + tampon
    const validationFilteredItems = availableItems.filter(item => (validationCache[parseInt(item.ID)] || 0) < seuilValidation);
    const weightedItems = validationFilteredItems.filter(item => !recentItems.includes(parseInt(item.ID)));
    
    let finalWeightedItems;
    
    if (weightedItems.length >= 4) {
      // Cas idéal : assez d'items respectant validation ≤ 10 ET hors tampon
      finalWeightedItems = weightedItems;
    } else if (weightedItems.length > 0) {
      // Peu d'items mais au moins quelques-uns : on les garde
      finalWeightedItems = weightedItems;
    } else {
      // Aucun item respectant les deux contraintes
      // PRIORITÉ : éviter le tampon (libérer contrainte validation ≤ 10)
      const itemsHorsTampon = availableItems.filter(item => !recentItems.includes(parseInt(item.ID)));
      if (itemsHorsTampon.length > 0) {
        finalWeightedItems = itemsHorsTampon;
        console.log(`⚠️ FALLBACK 1 - Libération contrainte Validation ≤ 10 pour éviter tampon`);
      } else {
        // Dernier recours : prendre tous les items (même dans le tampon)
        finalWeightedItems = availableItems;
        console.log(`⚠️ FALLBACK 2 - Tous les items utilisés (tampon ignoré)`);
      }
    }

    // Tirage pondéré sur les items finaux
    const weights = finalWeightedItems.map(item => {
      const stats = statsCache.items[parseInt(item.ID)] || { pourcentage: 0 };
      const pourcentage = stats.pourcentage;
      return pourcentage === 0 ? 50 : Math.min(50, Math.pow(100 / (pourcentage + 10), 2));
    });
    const totalWeight = weights.reduce((a, b) => a + b, 0);
    let random = Math.random() * totalWeight;
    for (let i = 0; i < finalWeightedItems.length; i++) {
      random -= weights[i];
      if (random <= 0) {
        selectedItem = finalWeightedItems[i];
        break;
      }
    }
    
    console.log(`⚖️ TIRAGE PONDÉRÉ (80%)`);
    console.log(`📋 Items disponibles (Validation ≤ 10 + tampon): ${finalWeightedItems.length}/${availableItems.length}`);
    console.log(`🔍 Items respectant Validation ≤ 10:`, 
      validationFilteredItems.map(item => `${item.key}(ID:${item.ID},Val:${validationCache[parseInt(item.ID)] || 0})`)
        .join(', '));
    console.log(`🚫 Items exclus par tampon:`, recentItems.join(', '));
    console.log(`✅ Items finaux pour pondération:`, 
      finalWeightedItems.map(item => `${item.key}(ID:${item.ID},Val:${validationCache[parseInt(item.ID)] || 0},${(statsCache.items[parseInt(item.ID)]?.pourcentage || 0).toFixed(1)}%)`)
        .join(', '));
  }

  // Mettre à jour le tampon - s'assurer que c'est un number
  recentItems.push(parseInt(selectedItem.ID));
  if (recentItems.length > 3) recentItems.shift(); // Garder seulement les 3 derniers
  localStorage.setItem('recentRevisionItems', JSON.stringify(recentItems));

  // Log pour vérification
  console.log(`🎯 Question sélectionnée: "${selectedItem.key}" (ID: ${selectedItem.ID}, Type: ${selectedItem.type})`);
  console.log(`🔍 Tampon récent:`, recentItems);

  // Configurer la question
  revisionMode.currentQuestion = selectedItem.key;
  const table = selectedItem.type === 'hiragana' ? revisionRomajiTable : revisionKatakanaTable;
  const tableEntry = table[selectedItem.key];
  revisionMode.romajiSegments = tableEntry.romaji;
  revisionMode.charCounts = tableEntry.charCounts;
  revisionMode.fullCorrect = revisionMode.romajiSegments.join("");
  revisionMode.currentItem = selectedItem;

  let cumRom = 0;
  revisionMode.cumulativeRomaji = revisionMode.romajiSegments.map(segment => {
    cumRom += segment.length;
    return cumRom;
  });
  let cumChar = 0;
  revisionMode.cumulativeChars = revisionMode.charCounts.map(count => {
    cumChar += count;
    return cumChar;
  });

  revisionMode.input = "";
  document.getElementById("revision-question").innerHTML = 
    revisionMode.currentQuestion.split("").map((char, index) => 
      `<div class="char-card" id="revision-card-${index}">
        <span id="revision-char-${index}">${char}</span>
      </div>`
    ).join("");
  document.getElementById("revision-input-display").textContent = "";
  document.getElementById("revision-message").textContent = "";

  const firstCard = document.getElementById(`revision-card-0`);
  if (firstCard) firstCard.classList.add("pulsing");

  console.log(`📝 Question: "${revisionMode.currentQuestion}" (${selectedItem.Romaji}) -> Attendu: "${revisionMode.fullCorrect}"`);
  console.log(`📊 Pourcentage item (ID ${selectedItem.ID}): ${(statsCache.items[parseInt(selectedItem.ID)]?.pourcentage || 0).toFixed(2)}% | Pourcentage global: ${statsCache.globalPourcentage.toFixed(2)}%`);
 // ✅ Afficher la barre à chaque nouvelle question (sans la recalculer)
  updateUnlockProgress();
}  
function isRevisionModeAvailable() {
  return niveauActif >= 4;
}  
function updateRevisionFeedback() {
  // Reset toutes les classes
  for (let i = 0; i < revisionMode.currentQuestion.length; i++) {
    const cardElement = document.getElementById(`revision-card-${i}`);
    const charElement = document.getElementById(`revision-char-${i}`);
    if (cardElement) {
      cardElement.classList.remove(
        "char-correct-1", "char-correct-2", "char-correct-3", "char-correct-4",
        "char-incorrect-1", "char-incorrect-2", "char-incorrect-3", "char-incorrect-4",
        "pulsing", "pop-animation"
      );
    }
    if (charElement) {
      charElement.classList.remove("pulsing");
    }
  }

  let currentSegment = -1;
  const inputLength = revisionMode.input.length;

  // Parcourir chaque segment
  for (let seg = 0; seg < revisionMode.romajiSegments.length; seg++) {
    const romStart = seg > 0 ? revisionMode.cumulativeRomaji[seg - 1] : 0;
    const romEnd = revisionMode.cumulativeRomaji[seg];
    const charStart = seg > 0 ? revisionMode.cumulativeChars[seg - 1] : 0;
    const charEnd = revisionMode.cumulativeChars[seg];
    const segmentLength = romEnd - romStart;
    const typedLen = Math.max(0, Math.min(inputLength - romStart, segmentLength));
    const typedSegment = revisionMode.input.substring(romStart, romStart + typedLen);
    const expected = revisionMode.romajiSegments[seg];
    let className = "";

    console.log(`Segment ${seg}: romStart=${romStart}, romEnd=${romEnd}, typedLen=${typedLen}, typedSegment="${typedSegment}", expected="${expected}"`);

    // Gradation basée sur la progression dans le segment
    if (typedLen > 0) {
      if (expected.startsWith(typedSegment)) {
        const level = Math.min(4, typedLen);
        className = `char-correct-${level}`;
      } else {
        const level = Math.min(4, typedLen);
        className = `char-incorrect-${level}`;
      }
    }

    // Appliquer la gradation aux cartes du segment
    for (let c = charStart; c < charEnd; c++) {
      const card = document.getElementById(`revision-card-${c}`);
      const span = document.getElementById(`revision-char-${c}`);
      if (card) {
        card.className = `char-card ${className || ""}`; // Appliquer la gradation
        // Ajouter animation "pop" et son si on valide un nouveau caractère
        if (inputLength > romStart && c === charStart && !card.classList.contains("pop-animation")) {
          card.classList.add("pop-animation");
          playPopSound();
          setTimeout(() => card.classList.remove("pop-animation"), 300);
        }
      }
    }

    // Validation finale uniquement pour le segment courant si entièrement saisi
    if (inputLength >= romEnd) {
      const fullSegment = revisionMode.input.substring(romStart, romEnd);
      if (fullSegment === expected) {
        for (let c = charStart; c < charEnd; c++) {
          const card = document.getElementById(`revision-card-${c}`);
          if (card) {
            card.classList.remove("pulsing");
            card.className = `char-card char-correct-4`;
          }
        }
      } else if (romStart < inputLength) { // Saisie incorrecte partielle
        for (let c = charStart; c < charEnd; c++) {
          const card = document.getElementById(`revision-card-${c}`);
          if (card) {
            card.classList.remove("pulsing");
            card.className = `char-card char-incorrect-4`;
          }
        }
      }
    }

    // Déterminer le segment en cours pour la pulsation
    if (romStart <= inputLength && inputLength < romEnd) {
      currentSegment = seg;
    }
  }

  // Ajouter la pulsation à la carte en cours
  if (currentSegment >= 0) {
    const charStart = currentSegment > 0 ? revisionMode.cumulativeChars[currentSegment - 1] : 0;
    const charEnd = revisionMode.cumulativeChars[currentSegment];
    for (let c = charStart; c < charEnd; c++) {
      const cardElement = document.getElementById(`revision-card-${c}`);
      if (cardElement) {
        cardElement.classList.add("pulsing");
      }
    }
  }

}
  
      
  
  
// Initialiser les événements du clavier de révision
// Initialiser les événements du clavier de révision
function initRevisionKeyboard() {
  const revisionKeys = document.querySelectorAll('.revision-key');
  revisionKeys.forEach(key => key.replaceWith(key.cloneNode(true)));
  const newRevisionKeys = document.querySelectorAll('.revision-key');

  newRevisionKeys.forEach(key => {
    key.addEventListener("click", async () => {  // ✅ ASYNC ajouté
      if (!revisionMode.isActive) return;

      if (key.id === "revision-back") {
        revisionMode.input = revisionMode.input.slice(0, -1);
      } else {
        revisionMode.input += key.textContent;
      }

      document.getElementById("revision-input-display").textContent = revisionMode.input;
      updateRevisionFeedback();

      const totalLength = revisionMode.cumulativeRomaji[revisionMode.cumulativeRomaji.length - 1] || 1;
      const hiraganaItem = HiraganaList.find(h => h.ID == revisionMode.currentItem.ID);
      const hiraganaChar = hiraganaItem ? hiraganaItem.Hiragana : revisionMode.currentQuestion;
      const niveau = parseInt(revisionMode.currentItem.Niveau || 1);
      const isHighLevel = niveau > 38;
      const isMultiChar = revisionMode.romajiSegments.length >= 2;
      const katakanaDisplay = (!isHighLevel && isMultiChar) ? ` (${getLocalizedKatakana(revisionMode.currentItem)})` : '';

    if (revisionMode.input.length >= totalLength) {
  const isCorrect = revisionMode.input === revisionMode.fullCorrect;
  const key = revisionMode.currentItem.ID;

  // Mettre à jour statsCache
  statsCache.items[key] = statsCache.items[key] || { tentatives: 0, reussites: 0, pourcentage: 0 };
  statsCache.items[key].tentatives += 1;
  statsCache.items[key].reussites += isCorrect ? 1 : 0;
  statsCache.items[key].pourcentage = statsCache.items[key].tentatives > 0 
    ? (statsCache.items[key].reussites / statsCache.items[key].tentatives * 100) : 0;

  // Mettre à jour pourcentage global
  const totalTentatives = Object.values(statsCache.items).reduce((sum, item) => sum + item.tentatives, 0);
  const totalReussites = Object.values(statsCache.items).reduce((sum, item) => sum + item.reussites, 0);
  statsCache.globalPourcentage = totalTentatives > 0 ? (totalReussites / totalTentatives * 100) : 0;

  console.log(`📊 Mise à jour pour "${revisionMode.currentQuestion}" (ID ${key}): Tentatives=${statsCache.items[key].tentatives}, Réussites=${statsCache.items[key].reussites}, Pourcentage=${statsCache.items[key].pourcentage.toFixed(2)}%`);
  console.log('📈 Pourcentage global:', statsCache.globalPourcentage.toFixed(2) + '%');

  // Modification de la validation en mode révision
  const hiraganaIndex = HiraganaList.findIndex(h => h.ID == revisionMode.currentItem.ID);
  if (hiraganaIndex !== -1) {
    const currentValidation = parseInt(HiraganaList[hiraganaIndex].Validation || 0);
    
    let newValidation;
    let pointsGagnes = 0;

    if (isCorrect) {
      newValidation = currentValidation + 1;
      if (currentValidation < seuilValidation) {
        pointsGagnes = 1;
      }
    } else {
      newValidation = Math.max(5, currentValidation - 2);
      const oldDeficit = Math.max(0, seuilValidation - currentValidation);
      const newDeficit = Math.max(0, seuilValidation - newValidation);
      pointsGagnes = oldDeficit - newDeficit;
    }

    HiraganaList[hiraganaIndex].Validation = newValidation.toString();
    validationCache[revisionMode.currentItem.ID] = newValidation;

    if (wasBlockedWhenEnteringRevision) {
      pointsGagnesEnRevision += pointsGagnes;
      console.log(`📊 Validation: ${currentValidation}→${newValidation} | Points cette question: ${pointsGagnes} | Total gagné: ${pointsGagnesEnRevision}/${deficitInitialRevision}`);
      updateUnlockProgress();
    }
    
    console.log(`🔒 Mode révision - Validation: ${newValidation} (était: ${currentValidation})`);
  }

  // ✅ Mettre en file d'attente l'appel API (en background, sans attendre)
  queueUpdateStats({
    token: userToken,
    id: parseInt(revisionMode.currentItem.ID),
    scorePoints: isCorrect ? 1 : 0,
    isRevisionMode: true
  });

  // Mettre à jour la barre de déblocage
  if (wasBlockedWhenEnteringRevision) {
    updateUnlockProgress();
  }

  // Afficher feedback
  if (isCorrect) {
    document.getElementById("revision-message").textContent = isHighLevel ? "OK" : `${katakanaDisplay}`;
    document.getElementById("revision-message").style.color = "#8B6F47";
    playZenBell();
  } else {
    document.getElementById("revision-message").textContent = isHighLevel 
      ? "Faux" 
      : `👉 Bonne réponse : ${revisionMode.fullCorrect}${katakanaDisplay}`;
    document.getElementById("revision-message").style.color = "#8B6F47";
    playSoftError();
  }

  // Jouer son MP3
  const audioFile = `${encodeURIComponent(hiraganaChar)}.mp3`;
  const audioUrl = `https://emmanuel971-source.github.io/hirakataquizz/${audioFile}`;
  const audio = new Audio(audioUrl);
  audio.play().catch(e => console.warn('Erreur audio:', e));

  setTimeout(() => {
    startRevisionQuestion();
  }, isCorrect ? 2000 : 3000);
}
    });
  });
}
  
// Appeler l'initialisation au chargement de la page
window.addEventListener('load', () => {
  initRevisionKeyboard();
});

  
  
  // Démarrage du jeu
window.onload = () => {
initGame();
updateAllTexts(); // ✅ AJOUTER CETTE LIGNE  
};
// S'assurer que les voix sont bien chargées
speechSynthesis.onvoiceschanged = () => {
console.log("📢 Voix disponibles :", speechSynthesis.getVoices());
};

</script>
  
</body>
<script>
document.addEventListener("DOMContentLoaded", () => {
  const panda = document.querySelector(".panda-logo");
  if (panda) {
   panda.addEventListener("click", () => {
  document.getElementById("welcome").classList.add("hidden");
  loadDifficulty();
  updateMenuMessage();
  updateApprendreButtonState();
  
  const menuBtn = document.querySelector(".hamburger");
  if (menuBtn) menuBtn.classList.remove("hidden");
  
  // Si pas de compte, afficher création de compte SANS ouvrir le menu
  if (!userToken || !currentUser) {
    showSection('create-account');
    generateNewPseudo(); // Générer le premier pseudo automatiquement
    // ✅ NE PAS ouvrir le menu automatiquement
  } else {
    // Utilisateur existant : afficher le menu
    const menu = document.querySelector(".menu");
    if (menu) menu.classList.add("active");
  }
  
  niveauActif = determineNiveauActif(HiraganaList);
  document.getElementById("levelDisplay").innerText = `Niveau actuel : ${niveauActif}`;
  updateLevelProgress(HiraganaList, niveauActif);
  renderProgressBar(niveauActif, getMaxLevel(HiraganaList));
  nextQuestion();      
  updateRevisionButtonState();
  updateApprendreButtonState();
});
  }
  
  updateAllTexts();
});
  document.addEventListener("DOMContentLoaded", () => {
  const panda = document.querySelector(".panda-logo");
  const menuBtn = document.querySelector(".hamburger");

  // Masquer le menu tant qu'on est sur l'accueil
  if (menuBtn) menuBtn.classList.add("hidden");

  // Désactiver le clic sur le panda tant que les données ne sont pas chargées
  panda.style.pointerEvents = "none"; 
  panda.style.opacity = "0.2"; // optionnel, pour indiquer que c'est inactif
});
</script>  
</html>








