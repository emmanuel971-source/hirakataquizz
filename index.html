<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hiragana Sensei - High Fidelity</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.3.1/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/speech-commands@0.4.0/dist/speech-commands.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', sans-serif; background: #1a1c2c; color: #333; display: flex; justify-content: center; align-items: center; min-height: 100vh; padding: 15px; }
        .container { background: white; border-radius: 25px; padding: 25px; max-width: 450px; width: 100%; text-align: center; box-shadow: 0 15px 40px rgba(0,0,0,0.4); }
        .target-char { font-size: 100px; font-weight: bold; margin: 10px 0; color: #2d3436; }
        .status { padding: 12px; border-radius: 12px; margin: 10px 0; font-weight: bold; background: #f1f2f6; }
        .recording { background: #ff4757; color: white; animation: pulse 1s infinite; }
        .success { background: #2ed573; color: white; }
        .mic-btn { width: 90px; height: 90px; border-radius: 50%; border: none; background: #667eea; color: white; font-size: 40px; cursor: pointer; margin: 15px 0; }
        .mic-btn:disabled { background: #ccc; }
        canvas { width: 100%; height: 50px; background: #f8f9fa; border-radius: 8px; margin-top: 10px; }
        .log-area { margin-top: 15px; font-size: 13px; text-align: left; max-height: 150px; overflow-y: auto; border-top: 1px solid #eee; padding-top: 10px; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
    </style>
</head>
<body>

<div class="container">
    <div style="display: flex; justify-content: space-between; font-weight: bold;">
        <span>Score: <span id="score">0</span></span>
        <span>Essai: <span id="attempt">0</span></span>
    </div>
    <div id="targetDisplay" class="target-char">?</div>
    <div id="status" class="status">Chargement...</div>
    
    <button id="micBtn" class="mic-btn" disabled>ðŸŽ¤</button>
    <p>Cliquez, dites l'hiragana, attendez l'analyse</p>
    
    <canvas id="vizCanvas"></canvas>
    
    <div class="log-area" id="logArea"><b>Historique :</b><br></div>
    <button onclick="exportCSV()" style="margin-top:10px; width:100%; padding:8px; border-radius:8px; border:none; background:#27ae60; color:white;">ðŸ“Š Exporter CSV</button>
</div>

<script>
 const MODEL_URL = "https://teachablemachine.withgoogle.com/models/ppaw5UWx4/";
    const HIRAGANAS = ['ã‚', 'ã„', 'ã†', 'ãˆ', 'ãŠ'];
    
    let recognizer;
    let currentTarget = "";
    let score = 0;
    let attempt = 0;
    let logs = [];
    // On force l'Ã©chantillonnage Ã  44100Hz
    let audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 44100 });

    async function init() {
        try {
            // FORCE LE MODE CPU (Ã©vite l'erreur WebGL)
            await tf.setBackend('cpu');
            
            recognizer = speechCommands.create("BROWSER_FFT", undefined, MODEL_URL + "model.json", MODEL_URL + "metadata.json");
            await recognizer.ensureModelLoaded();
            
            document.getElementById('status').innerText = "Sensei prÃªt (Mode CPU) !";
            document.getElementById('micBtn').disabled = false;
            nextQuestion();
        } catch (e) {
            document.getElementById('status').innerText = "Erreur : " + e.message;
        }
    }

    function nextQuestion() {
        currentTarget = HIRAGANAS[Math.floor(Math.random() * HIRAGANAS.length)];
        document.getElementById('targetDisplay').innerText = currentTarget;
        document.getElementById('status').innerText = "Ã€ vous !";
        document.getElementById('status').className = "status";
    }

    async function startCapture() {
        const btn = document.getElementById('micBtn');
        const status = document.getElementById('status');
        btn.disabled = true;
        status.innerText = "Ã‰COUTE...";
        status.className = "status recording";

        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const mediaRecorder = new MediaRecorder(stream);
            let chunks = [];

            mediaRecorder.ondataavailable = e => chunks.push(e.data);
mediaRecorder.onstop = async () => {
                const btn = document.getElementById('micBtn');
                const status = document.getElementById('status');
                
                const blob = new Blob(chunks);
                const arrayBuffer = await blob.arrayBuffer();
                const fullAudioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                
                try {
                    // TAILLE MAGIQUE RÃ‰CLAMÃ‰E PAR TON MODÃˆLE
                    const SAMPLES_EXPECTED = 9976; 
                    
                    // On extrait exactement 9976 Ã©chantillons
                    const rawData = fullAudioBuffer.getChannelData(0);
                    const truncatedData = new Float32Array(SAMPLES_EXPECTED);
                    
                    // On prend les donnÃ©es (ou on met du silence si trop court)
                    for (let i = 0; i < SAMPLES_EXPECTED; i++) {
                        truncatedData[i] = rawData[i] || 0;
                    }

                    drawWave(truncatedData);

                    // --- LE HACK ULTIME ---
                    // On transforme le son en "image" (Spectrogramme) manuellement
                    // pour satisfaire le Rank 4 [batch, height, width, channels]
                    // 9976 est souvent 43 colonnes x 232 frÃ©quences.
                    
                    const tensorReshaped = tf.tensor4d(truncatedData, [1, 43, 232, 1]);

                    // On utilise le modÃ¨le interne DIRECTEMENT sans passer par recognize()
                    const modelOutput = await recognizer.model.predict(tensorReshaped);
                    const scores = await modelOutput.data();
                    
                    // On formate le rÃ©sultat pour qu'il soit compatible avec notre fonction processResult
                    processResult({ scores: scores });

                    // Nettoyage mÃ©moire obligatoire pour Android
                    tensorReshaped.dispose();
                    modelOutput.dispose();

                } catch (err) {
                    console.error("Erreur de dimensionnement :", err);
                    // Si le 43x232 ne marche pas, on tente le format "Flat"
                    try {
                        const flatTensor = tf.tensor4d(truncatedData, [1, SAMPLES_EXPECTED, 1, 1]);
                        const modelOutput = await recognizer.model.predict(flatTensor);
                        processResult({ scores: await modelOutput.data() });
                        flatTensor.dispose();
                    } catch (err2) {
                        status.innerText = "Format incompatible : " + SAMPLES_EXPECTED;
                    }
                }
                
                btn.disabled = false;
                btn.classList.remove('active');
                stream.getTracks().forEach(t => t.stop());
            };

            mediaRecorder.start();
            // On enregistre un peu plus d'une seconde pour Ãªtre sÃ»r
            setTimeout(() => mediaRecorder.stop(), 1100); 

        } catch (err) {
            alert("Erreur : " + err);
            btn.disabled = false;
        }
    }

    function processResult(result) {
        const labels = recognizer.wordLabels();
        let maxScore = 0;
        let winner = "";

        for (let i = 0; i < labels.length; i++) {
            if (result.scores[i] > maxScore) {
                maxScore = result.scores[i];
                winner = labels[i];
            }
        }

        attempt++;
        document.getElementById('attempt').innerText = attempt;
        const confidence = Math.round(maxScore * 100);
        const isCorrect = (winner === currentTarget);

        if(isCorrect) {
            score++;
            document.getElementById('score').innerText = score;
            document.getElementById('status').innerText = "BRAVO ! (" + confidence + "%)";
            document.getElementById('status').className = "status success";
        } else {
            document.getElementById('status').innerText = "ENTENDU : " + winner + " (" + confidence + "%)";
            document.getElementById('status').className = "status";
        }

        logs.push({id: attempt, target: currentTarget, heard: winner, conf: confidence, ok: isCorrect});
        document.getElementById('logArea').innerHTML = `<b>NÂ°${attempt}:</b> ${currentTarget} -> ${winner} (${confidence}%)<br>` + document.getElementById('logArea').innerHTML;
        
        setTimeout(nextQuestion, 1500);
    }

    function drawWave(data) {
        const canvas = document.getElementById('vizCanvas');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = '#667eea';
        ctx.lineWidth = 1;
        ctx.beginPath();
        const step = Math.ceil(data.length / canvas.width);
        const amp = canvas.height / 2;
        for(let i=0; i<canvas.width; i++) {
            ctx.lineTo(i, amp + (data[i*step] * amp));
        }
        ctx.stroke();
    }

    function exportCSV() {
        let csv = "ID,Attendu,Entendu,Confiance,Resultat\n";
        logs.forEach(l => csv += `${l.id},${l.target},${l.heard},${l.conf}%,${l.ok?'OK':'KO'}\n`);
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'diagnostic.csv'; a.click();
    }

    document.getElementById('micBtn').onclick = startCapture;
    init(); 
    
</script>
</body>
</html>






