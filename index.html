<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" href="data:,">
<base target="_top">
<title>Hira-Kata-Quizzz Zen</title>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
<link rel="manifest" href="/manifest.json">
<style>
html, body {
margin: 0;
padding: 0;
height: 100%;
width: 100%;
overflow: hidden;
background: #F8F1E9; /* Blanc cassé, papier washi */
font-family: 'Noto Sans JP', sans-serif;
color: #8B6F47; /* Marron clair */
display: flex;
flex-direction: column;
align-items: center;
justify-content: start;
padding: 10px;
box-sizing: border-box;
}

body::before {
content: '';
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: url('https://www.transparenttextures.com/patterns/paper-fibers.png');
opacity: 0.1;
z-index: -1;
}

h1 {
margin: 0.5em 0;
font-size: 1.8em;
text-align: center;
color: #8B6F47;
text-shadow: 0 1px 2px rgba(139, 111, 71, 0.3);
}

@media screen and (max-width: 400px),
screen and (-webkit-min-device-pixel-ratio: 2),
screen and (min-resolution: 192dpi) {
h1 {
font-size: 3em;
margin: 0.3em 0;
}
}

@media screen and (-webkit-min-device-pixel-ratio: 2) and (max-width: 800px) {
h1 {
font-size: 2.2em;
margin: 0.15em 0;
}
}

/* Barre de progression */
#progressBarContainer {
display: flex;
align-items: center;
justify-content: space-between;
gap: 0.5em;
margin: 1em auto 0.3em auto;
max-width: 40ch;
width: 100%;
}

.progress-bar-track {
position: relative;
height: 16px;
background: linear-gradient(to right, #E0F7FA, #355E3B); /* Vert d'eau à vert forêt clair */
border-radius: 6px;
flex: 1;
box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.progress-marker {
position: absolute;
top: 25%;
left: 0;
transform: translate(-50%, -75%);
font-size: 2em;
animation: pulse 1.5s infinite alternate;
transition: left 1.5s ease;
color: #636E72; /* Gris pierre */
pointer-events: none;
}

.side-emoji {
font-size: 1.6em;
line-height: 1;
color: #636E72;
}

@keyframes pulse {
0% { transform: translate(-50%, -50%) scale(1); }
100% { transform: translate(-50%, -50%) scale(1.2); }
}

.level {
font-size: 1.1em;
margin: 0.5em 0;
color: #8B6F47;
text-shadow: 0 1px 2px rgba(139, 111, 71, 0.3);
text-align: center;
}

/* Système d'étoiles pour les hiraganas */
.level-hiraganas {
margin: 1em auto;
width: 100%;
max-width: 800px;
flex-shrink: 0;
}

.hiraganas-grid {
display: flex;
justify-content: center;
gap: 20px;
flex-wrap: wrap;
margin-bottom: 0.5em;
width: 100%;
}

.hiragana-card {
text-align: center;
transition: all 0.3s ease;
position: relative;
padding: 8px;
background: #FFFFFF;
border-radius: 8px;
box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
}

.hiragana-card.completed {
background: #DDE6D5; /* Vert matcha clair */
animation: completedPulse 2s ease-in-out infinite;
}

@keyframes completedPulse {
0%, 100% { transform: scale(1); }
50% { transform: scale(1.05); }
}

.hiragana-char {
font-size: 2.2em;
font-weight: bold;
margin-bottom: 6px;
color: #8B6F47;
text-shadow: 0 0 3px rgba(139, 111, 71, 0.3);
}

.hiragana-card.completed .hiragana-char {
color: #A8D5BA; /* Vert matcha */
text-shadow: 0 0 5px rgba(168, 213, 186, 0.5);
}

.stars-container {
display: flex;
justify-content: center;
gap: 2px;
}

.star {
width: 12px;
height: 12px;
background: #E8ECEF; /* Gris clair */
clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
transition: all 0.3s ease;
}

.star.filled {
background: #FDC1C5; /* Rose sakura */
}

.star.new-star {
animation: starFill 0.5s ease-in-out;
}

.hiragana-card.completed .star.filled {
background: #A8D5BA; /* Vert matcha */
animation: starGlow 2s ease-in-out infinite;
}

@keyframes starFill {
0% { transform: scale(0) rotate(180deg); }
100% { transform: scale(1) rotate(0deg); }
}

@keyframes starGlow {
0%, 100% { filter: brightness(1); }
50% { filter: brightness(1.3); }
}

/* Animation pétales de cerisier */
.sakura {
position: absolute;
width: 10px;
height: 10px;
background: #FDC1C5; /* Rose sakura */
border-radius: 50%;
pointer-events: none;
animation: sakuraFall 3s linear forwards;
z-index: 10;
}

@keyframes sakuraFall {
0% { transform: translateY(0) rotate(0deg); opacity: 1; }
100% { transform: translateY(110vh) rotate(720deg); opacity: 0; }
}

/* Zone de quiz */
.quiz-container {
flex: 1;
display: flex;
flex-direction: column;
justify-content: flex-start;
width: 100%;
height: auto;
min-height: 100vh;
padding: 10px;
box-sizing: border-box;
}

.question {
font-size: 3.5em;
font-weight: bold;
margin: 0.5em 0;
height: 1.2em;
display: flex;
align-items: center;
justify-content: center;
color: #8B6F47;
text-shadow: 0 0 12px #A8D5BA, 0 0 4px #A8D5BA;
}

.answers {
display: flex;
flex-wrap: wrap;
justify-content: center;
gap: 0.8em;
margin-bottom: 1em;
width: 100%;
box-sizing: border-box;
padding: 0 1em;
}

/* Styles boutons bois/domino */
.arcade-button {
position: relative;
background: #F5E8C7; /* Ivoire/bois clair */
background-image: url('https://www.transparenttextures.com/patterns/light-wood.png');
border: 2px solid #8B6F47; /* Marron clair */
border-radius: 10px;
padding: 0.8em 1.5em;
color: #8B6F47;
font-size: 1.4em;
line-height: 0.6;
white-space: normal;
font-weight: bold;
cursor: pointer;
box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2), inset 0 2px 2px rgba(255, 255, 255, 0.3);
transition: all 0.15s ease;
text-shadow: 0 0 8px rgba(139, 111, 71, 0.5);
overflow: hidden;
text-align: center;
}

.arcade-button::before {
content: '';
position: absolute;
top: 0;
left: 0;
right: 0;
height: 50%;
background: linear-gradient(to bottom, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0));
border-top-left-radius: 10px;
border-top-right-radius: 10px;
pointer-events: none;
}

.arcade-button:hover {
transform: translateY(-2px) scale(1.02);
box-shadow: 0 6px 10px rgba(0, 0, 0, 0.25), inset 0 2px 2px rgba(255, 255, 255, 0.3);
border-color: #7A5C3A;
}

.arcade-button:active {
transform: translateY(2px) scale(0.98);
box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2), inset 0 1px 1px rgba(255, 255, 255, 0.3);
}

.arcade-button:disabled {
cursor: not-allowed;
opacity: 0.6;
}

.arcade-button:disabled:hover {
transform: none;
box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2), inset 0 2px 2px rgba(255, 255, 255, 0.3);
border-color: #8B6F47;
}

.arcade-button:disabled:active {
transform: none;
box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2), inset 0 2px 2px rgba(255, 255, 255, 0.3);
}

.arcade-button.clicked-glow {
text-shadow: 0 0 12px #A8D5BA, 0 0 4px #A8D5BA;
animation: glowPulse 1s ease-in-out infinite;
}

.arcade-button.correct {
background: linear-gradient(135deg, #A8D5BA 0%, #DDE6D5 100%); /* Vert matcha */
color: #8B6F47;
border-color: #A8D5BA;
background-image: none;
animation: correctGlow 0.6s ease-in-out;
}

.arcade-button.incorrect {
background: linear-gradient(135deg, #FDC1C5 0%, #FFB6C1 100%); /* Rose sakura */
color: #8B6F47;
border-color: #FDC1C5;
background-image: none;
animation: incorrectShake 0.6s ease-in-out;
}

@keyframes glowPulse {
0%, 100% { text-shadow: 0 0 12px #A8D5BA, 0 0 4px #A8D5BA; }
50% { text-shadow: 0 0 18px #A8D5BA, 0 0 6px #A8D5BA; }
}

@keyframes correctGlow {
0% { box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2), inset 0 2px 2px rgba(255, 255, 255, 0.3); }
50% { box-shadow: 0 6px 10px rgba(0, 0, 0, 0.25), 0 0 20px rgba(168, 213, 186, 0.6); }
100% { box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2), inset 0 2px 2px rgba(255, 255, 255, 0.3); }
}

@keyframes incorrectShake {
0% { transform: translateX(0); }
10% { transform: translateX(-8px); }
20% { transform: translateX(8px); }
30% { transform: translateX(-6px); }
40% { transform: translateX(6px); }
50% { transform: translateX(-4px); }
60% { transform: translateX(4px); }
70% { transform: translateX(-2px); }
80% { transform: translateX(2px); }
90% { transform: translateX(-1px); }
100% { transform: translateX(0); }
}

/* Zone de résultats */
.result {
animation: fadeIn 0.4s ease-in;
font-size: 1.3em;
line-height: 1.4em;
margin: 0.5em 0 0.2em 0;
min-height: 4.5em;
display: flex;
flex-direction: column;
justify-content: flex-start;
text-align: center;
color: #8B6F47;
}

.result-line.highlight {
color: #8B6F47;
}

@keyframes fadeIn {
from { opacity: 0; transform: translateY(10px); }
to { opacity: 1; transform: translateY(0); }
}

#continueBtn {
visibility: hidden;
margin: 0.5em auto;
display: block;
width: fit-content;
}

#boutonInstaller {
margin: 0.5em auto;
height: 3em;
display: none;
}

/* Media queries pour petits écrans */
@media (max-width: 600px) {
.quiz-container {
padding: 5px;
}

.question, .answers {
font-size: 0.9em;
}

.answers {
flex-direction: column;
gap: 0.5em;
}

.progress-marker {
top: 20%;
font-size: 1.5em;
}

.hiragana-char {
font-size: 2em;
}

.star {
width: 10px;
height: 10px;
}

.arcade-button {
font-size: 1.2em;
padding: 0.5em 1em;
}
}

@media screen and (max-width: 768px),
screen and (-webkit-min-device-pixel-ratio: 2),
screen and (min-resolution: 192dpi) {
button, a, input, textarea {
-webkit-tap-highlight-color: transparent;
}

.quiz-container {
flex: 1;
display: flex;
flex-direction: column;
justify-content: flex-start;
min-height: 0;
padding-bottom: 2em;
}

.question {
font-size: 6em; /* Réduit pour éviter débordements */
margin: 0.5em 0;
height: auto;
text-shadow: 0 0 12px #A8D5BA, 0 0 4px #A8D5BA;
}

.answers {
display: grid;
grid-template-columns: repeat(4, 1fr);
gap: 0.8em;
margin-bottom: 1em;
width: 100%;
box-sizing: border-box;
padding: 0 1em;
}

.arcade-button {
font-size: 2em; /* Réduit pour mieux s'adapter */
aspect-ratio: 1 / 0.6;
width: 100%;
box-sizing: border-box;
padding: 0;
display: flex;
align-items: center;
justify-content: center;
text-align: center;
min-width: unset;
}

.level-hiraganas {
max-width: none;
width: 100vw;
padding: 0 2em;
box-sizing: border-box;
}

.hiraganas-grid {
gap: 20px; /* Réduit pour éviter débordements */
justify-content: space-evenly;
}

.hiragana-card {
padding: 5px;
}

.hiragana-char {
font-size: 3em; /* Réduit pour mobile */
margin-bottom: 5px;
}

.stars-container {
gap: 2px;
}

.star {
width: 18px;
height: 18px;
}

.result {
margin-top: 3em; /* Réduit pour éviter débordements */
text-align: center;
word-break: break-word;
white-space: normal;
display: block;
min-height: auto;
}

.result-line {
font-size: 2.5em; /* Réduit pour lisibilité */
width: 100%;
text-align: center;
}

.result-line.highlight {
margin-top: 1em;
font-size: 2em;
}

#progressBarContainer {
max-width: 80%;
margin: 1em auto 0.5em auto;
gap: 0.5em;
}

.progress-bar-track {
height: 20px;
border-radius: 6px;
}

.progress-marker {
font-size: 3em;
top: 25%;
}

.side-emoji {
font-size: 2em;
}

.level {
font-size: 2em;
margin: 0.3em 0;
}

#continueBtn {
margin-top: 1.5em;
margin-bottom: 1.5em;
height: 2.5em;
}

#boutonInstaller {
margin-top: 1.5em;
margin-bottom: 1.5em;
height: 2.5em;
}
}

@media screen and (-webkit-min-device-pixel-ratio: 2) and (max-width: 800px) {
.level-hiraganas {
max-width: none;
width: 100vw;
padding: 0 2em;
box-sizing: border-box;
}

.hiraganas-grid {
width: 100%;
box-sizing: border-box;
justify-content: space-evenly;
gap: 15px;
}

.hiragana-char {
font-size: 4em;
margin-bottom: 5px;
}

.stars-container {
gap: 2px;
}

.star {
width: 14px;
height: 14px;
}

.level {
font-size: 1.5em;
margin: 0.1em 0;
}

#progressBarContainer {
max-width: 80%;
margin: 1em auto 0.5em auto;
gap: 0.5em;
}

.progress-bar-track {
height: 20px;
border-radius: 6px;
}

.progress-marker {
font-size: 3em;
top: 25%;
}

.side-emoji {
font-size: 2em;
}
}

@media (max-height: 700px) {
.hiragana-char {
font-size: 1.6em;
margin-bottom: 4px;
}

.question {
font-size: 4em;
margin: 0.3em 0;
}

.answers {
gap: 0.6em;
margin-bottom: 0.8em;
}

.arcade-button {
padding: 0.4em 0.8em;
font-size: 1em;
}
}

@media (max-height: 600px) {
.hiragana-char {
font-size: 1.4em;
}

.stars-container {
gap: 1px;
}

.star {
width: 10px;
height: 10px;
}

.question {
font-size: 3em;
}

.progress-marker {
font-size: 1.6em;
}

.side-emoji {
font-size: 1.4em;
}
}
</style>
</head>
<body>
<h1>🌿⛩️ Hira-Kata-Quizzz Zen ⛩️🌸</h1>
<div id="progressBarContainer"></div>
<div class="level" id="levelDisplay">Niveau actuel : 1</div>
<div class="level-hiraganas">
<div class="hiraganas-grid" id="hiraganaCards"></div>
</div>
<div class="quiz-container">
<div class="question" id="question">load...</div>
<div>
<div class="answers" id="choices1"></div>
<div class="answers" id="choices2"></div>
</div>
<div>
<div class="result" id="result"></div>
<button class="arcade-button" id="continueBtn" onclick="nextQuestion()">🌱 OK... j’ai capté 🌱</button>
<button class="arcade-button" id="boutonInstaller">Ajouter à l'écran d'accueil</button>
</div>
</div>

<script>
let HiraganaList = [];
let current = {};
let selections = { first: null, second: null };
let targetFields = [];
let isAnswered = false;
let niveauActif = 1;
let previousValidationStates = new Map();
let activeSparks = [];
let globalParticleCount = 0;
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
const MAX_ACTIVE_PARTICLES = isMobile ? 15 : 30;

function logError(msg) {
console.warn(msg);
}

function triggerSakuraFall(container) {
const particleCount = isMobile ? 10 : 30; // Réduit pour mobile
for (let i = 0; i < particleCount; i++) {
const sakura = document.createElement("div");
sakura.className = "sakura";
sakura.style.left = Math.random() * 100 + "vw";
sakura.style.top = "-10px";
sakura.style.animationDelay = Math.random() * 1.5 + "s";
sakura.style.animationDuration = 2.5 + Math.random() * 1.5 + "s";
document.body.appendChild(sakura);
setTimeout(() => sakura.remove(), 4000);
}
}

let audioContext;
let audioInitialized = false;

function initAudio() {
try {
if (!audioInitialized) {
audioContext = new (window.AudioContext || window.webkitAudioContext)();
audioInitialized = true;
}
} catch (error) {
console.error("Erreur lors de l'initialisation audio:", error.message);
}
}

function getValidatedCountForLevel(level) {
return HiraganaList.filter(h => parseInt(h.Niveau) === level && parseInt(h.Validation) >= 5).length;
}

function playMarioCoin() {
initAudio();
const notes = [659.25, 1046.50];
const durations = [0.1, 0.2];
notes.forEach((freq, i) => {
setTimeout(() => {
const osc = audioContext.createOscillator();
const gain = audioContext.createGain();
osc.connect(gain);
gain.connect(audioContext.destination);
osc.type = 'sine';
osc.frequency.value = freq;
gain.gain.setValueAtTime(0.05, audioContext.currentTime);
gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + durations[i]);
osc.start();
osc.stop(audioContext.currentTime + durations[i]);
}, i * 100);
});
}

function playSuccess90s() {
initAudio();
const baseFreq = 587.33;
const osc1 = audioContext.createOscillator();
const gain1 = audioContext.createGain();
const osc2 = audioContext.createOscillator();
const gain2 = audioContext.createGain();
osc1.connect(gain1);
osc2.connect(gain2);
gain1.connect(audioContext.destination);
gain2.connect(audioContext.destination);
osc1.type = 'sine';
osc2.type = 'sine';
osc1.frequency.value = baseFreq;
osc2.frequency.setValueAtTime(baseFreq * 1.5, audioContext.currentTime);
osc2.frequency.exponentialRampToValueAtTime(baseFreq * 3, audioContext.currentTime + 0.3);
gain1.gain.setValueAtTime(0.03, audioContext.currentTime);
gain1.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
gain2.gain.setValueAtTime(0.01, audioContext.currentTime);
gain2.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
osc1.start();
osc2.start();
osc1.stop(audioContext.currentTime + 0.4);
osc2.stop(audioContext.currentTime + 0.3);
}

function playFail() {
initAudio();
const oscillator = audioContext.createOscillator();
const gainNode = audioContext.createGain();
oscillator.connect(gainNode);
gainNode.connect(audioContext.destination);
oscillator.type = 'sine';
gainNode.gain.setValueAtTime(0.04, audioContext.currentTime);
gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
oscillator.frequency.exponentialRampToValueAtTime(110, audioContext.currentTime + 0.4);
oscillator.start(audioContext.currentTime);
oscillator.stop(audioContext.currentTime + 0.4);
}

function playFireworkSound() {
initAudio();
try {
const frequencies = [329.63, 415.30, 523.25, 659.25];
frequencies.forEach((freq, i) => {
setTimeout(() => {
const osc = audioContext.createOscillator();
const gain = audioContext.createGain();
const filter = audioContext.createBiquadFilter();
osc.connect(filter);
filter.connect(gain);
gain.connect(audioContext.destination);
osc.type = 'triangle';
osc.frequency.value = freq;
filter.type = 'lowpass';
filter.frequency.value = freq * 2;
gain.gain.setValueAtTime(0.03, audioContext.currentTime);
gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
osc.start();
osc.stop(audioContext.currentTime + 0.4);
}, i * 150);
});
} catch (error) {
logError('Erreur Firework: ' + error.message);
}
}

function playfireworksound2() {
initAudio();
try {
const sequence = [554.37, 659.25, 830.61, 987.77];
sequence.forEach((freq, i) => {
setTimeout(() => {
const osc = audioContext.createOscillator();
const gain = audioContext.createGain();
osc.connect(gain);
gain.connect(audioContext.destination);
osc.type = 'sine';
osc.frequency.value = freq;
gain.gain.setValueAtTime(0.035, audioContext.currentTime);
gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
osc.start();
osc.stop(audioContext.currentTime + 0.2);
}, i * 100);
});
} catch (error) {
logError('Erreur fireworksound 2: ' + error.message);
}
}

function playfireworksound3() {
initAudio();
try {
const sequence = [659.25, 783.99, 987.77, 1174.66];
sequence.forEach((freq, i) => {
setTimeout(() => {
const osc = audioContext.createOscillator();
const gain = audioContext.createGain();
osc.connect(gain);
gain.connect(audioContext.destination);
osc.type = 'sine';
osc.frequency.value = freq;
gain.gain.setValueAtTime(0.035, audioContext.currentTime);
gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
osc.start();
osc.stop(audioContext.currentTime + 0.2);
}, i * 100);
});
} catch (error) {
logError('Erreur fireworksound 3: ' + error.message);
}
}

function playfireworksound4() {
initAudio();
try {
const sequence = [783.99, 987.77, 1174.66, 1396.91];
sequence.forEach((freq, i) => {
setTimeout(() => {
const osc = audioContext.createOscillator();
const gain = audioContext.createGain();
osc.connect(gain);
gain.connect(audioContext.destination);
osc.type = 'sine';
osc.frequency.value = freq;
gain.gain.setValueAtTime(0.035, audioContext.currentTime);
gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
osc.start();
osc.stop(audioContext.currentTime + 0.2);
}, i * 100);
});
} catch (error) {
logError('Erreur fireworksound 4: ' + error.message);
}
}

function playLevelUp() {
initAudio();
try {
const sequence = [523.25, 659.25, 783.99, 1046.50];
const flourish = [783.99, 1046.50, 1318.51];
sequence.forEach((freq, i) => {
setTimeout(() => {
const osc = audioContext.createOscillator();
const gain = audioContext.createGain();
osc.connect(gain);
gain.connect(audioContext.destination);
osc.type = 'sine';
osc.frequency.value = freq;
gain.gain.setValueAtTime(0.04, audioContext.currentTime);
gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.12);
osc.start();
osc.stop(audioContext.currentTime + 0.12);
}, i * 120);
});
flourish.forEach((freq, i) => {
setTimeout(() => {
const osc = audioContext.createOscillator();
const gain = audioContext.createGain();
osc.connect(gain);
gain.connect(audioContext.destination);
osc.type = 'sine';
osc.frequency.value = freq;
gain.gain.setValueAtTime(0.04, audioContext.currentTime);
gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
osc.start();
osc.stop(audioContext.currentTime + 0.1);
}, 480 + i * 100);
});
setTimeout(() => {
const osc = audioContext.createOscillator();
const gain = audioContext.createGain();
const mod = audioContext.createOscillator();
const modGain = audioContext.createGain();
mod.connect(modGain);
modGain.connect(osc.frequency);
osc.connect(gain);
gain.connect(audioContext.destination);
osc.type = 'sine';
mod.type = 'sine';
osc.frequency.value = 1318.51;
mod.frequency.value = 5;
modGain.gain.value = 10;
gain.gain.setValueAtTime(0.04, audioContext.currentTime);
gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 2.0);
osc.start();
mod.start();
osc.stop(audioContext.currentTime + 2.0);
mod.stop(audioContext.currentTime + 2.0);
}, 780);
} catch (error) {
logError('Erreur Level Up: ' + error.message);
}
}

function drawStar(ctx, x, y, radius, rotation = 0) {
const points = 5;
const outerRadius = radius;
const innerRadius = radius / 2;
ctx.beginPath();
for (let i = 0; i < points * 2; i++) {
const r = i % 2 === 0 ? outerRadius : innerRadius;
const angle = (i * Math.PI / points) + rotation - Math.PI / 2;
ctx.lineTo(
x + r * Math.cos(angle),
y + r * Math.sin(angle)
);
}
ctx.closePath();
ctx.fill();
}

function triggerAdvancedFirework(container) {
initAudio();
const validatedCount = getValidatedCountForLevel(niveauActif);
const canvas = document.createElement('canvas');
canvas.style.position = 'absolute';
canvas.style.left = '50%';
canvas.style.top = '50%';
canvas.style.transform = 'translate(-50%, -50%)';
canvas.style.pointerEvents = 'none';
canvas.style.zIndex = '20';
canvas.width = 400;
canvas.height = 400;
container.appendChild(canvas);
const ctx = canvas.getContext('2d');

const colorPalettes = [
['#6B8E23', '#9ACD32', '#32CD32', '#228B22', '#008000', '#006400'], // Palette verte
['#A8D5BA', '#76FF03', '#64DD17', '#00C853', '#AEEA00', '#00E676'],
['#FDC1C5', '#F48FB1', '#EC407A', '#D81B60', '#AD1457', '#FF80AB'],
];
const colors = colorPalettes[Math.floor(Math.random() * colorPalettes.length)];

const maxLifeBase = isMobile ? 30 : 50;
const numParticles = isMobile ? 9 : 12;
const numSalvos = isMobile ? 3 : 3;
const gravity = 0.1;
const salvoDelay = 150;
const dispersionBase = 3;

const particles = [];
const trails = [];

const halo = document.createElement('div');
halo.style.position = 'absolute';
halo.style.left = '50%';
halo.style.top = '50%';
halo.style.width = '20px';
halo.style.height = '20px';
halo.style.borderRadius = '50%';
halo.style.background = 'radial-gradient(circle, rgba(255,255,255,0.9), rgba(255,255,255,0.05))';
halo.style.transform = 'translate(-50%, -50%) scale(1)';
halo.style.opacity = '1';
halo.style.zIndex = '0';
halo.style.pointerEvents = 'none';
container.appendChild(halo);
halo.animate([
{ transform: 'translate(-50%, -50%) scale(1)', opacity: 1 },
{ transform: 'translate(-50%, -50%) scale(6)', opacity: 0 }
], {
duration: 700,
easing: 'ease-out'
}).onfinish = () => halo.remove();

if (validatedCount === 0) {
playFireworkSound();
} else if (validatedCount === 1) {
playfireworksound2();
} else if (validatedCount === 2) {
playfireworksound3();
} else if (validatedCount === 3) {
playfireworksound4();
} else if (validatedCount === 4) {
playLevelUp();
triggerLevelUpAnimation(container);
}

for (let salvo = 0; salvo < numSalvos; salvo++) {
setTimeout(() => {
if (activeSparks.length >= MAX_ACTIVE_PARTICLES) {
console.warn(`⚠️ Salvo ${salvo} annulée - limite atteinte`);
return;
}

const biasDirection = Math.random() < 0.5 ? -1 : 1;
const biasMagnitude = (Math.random() * 0.2 - 0.1) * biasDirection;

for (let i = 0; i < numParticles; i++) {
if (activeSparks.length >= MAX_ACTIVE_PARTICLES) {
console.warn(`🛑 Particule ${i} du salvo ${salvo} ignorée - limite atteinte`);
break;
}

const angleOffset = (Math.random() * 10 - 5) * (Math.PI / 180);
const angle = angleOffset + (i * (360 / numParticles)) * (Math.PI / 180);
const isUpward = (angle >= 3 * Math.PI / 2 || angle <= Math.PI / 2);
let speed = dispersionBase + Math.random() * 3;
if (isUpward) {
speed = Math.max(7, speed);
if ((angle >= 3 * Math.PI / 2 && biasDirection === -1) || (angle <= Math.PI / 2 && biasDirection === 1)) {
speed *= (1 + biasMagnitude);
}
}

const v0x = speed * Math.cos(angle);
const v0y = speed * Math.sin(angle) * -1;
const color = colors[Math.floor(Math.random() * colors.length)];

particles.push({
x: canvas.width / 2,
y: canvas.height / 2,
vx: v0x,
vy: v0y,
life: maxLifeBase + Math.random() * 20,
maxLife: maxLifeBase + Math.random() * 20,
color: color,
rotation: Math.random() * Math.PI * 2
});
activeSparks.push({ canvas });
globalParticleCount++;
console.log(`Particule ajoutée: ${particles.length} particules, ${activeSparks.length} sparks`);
}
}, salvo * salvoDelay);
}

function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (!isMobile) {
        particles.forEach(p => {
            if (Math.random() < 0.2) {
                trails.push({
                    x: p.x,
                    y: p.y,
                    color: p.color,
                    life: 10
                });
            }
        });
    }

    trails.forEach((t, i) => {
        t.life--;
        if (t.life <= 0) {
            trails.splice(i, 1);
            return;
        }
        ctx.fillStyle = t.color;
        ctx.globalAlpha = t.life / 10 * 0.3;
        ctx.beginPath();
        ctx.arc(t.x, t.y, isMobile ? 2 : 3, 0, 2 * Math.PI);
        ctx.fill();
    });

    particles.forEach((p, i) => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += gravity;
        p.life--;
        p.rotation += 0.05;
        if (p.life <= 0) {
            particles.splice(i, 1);
            activeSparks.splice(i, 1);
            globalParticleCount--;
            return;
        }
        ctx.fillStyle = p.color;
        ctx.globalAlpha = Math.max(0, p.life / p.maxLife);
        ctx.save();
        ctx.translate(p.x, p.y);
        drawStar(ctx, 0, 0, isMobile ? 4 : 6, p.rotation);
        ctx.restore();
    });

    // Correction : Calcul du timestamp de fin une seule fois
    const endTime = Date.now() + numSalvos * salvoDelay;
    if (particles.length > 0 || Date.now() < endTime) {
        requestAnimationFrame(animate);
    } else {
        canvas.remove();
        activeSparks = activeSparks.filter(spark => spark.canvas !== canvas);
        globalParticleCount = Math.max(0, globalParticleCount - particles.length);
        console.log('Animation terminée');
    }
}
requestAnimationFrame(animate);

function cleanupOldParticles() {
while (activeSparks.length > MAX_ACTIVE_PARTICLES) {
const oldSpark = activeSparks.shift();
if (oldSpark && oldSpark.canvas && oldSpark.canvas.parentNode) {
oldSpark.canvas.remove();
globalParticleCount--;
}
}
activeSparks = activeSparks.filter(spark => {
if (!spark.canvas || !spark.canvas.parentNode) {
globalParticleCount--;
return false;
}
return true;
});
console.log(`🧹 Nettoyage: ${activeSparks.length} particules actives, ${globalParticleCount} compteur global`);
}

setInterval(cleanupOldParticles, 3000);

function getMaxLevel(list) {
if (!list || list.length === 0) return 1;
return Math.max(...list.map(k => parseInt(k.Niveau) || 1));
}

function updateStarsForHiragana(hiraganaId, newValidation) {
const cards = document.querySelectorAll('.hiragana-card');
cards.forEach(card => {
const hiraganaChar = card.querySelector('.hiragana-char').textContent;
const hiragana = HiraganaList.find(h => h.Hiragana === hiraganaChar && h.ID == hiraganaId);
if (hiragana) {
const stars = card.querySelectorAll('.star');
const previousValidation = previousValidationStates.get(hiraganaId) || 0;

stars.forEach((star, index) => {
if (index < newValidation && !star.classList.contains('filled')) {
star.classList.add('filled', 'new-star');
setTimeout(() => star.classList.remove('new-star'), 500);
} else if (index < newValidation) {
star.classList.add('filled');
} else {
star.classList.remove('filled', 'new-star');
}
});

if (newValidation >= 5 && previousValidation < 5) {
if (isMobile) {
triggerLightFirework(card);
} else {
triggerAdvancedFirework(card);
}
}

if (newValidation >= 5) {
card.classList.add('completed');
} else {
card.classList.remove('completed');
}

previousValidationStates.set(hiraganaId, newValidation);
}
});
}

function renderHiraganaCards(list, niveau) {
const container = document.getElementById("hiraganaCards");
if (!container) return;
const hiraganas = list.filter(h => parseInt(h.Niveau) === niveau);
container.innerHTML = "";
hiraganas.forEach(hiragana => {
const validation = parseInt(hiragana.Validation || 0);
const isCompleted = validation >= 5;
const card = document.createElement("div");
card.className = `hiragana-card ${isCompleted ? 'completed' : ''}`;
card.innerHTML = `
<div class="hiragana-char">${hiragana.Hiragana}</div>
<div class="stars-container">
${Array.from({length: 5}, (_, i) =>
`<div class="star ${i < validation ? 'filled' : ''}"></div>`
).join('')}
</div>
`;
container.appendChild(card);
previousValidationStates.set(parseInt(hiragana.ID), validation);
});
}

function renderProgressBar(currentLevel, maxLevel) {
const container = document.getElementById("progressBarContainer");
if (!container) return;

container.innerHTML = "";

const leftEmoji = document.createElement("span");
leftEmoji.textContent = "🌱";
leftEmoji.className = "side-emoji";

const rightEmoji = document.createElement("span");
rightEmoji.textContent = "🌳";
rightEmoji.className = "side-emoji";

const barTrack = document.createElement("div");
barTrack.className = "progress-bar-track";

const marker = document.createElement("div");
marker.className = "progress-marker";
marker.innerText = "🐼";

const pct = maxLevel > 1 ? ((currentLevel - 1) / (maxLevel - 1)) * 100 : 0;
marker.style.left = `${Math.min(100, Math.max(0, pct))}%`;

barTrack.appendChild(marker);
container.appendChild(leftEmoji);
container.appendChild(barTrack);
container.appendChild(rightEmoji);
}

function determineNiveauActif(list) {
if (!list || list.length === 0) return 1;
let maxNiveau = Math.max(...list.map(k => parseInt(k.Niveau) || 1));

for (let n = 1; n <= maxNiveau; n++) {
const kanjisNiveau = list.filter(k => parseInt(k.Niveau) === n);
const kanjisValides = kanjisNiveau.filter(k => parseInt(k.Validation) >= 5);
if (kanjisValides.length < kanjisNiveau.length) {
return n;
}
}
return maxNiveau;
}

function updateLevelProgress(list, niveau) {
renderHiraganaCards(list, niveau);
}

// Initialisation avec Google Apps Script
const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbyunFkM7h0FV_xu1GRa4uOiuxeggNSVY1HRCzNungo8QonzHznN0TRNLDOEEOtfQu_8FQ/exec';

async function callAPI(action, data = null) {
try {
if (action === 'updateStats') {
const params = new URLSearchParams({
action,
id: data.id,
scorePoints: data.scorePoints
});
const response = await fetch(`${WEB_APP_URL}?${params}`);
return await response.json();
} else {
const response = await fetch(`${WEB_APP_URL}?action=${action}`);
return await response.json();
}
} catch (error) {
logError('Erreur API: ' + error.message);
return { error: error.message };
}
}

async function initGame() {
const data = await callAPI('getHiraganas');
if (data.error) {
logError('Erreur lors du chargement: ' + data.error);
return;
}

HiraganaList = data;
niveauActif = determineNiveauActif(HiraganaList);
document.getElementById("levelDisplay").innerText = `Niveau actuel : ${niveauActif}`;
updateLevelProgress(HiraganaList, niveauActif);
renderProgressBar(niveauActif, getMaxLevel(HiraganaList));
nextQuestion();
}

function nextQuestion() {
document.getElementById("result").innerText = "";
document.getElementById("continueBtn").style.visibility = "hidden";
selections = { first: null, second: null };
isAnswered = false;

const kanas = HiraganaList.filter(k =>
parseInt(k.Niveau) === niveauActif && parseInt(k.Validation || 0) < 5
);

if (kanas.length === 0) {
const nouveauNiveau = determineNiveauActif(HiraganaList);
if (nouveauNiveau !== niveauActif) {
niveauActif = nouveauNiveau;
document.getElementById("levelDisplay").innerText = `Niveau actuel : ${niveauActif}`;
renderProgressBar(niveauActif, getMaxLevel(HiraganaList));
updateLevelProgress(HiraganaList, niveauActif);
nextQuestion();
return;
}
}

const finalKanas = kanas.length > 0 ? kanas : HiraganaList.filter(k => parseInt(k.Niveau) === niveauActif);

const currentWeights = finalKanas.map(k => {
const validation = parseInt(k.Validation || 0);
return Math.max(0.1, 5 - validation + 0.5);
});

const sum = currentWeights.reduce((a, b) => a + b, 0);
const rand = Math.random() * sum;
let acc = 0;
for (let i = 0; i < finalKanas.length; i++) {
acc += currentWeights[i];
if (rand < acc) {
current = finalKanas[i];
break;
}
}

const modes = [
{ question: "Hiragana", options1: "Katakana", options2: "Romaji" },
{ question: "Katakana", options1: "Hiragana", options2: "Romaji" },
{ question: "Romaji", options1: "Hiragana", options2: "Katakana" }
];
const mode = modes[Math.floor(Math.random() * modes.length)];
targetFields = [mode.options1, mode.options2];

document.getElementById("question").innerText = current[mode.question];
renderChoices("choices1", generateChoices(mode.options1), "first");
renderChoices("choices2", generateChoices(mode.options2), "second");
}

function generateChoices(field) {
const others = HiraganaList.filter(k => k !== current && parseInt(k.Niveau) === niveauActif);
const values = [current[field], ...others.sort(() => 0.5 - Math.random()).slice(0, 3).map(k => k[field])];
return values.sort(() => 0.5 - Math.random());
}

function renderChoices(id, options, slot) {
const container = document.getElementById(id);
container.innerHTML = "";
options.forEach(text => {
const btn = document.createElement("button");
btn.innerText = text;
btn.className = "arcade-button";
btn.onclick = () => {
if (selections[slot] !== null || isAnswered) return;
selections[slot] = text;
btn.classList.add("clicked-glow");
container.querySelectorAll("button").forEach(b => {
b.disabled = true;
if (b !== btn) b.style.opacity = 0.5;
});
checkAnswer();
};
container.appendChild(btn);
});
}

async function checkAnswer() {
if (selections.first && selections.second && !isAnswered) {
isAnswered = true;
const correct1 = current[targetFields[0]];
const correct2 = current[targetFields[1]];
let score = 0;
const containers = [document.getElementById("choices1"), document.getElementById("choices2")];
const correctAnswers = [correct1, correct2];
const userSelections = [selections.first, selections.second];

containers.forEach(container => {
container.querySelectorAll("button").forEach(btn => {
btn.classList.remove("clicked-glow");
});
});

containers.forEach((container, index) => {
const buttons = container.querySelectorAll("button");
buttons.forEach(btn => {
btn.classList.remove("correct", "incorrect");
if (btn.innerText === correctAnswers[index]) {
btn.disabled = false;
btn.style.opacity = '1';
btn.classList.add("correct");
if (btn.innerText === userSelections[index]) {
score += 0.5;
}
} else if (btn.innerText === userSelections[index]) {
btn.disabled = false;
btn.style.opacity = '1';
btn.classList.add("incorrect");
}
});
});

const currentValidation = parseInt(current.Validation || 0);
let newValidation = currentValidation;

if (score === 1) {
newValidation = Math.min(5, currentValidation + 1);
} else if (score === 0.5) {
newValidation = Math.max(0, currentValidation - 1);
} else {
newValidation = Math.max(0, currentValidation - 2);
}

const isFinalValidation = score === 1 && currentValidation < 5 && newValidation >= 5;

updateStarsForHiragana(parseInt(current.ID), newValidation);

const hiraganaIndex = HiraganaList.findIndex(h => h.ID == current.ID);
if (hiraganaIndex !== -1) {
HiraganaList[hiraganaIndex].Validation = newValidation.toString();
}

let emoji = "", resultText = "";
if (score === 1) {
const emojisOK = ["🌸", "🎍", "🍵", "🪴"];
emoji = emojisOK[Math.floor(Math.random() * emojisOK.length)];
resultText = isFinalValidation ? "Validé ! 🎉" : "Parfait !";
if (!isFinalValidation) {
playMarioCoin();
}
} else if (score === 0.5) {
const emojisMid = ["🪨", "🌿", "🪵"];
emoji = emojisMid[Math.floor(Math.random() * emojisMid.length)];
resultText = "Presque...";
playSuccess90s();
} else {
const emojisBad = ["🍂", "🌫️", "🪨"];
emoji = emojisBad[Math.floor(Math.random() * emojisBad.length)];
resultText = "Pas tout à fait...";
playFail();
}

document.getElementById("result").innerHTML = `
<div class="result-line">${emoji} ${resultText} ${emoji}</div>
<div class="result-line highlight">
👉 Bonnes réponses : <strong>${correct1}</strong> – <strong>${correct2}</strong>
</div>`;

if (score === 1) {
document.getElementById("result").innerHTML += "<br><small style='color: #4CAF50;'></small>";
setTimeout(nextQuestion, 1500);
} else {
document.getElementById("continueBtn").style.visibility = "visible";
}

callAPI('updateStats', { id: parseInt(current.ID), scorePoints: score })
.then(response => {
if (response.error) {
console.warn('Erreur sauvegarde:', response.error);
} else {
console.log('✅ Score sauvegardé en arrière-plan');
}
})
.catch(error => {
console.error('Erreur lors de la sauvegarde:', error);
});
}
}

function triggerLightFirework(card) {
const halo = document.createElement("div");
halo.style.position = "absolute";
halo.style.width = "30px";
halo.style.height = "30px";
halo.style.borderRadius = "50%";
halo.style.background = "radial-gradient(circle, rgba(253,193,197,0.9), rgba(253,193,197,0.1))";
halo.style.transform = "translate(-50%, -50%) scale(1)";
halo.style.opacity = "1";
halo.style.pointer-events = "none";
halo.style.zIndex = "10";

const rect = card.getBoundingClientRect();
const cx = rect.left + rect.width / 2;
const cy = rect.top + rect.height / 2;

halo.style.left = `${cx}px`;
halo.style.top = `${cy}px`;
document.body.appendChild(halo);

halo.animate([
{ transform: "translate(-50%, -50%) scale(1)", opacity: 1 },
{ transform: "translate(-50%, -50%) scale(4)", opacity: 0 }
], {
duration: 800,
easing: "ease-out"
}).onfinish = () => halo.remove();

for (let i = 0; i < 5; i++) {
setTimeout(() => {
const sakura = document.createElement("div");
sakura.className = "sakura";
const offsetX = (Math.random() - 0.5) * 80;
const offsetY = (Math.random() - 0.5) * 80;
sakura.style.left = `${cx + offsetX}px`;
sakura.style.top = `${cy + offsetY}px`;
sakura.style.animationDuration = "1.5s";
document.body.appendChild(sakura);
setTimeout(() => sakura.remove(), 1500);
}, i * 250);
}

const validatedCount = getValidatedCountForLevel(niveauActif);
if (validatedCount === 0) {
playFireworkSound();
} else if (validatedCount === 1) {
playfireworksound2();
} else if (validatedCount === 2) {
playfireworksound3();
} else if (validatedCount === 3) {
playfireworksound4();
} else if (validatedCount === 4) {
playLevelUp();
triggerLevelUpAnimation(document.body);
}
}

function triggerLevelUpAnimation(container) {
const toHide = ['#question', '#choices1', '#choices2'];
toHide.forEach(id => {
const el = document.querySelector(id);
if (el) el.style.visibility = 'hidden';
});

triggerSakuraFall(container);

setTimeout(() => {
toHide.forEach(id => {
const el = document.querySelector(id);
if (el) {
el.style.visibility = 'visible';
el.style.opacity = 0;
el.animate([
{ opacity: 0 },
{ opacity: 1 }
], {
duration: 600,
fill: 'forwards'
});
}
});
}, 3000);

const msgWrapper = document.createElement("div");
msgWrapper.style.position = "fixed";
msgWrapper.style.top = "30%";
msgWrapper.style.left = "0";
msgWrapper.style.width = "100vw";
msgWrapper.style.text-align = "center";
msgWrapper.style.zIndex = 9999;
msgWrapper.style.pointer-events = "none";
document.body.appendChild(msgWrapper);

const msg = document.createElement("div");
msg.innerText = "レベルアップ！";
msg.style.display = "inline-block";
msg.style.fontSize = "5em";
msg.style.fontWeight = "bold";
msg.style.color = "#8B6F47";
msg.style.textShadow = "0 0 20px #A8D5BA, 0 0 40px #FDC1C5";
msg.style.writingMode = "horizontal-tb";
msg.style.whiteSpace = "nowrap";
msgWrapper.appendChild(msg);

msg.animate([
{ transform: "translateY(0)", opacity: 1 },
{ transform: "translateY(-40px)", opacity: 0 }
], {
duration: 5000,
easing: "ease-out"
}).onfinish = () => msgWrapper.remove();

const marker = document.querySelector(".progress-marker");
if (marker) {
marker.animate([
{ transform: "translate(-50%, -50%) rotate(0deg) scale(1)" },
{ transform: "translate(-50%, -50%) rotate(180deg) scale(4)" },
{ transform: "translate(-50%, -50%) rotate(360deg) scale(1)" }
], {
duration: 1000,
easing: "ease-in-out"
});
}
}

let deferredPrompt;
window.addEventListener('beforeinstallprompt', (e) => {
e.preventDefault();
deferredPrompt = e;
document.getElementById('boutonInstaller').style.display = 'block';
});

document.getElementById('boutonInstaller').addEventListener('click', () => {
deferredPrompt.prompt();
deferredPrompt.userChoice.then((choiceResult) => {
if (choiceResult.outcome === 'accepted') {
console.log('PWA installée');
}
deferredPrompt = null;
});
});

if ('serviceWorker' in navigator) {
window.addEventListener('load', () => {
navigator.serviceWorker.register('/sw.js').then(
(registration) => {
console.log('Service Worker enregistré:', registration);
},
(error) => {
console.log('Échec Service Worker:', error);
}
);
});
}

window.onload = () => {
initGame();
};
</script>
</body>
</html>
